"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ai-sdk";
exports.ids = ["vendor-chunks/@ai-sdk"];
exports.modules = {

/***/ "(ssr)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@ai-sdk/provider-utils/dist/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asValidator: () => (/* binding */ asValidator),\n/* harmony export */   combineHeaders: () => (/* binding */ combineHeaders),\n/* harmony export */   convertAsyncIteratorToReadableStream: () => (/* binding */ convertAsyncIteratorToReadableStream),\n/* harmony export */   convertBase64ToUint8Array: () => (/* binding */ convertBase64ToUint8Array),\n/* harmony export */   convertUint8ArrayToBase64: () => (/* binding */ convertUint8ArrayToBase64),\n/* harmony export */   createBinaryResponseHandler: () => (/* binding */ createBinaryResponseHandler),\n/* harmony export */   createEventSourceResponseHandler: () => (/* binding */ createEventSourceResponseHandler),\n/* harmony export */   createIdGenerator: () => (/* binding */ createIdGenerator),\n/* harmony export */   createJsonErrorResponseHandler: () => (/* binding */ createJsonErrorResponseHandler),\n/* harmony export */   createJsonResponseHandler: () => (/* binding */ createJsonResponseHandler),\n/* harmony export */   createJsonStreamResponseHandler: () => (/* binding */ createJsonStreamResponseHandler),\n/* harmony export */   createStatusCodeErrorResponseHandler: () => (/* binding */ createStatusCodeErrorResponseHandler),\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   extractResponseHeaders: () => (/* binding */ extractResponseHeaders),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   getFromApi: () => (/* binding */ getFromApi),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isParsableJson: () => (/* binding */ isParsableJson),\n/* harmony export */   isValidator: () => (/* binding */ isValidator),\n/* harmony export */   loadApiKey: () => (/* binding */ loadApiKey),\n/* harmony export */   loadOptionalSetting: () => (/* binding */ loadOptionalSetting),\n/* harmony export */   loadSetting: () => (/* binding */ loadSetting),\n/* harmony export */   parseJSON: () => (/* binding */ parseJSON),\n/* harmony export */   postJsonToApi: () => (/* binding */ postJsonToApi),\n/* harmony export */   postToApi: () => (/* binding */ postToApi),\n/* harmony export */   removeUndefinedEntries: () => (/* binding */ removeUndefinedEntries),\n/* harmony export */   resolve: () => (/* binding */ resolve),\n/* harmony export */   safeParseJSON: () => (/* binding */ safeParseJSON),\n/* harmony export */   safeValidateTypes: () => (/* binding */ safeValidateTypes),\n/* harmony export */   validateTypes: () => (/* binding */ validateTypes),\n/* harmony export */   validator: () => (/* binding */ validator),\n/* harmony export */   validatorSymbol: () => (/* binding */ validatorSymbol),\n/* harmony export */   withoutTrailingSlash: () => (/* binding */ withoutTrailingSlash),\n/* harmony export */   zodValidator: () => (/* binding */ zodValidator)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(ssr)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var secure_json_parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! secure-json-parse */ \"(ssr)/./node_modules/secure-json-parse/index.js\");\n/* harmony import */ var eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! eventsource-parser/stream */ \"(ssr)/./node_modules/eventsource-parser/dist/stream.js\");\n// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n    return headers.reduce((combinedHeaders, currentHeaders)=>({\n            ...combinedHeaders,\n            ...currentHeaders != null ? currentHeaders : {}\n        }), {});\n}\n// src/convert-async-iterator-to-readable-stream.ts\nfunction convertAsyncIteratorToReadableStream(iterator) {\n    return new ReadableStream({\n        /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */ async pull (controller) {\n            try {\n                const { value, done } = await iterator.next();\n                if (done) {\n                    controller.close();\n                } else {\n                    controller.enqueue(value);\n                }\n            } catch (error) {\n                controller.error(error);\n            }\n        },\n        /**\n     * Called when the consumer cancels the stream.\n     */ cancel () {}\n    });\n}\n// src/delay.ts\nasync function delay(delayInMs) {\n    return delayInMs == null ? Promise.resolve() : new Promise((resolve2)=>setTimeout(resolve2, delayInMs));\n}\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n    const headers = {};\n    response.headers.forEach((value, key)=>{\n        headers[key] = value;\n    });\n    return headers;\n}\n// src/generate-id.ts\n\n\nvar createIdGenerator = ({ prefix, size: defaultSize = 16, alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", separator = \"-\" } = {})=>{\n    const generator = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__.customAlphabet)(alphabet, defaultSize);\n    if (prefix == null) {\n        return generator;\n    }\n    if (alphabet.includes(separator)) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n            argument: \"separator\",\n            message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n        });\n    }\n    return (size)=>`${prefix}${separator}${generator(size)}`;\n};\nvar generateId = createIdGenerator();\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n    if (error == null) {\n        return \"unknown error\";\n    }\n    if (typeof error === \"string\") {\n        return error;\n    }\n    if (error instanceof Error) {\n        return error.message;\n    }\n    return JSON.stringify(error);\n}\n// src/get-from-api.ts\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n    return Object.fromEntries(Object.entries(record).filter(([_key, value])=>value != null));\n}\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n    return error instanceof Error && (error.name === \"AbortError\" || error.name === \"TimeoutError\");\n}\n// src/get-from-api.ts\nvar getOriginalFetch = ()=>globalThis.fetch;\nvar getFromApi = async ({ url, headers = {}, successfulResponseHandler, failedResponseHandler, abortSignal, fetch = getOriginalFetch() })=>{\n    try {\n        const response = await fetch(url, {\n            method: \"GET\",\n            headers: removeUndefinedEntries(headers),\n            signal: abortSignal\n        });\n        const responseHeaders = extractResponseHeaders(response);\n        if (!response.ok) {\n            let errorInformation;\n            try {\n                errorInformation = await failedResponseHandler({\n                    response,\n                    url,\n                    requestBodyValues: {}\n                });\n            } catch (error) {\n                if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error)) {\n                    throw error;\n                }\n                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                    message: \"Failed to process error response\",\n                    cause: error,\n                    statusCode: response.status,\n                    url,\n                    responseHeaders,\n                    requestBodyValues: {}\n                });\n            }\n            throw errorInformation.value;\n        }\n        try {\n            return await successfulResponseHandler({\n                response,\n                url,\n                requestBodyValues: {}\n            });\n        } catch (error) {\n            if (error instanceof Error) {\n                if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error)) {\n                    throw error;\n                }\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                message: \"Failed to process successful response\",\n                cause: error,\n                statusCode: response.status,\n                url,\n                responseHeaders,\n                requestBodyValues: {}\n            });\n        }\n    } catch (error) {\n        if (isAbortError(error)) {\n            throw error;\n        }\n        if (error instanceof TypeError && error.message === \"fetch failed\") {\n            const cause = error.cause;\n            if (cause != null) {\n                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                    message: `Cannot connect to API: ${cause.message}`,\n                    cause,\n                    url,\n                    isRetryable: true,\n                    requestBodyValues: {}\n                });\n            }\n        }\n        throw error;\n    }\n};\n// src/load-api-key.ts\n\nfunction loadApiKey({ apiKey, environmentVariableName, apiKeyParameterName = \"apiKey\", description }) {\n    if (typeof apiKey === \"string\") {\n        return apiKey;\n    }\n    if (apiKey != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n            message: `${description} API key must be a string.`\n        });\n    }\n    if (typeof process === \"undefined\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n            message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n        });\n    }\n    apiKey = process.env[environmentVariableName];\n    if (apiKey == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n            message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n        });\n    }\n    if (typeof apiKey !== \"string\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n            message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n        });\n    }\n    return apiKey;\n}\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({ settingValue, environmentVariableName }) {\n    if (typeof settingValue === \"string\") {\n        return settingValue;\n    }\n    if (settingValue != null || typeof process === \"undefined\") {\n        return void 0;\n    }\n    settingValue = process.env[environmentVariableName];\n    if (settingValue == null || typeof settingValue !== \"string\") {\n        return void 0;\n    }\n    return settingValue;\n}\n// src/load-setting.ts\n\nfunction loadSetting({ settingValue, environmentVariableName, settingName, description }) {\n    if (typeof settingValue === \"string\") {\n        return settingValue;\n    }\n    if (settingValue != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n            message: `${description} setting must be a string.`\n        });\n    }\n    if (typeof process === \"undefined\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n            message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n        });\n    }\n    settingValue = process.env[environmentVariableName];\n    if (settingValue == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n            message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n        });\n    }\n    if (typeof settingValue !== \"string\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n            message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n        });\n    }\n    return settingValue;\n}\n// src/parse-json.ts\n\n\n// src/validate-types.ts\n\n// src/validator.ts\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n    return {\n        [validatorSymbol]: true,\n        validate\n    };\n}\nfunction isValidator(value) {\n    return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n    return isValidator(value) ? value : zodValidator(value);\n}\nfunction zodValidator(zodSchema) {\n    return validator((value)=>{\n        const result = zodSchema.safeParse(value);\n        return result.success ? {\n            success: true,\n            value: result.data\n        } : {\n            success: false,\n            error: result.error\n        };\n    });\n}\n// src/validate-types.ts\nfunction validateTypes({ value, schema: inputSchema }) {\n    const result = safeValidateTypes({\n        value,\n        schema: inputSchema\n    });\n    if (!result.success) {\n        throw _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({\n            value,\n            cause: result.error\n        });\n    }\n    return result.value;\n}\nfunction safeValidateTypes({ value, schema }) {\n    const validator2 = asValidator(schema);\n    try {\n        if (validator2.validate == null) {\n            return {\n                success: true,\n                value\n            };\n        }\n        const result = validator2.validate(value);\n        if (result.success) {\n            return result;\n        }\n        return {\n            success: false,\n            error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({\n                value,\n                cause: result.error\n            })\n        };\n    } catch (error) {\n        return {\n            success: false,\n            error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({\n                value,\n                cause: error\n            })\n        };\n    }\n}\n// src/parse-json.ts\nfunction parseJSON({ text, schema }) {\n    try {\n        const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n        if (schema == null) {\n            return value;\n        }\n        return validateTypes({\n            value,\n            schema\n        });\n    } catch (error) {\n        if (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isInstance(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.isInstance(error)) {\n            throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({\n            text,\n            cause: error\n        });\n    }\n}\nfunction safeParseJSON({ text, schema }) {\n    try {\n        const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n        if (schema == null) {\n            return {\n                success: true,\n                value,\n                rawValue: value\n            };\n        }\n        const validationResult = safeValidateTypes({\n            value,\n            schema\n        });\n        return validationResult.success ? {\n            ...validationResult,\n            rawValue: value\n        } : validationResult;\n    } catch (error) {\n        return {\n            success: false,\n            error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isInstance(error) ? error : new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({\n                text,\n                cause: error\n            })\n        };\n    }\n}\nfunction isParsableJson(input) {\n    try {\n        secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(input);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n// src/post-to-api.ts\n\nvar getOriginalFetch2 = ()=>globalThis.fetch;\nvar postJsonToApi = async ({ url, headers, body, failedResponseHandler, successfulResponseHandler, abortSignal, fetch })=>postToApi({\n        url,\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        body: {\n            content: JSON.stringify(body),\n            values: body\n        },\n        failedResponseHandler,\n        successfulResponseHandler,\n        abortSignal,\n        fetch\n    });\nvar postToApi = async ({ url, headers = {}, body, successfulResponseHandler, failedResponseHandler, abortSignal, fetch = getOriginalFetch2() })=>{\n    try {\n        const response = await fetch(url, {\n            method: \"POST\",\n            headers: removeUndefinedEntries(headers),\n            body: body.content,\n            signal: abortSignal\n        });\n        const responseHeaders = extractResponseHeaders(response);\n        if (!response.ok) {\n            let errorInformation;\n            try {\n                errorInformation = await failedResponseHandler({\n                    response,\n                    url,\n                    requestBodyValues: body.values\n                });\n            } catch (error) {\n                if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error)) {\n                    throw error;\n                }\n                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                    message: \"Failed to process error response\",\n                    cause: error,\n                    statusCode: response.status,\n                    url,\n                    responseHeaders,\n                    requestBodyValues: body.values\n                });\n            }\n            throw errorInformation.value;\n        }\n        try {\n            return await successfulResponseHandler({\n                response,\n                url,\n                requestBodyValues: body.values\n            });\n        } catch (error) {\n            if (error instanceof Error) {\n                if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error)) {\n                    throw error;\n                }\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                message: \"Failed to process successful response\",\n                cause: error,\n                statusCode: response.status,\n                url,\n                responseHeaders,\n                requestBodyValues: body.values\n            });\n        }\n    } catch (error) {\n        if (isAbortError(error)) {\n            throw error;\n        }\n        if (error instanceof TypeError && error.message === \"fetch failed\") {\n            const cause = error.cause;\n            if (cause != null) {\n                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                    message: `Cannot connect to API: ${cause.message}`,\n                    cause,\n                    url,\n                    requestBodyValues: body.values,\n                    isRetryable: true\n                });\n            }\n        }\n        throw error;\n    }\n};\n// src/resolve.ts\nasync function resolve(value) {\n    if (typeof value === \"function\") {\n        value = value();\n    }\n    return Promise.resolve(value);\n}\n// src/response-handler.ts\n\n\nvar createJsonErrorResponseHandler = ({ errorSchema, errorToMessage, isRetryable })=>async ({ response, url, requestBodyValues })=>{\n        const responseBody = await response.text();\n        const responseHeaders = extractResponseHeaders(response);\n        if (responseBody.trim() === \"\") {\n            return {\n                responseHeaders,\n                value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                    message: response.statusText,\n                    url,\n                    requestBodyValues,\n                    statusCode: response.status,\n                    responseHeaders,\n                    responseBody,\n                    isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n                })\n            };\n        }\n        try {\n            const parsedError = parseJSON({\n                text: responseBody,\n                schema: errorSchema\n            });\n            return {\n                responseHeaders,\n                value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                    message: errorToMessage(parsedError),\n                    url,\n                    requestBodyValues,\n                    statusCode: response.status,\n                    responseHeaders,\n                    responseBody,\n                    data: parsedError,\n                    isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n                })\n            };\n        } catch (parseError) {\n            return {\n                responseHeaders,\n                value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                    message: response.statusText,\n                    url,\n                    requestBodyValues,\n                    statusCode: response.status,\n                    responseHeaders,\n                    responseBody,\n                    isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n                })\n            };\n        }\n    };\nvar createEventSourceResponseHandler = (chunkSchema)=>async ({ response })=>{\n        const responseHeaders = extractResponseHeaders(response);\n        if (response.body == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n        }\n        return {\n            responseHeaders,\n            value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_3__.EventSourceParserStream()).pipeThrough(new TransformStream({\n                transform ({ data }, controller) {\n                    if (data === \"[DONE]\") {\n                        return;\n                    }\n                    controller.enqueue(safeParseJSON({\n                        text: data,\n                        schema: chunkSchema\n                    }));\n                }\n            }))\n        };\n    };\nvar createJsonStreamResponseHandler = (chunkSchema)=>async ({ response })=>{\n        const responseHeaders = extractResponseHeaders(response);\n        if (response.body == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n        }\n        let buffer = \"\";\n        return {\n            responseHeaders,\n            value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({\n                transform (chunkText, controller) {\n                    if (chunkText.endsWith(\"\\n\")) {\n                        controller.enqueue(safeParseJSON({\n                            text: buffer + chunkText,\n                            schema: chunkSchema\n                        }));\n                        buffer = \"\";\n                    } else {\n                        buffer += chunkText;\n                    }\n                }\n            }))\n        };\n    };\nvar createJsonResponseHandler = (responseSchema)=>async ({ response, url, requestBodyValues })=>{\n        const responseBody = await response.text();\n        const parsedResult = safeParseJSON({\n            text: responseBody,\n            schema: responseSchema\n        });\n        const responseHeaders = extractResponseHeaders(response);\n        if (!parsedResult.success) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                message: \"Invalid JSON response\",\n                cause: parsedResult.error,\n                statusCode: response.status,\n                responseHeaders,\n                responseBody,\n                url,\n                requestBodyValues\n            });\n        }\n        return {\n            responseHeaders,\n            value: parsedResult.value,\n            rawValue: parsedResult.rawValue\n        };\n    };\nvar createBinaryResponseHandler = ()=>async ({ response, url, requestBodyValues })=>{\n        const responseHeaders = extractResponseHeaders(response);\n        if (!response.body) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                message: \"Response body is empty\",\n                url,\n                requestBodyValues,\n                statusCode: response.status,\n                responseHeaders,\n                responseBody: void 0\n            });\n        }\n        try {\n            const buffer = await response.arrayBuffer();\n            return {\n                responseHeaders,\n                value: new Uint8Array(buffer)\n            };\n        } catch (error) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                message: \"Failed to read response as array buffer\",\n                url,\n                requestBodyValues,\n                statusCode: response.status,\n                responseHeaders,\n                responseBody: void 0,\n                cause: error\n            });\n        }\n    };\nvar createStatusCodeErrorResponseHandler = ()=>async ({ response, url, requestBodyValues })=>{\n        const responseHeaders = extractResponseHeaders(response);\n        const responseBody = await response.text();\n        return {\n            responseHeaders,\n            value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                message: response.statusText,\n                url,\n                requestBodyValues,\n                statusCode: response.status,\n                responseHeaders,\n                responseBody\n            })\n        };\n    };\n// src/uint8-utils.ts\nvar { btoa, atob } = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n    const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const latin1string = atob(base64Url);\n    return Uint8Array.from(latin1string, (byte)=>byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n    let latin1string = \"\";\n    for(let i = 0; i < array.length; i++){\n        latin1string += String.fromCodePoint(array[i]);\n    }\n    return btoa(latin1string);\n}\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n    return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx5QkFBeUI7QUFDekIsU0FBU0EsZUFBZSxHQUFHQyxPQUFPO0lBQ2hDLE9BQU9BLFFBQVFDLE1BQU0sQ0FDbkIsQ0FBQ0MsaUJBQWlCQyxpQkFBb0I7WUFDcEMsR0FBR0QsZUFBZTtZQUNsQixHQUFHQyxrQkFBa0IsT0FBT0EsaUJBQWlCLENBQUMsQ0FBQztRQUNqRCxJQUNBLENBQUM7QUFFTDtBQUVBLG1EQUFtRDtBQUNuRCxTQUFTQyxxQ0FBcUNDLFFBQVE7SUFDcEQsT0FBTyxJQUFJQyxlQUFlO1FBQ3hCOzs7OztLQUtDLEdBQ0QsTUFBTUMsTUFBS0MsVUFBVTtZQUNuQixJQUFJO2dCQUNGLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUUsR0FBRyxNQUFNTCxTQUFTTSxJQUFJO2dCQUMzQyxJQUFJRCxNQUFNO29CQUNSRixXQUFXSSxLQUFLO2dCQUNsQixPQUFPO29CQUNMSixXQUFXSyxPQUFPLENBQUNKO2dCQUNyQjtZQUNGLEVBQUUsT0FBT0ssT0FBTztnQkFDZE4sV0FBV00sS0FBSyxDQUFDQTtZQUNuQjtRQUNGO1FBQ0E7O0tBRUMsR0FDREMsV0FDQTtJQUNGO0FBQ0Y7QUFFQSxlQUFlO0FBQ2YsZUFBZUMsTUFBTUMsU0FBUztJQUM1QixPQUFPQSxhQUFhLE9BQU9DLFFBQVFDLE9BQU8sS0FBSyxJQUFJRCxRQUFRLENBQUNFLFdBQWFDLFdBQVdELFVBQVVIO0FBQ2hHO0FBRUEsa0NBQWtDO0FBQ2xDLFNBQVNLLHVCQUF1QkMsUUFBUTtJQUN0QyxNQUFNdkIsVUFBVSxDQUFDO0lBQ2pCdUIsU0FBU3ZCLE9BQU8sQ0FBQ3dCLE9BQU8sQ0FBQyxDQUFDZixPQUFPZ0I7UUFDL0J6QixPQUFPLENBQUN5QixJQUFJLEdBQUdoQjtJQUNqQjtJ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aGVybG9nLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXItdXRpbHMvZGlzdC9pbmRleC5tanM/YTcxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29tYmluZS1oZWFkZXJzLnRzXG5mdW5jdGlvbiBjb21iaW5lSGVhZGVycyguLi5oZWFkZXJzKSB7XG4gIHJldHVybiBoZWFkZXJzLnJlZHVjZShcbiAgICAoY29tYmluZWRIZWFkZXJzLCBjdXJyZW50SGVhZGVycykgPT4gKHtcbiAgICAgIC4uLmNvbWJpbmVkSGVhZGVycyxcbiAgICAgIC4uLmN1cnJlbnRIZWFkZXJzICE9IG51bGwgPyBjdXJyZW50SGVhZGVycyA6IHt9XG4gICAgfSksXG4gICAge31cbiAgKTtcbn1cblxuLy8gc3JjL2NvbnZlcnQtYXN5bmMtaXRlcmF0b3ItdG8tcmVhZGFibGUtc3RyZWFtLnRzXG5mdW5jdGlvbiBjb252ZXJ0QXN5bmNJdGVyYXRvclRvUmVhZGFibGVTdHJlYW0oaXRlcmF0b3IpIHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbnN1bWVyIHdhbnRzIHRvIHB1bGwgbW9yZSBkYXRhIGZyb20gdGhlIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxUPn0gY29udHJvbGxlciAtIFRoZSBjb250cm9sbGVyIHRvIGVucXVldWUgZGF0YSBpbnRvIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbnN1bWVyIGNhbmNlbHMgdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBjYW5jZWwoKSB7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2RlbGF5LnRzXG5hc3luYyBmdW5jdGlvbiBkZWxheShkZWxheUluTXMpIHtcbiAgcmV0dXJuIGRlbGF5SW5NcyA9PSBudWxsID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZTIpID0+IHNldFRpbWVvdXQocmVzb2x2ZTIsIGRlbGF5SW5NcykpO1xufVxuXG4vLyBzcmMvZXh0cmFjdC1yZXNwb25zZS1oZWFkZXJzLnRzXG5mdW5jdGlvbiBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gaGVhZGVycztcbn1cblxuLy8gc3JjL2dlbmVyYXRlLWlkLnRzXG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBjdXN0b21BbHBoYWJldCB9IGZyb20gXCJuYW5vaWQvbm9uLXNlY3VyZVwiO1xudmFyIGNyZWF0ZUlkR2VuZXJhdG9yID0gKHtcbiAgcHJlZml4LFxuICBzaXplOiBkZWZhdWx0U2l6ZSA9IDE2LFxuICBhbHBoYWJldCA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIixcbiAgc2VwYXJhdG9yID0gXCItXCJcbn0gPSB7fSkgPT4ge1xuICBjb25zdCBnZW5lcmF0b3IgPSBjdXN0b21BbHBoYWJldChhbHBoYWJldCwgZGVmYXVsdFNpemUpO1xuICBpZiAocHJlZml4ID09IG51bGwpIHtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGlmIChhbHBoYWJldC5pbmNsdWRlcyhzZXBhcmF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgIGFyZ3VtZW50OiBcInNlcGFyYXRvclwiLFxuICAgICAgbWVzc2FnZTogYFRoZSBzZXBhcmF0b3IgXCIke3NlcGFyYXRvcn1cIiBtdXN0IG5vdCBiZSBwYXJ0IG9mIHRoZSBhbHBoYWJldCBcIiR7YWxwaGFiZXR9XCIuYFxuICAgIH0pO1xuICB9XG4gIHJldHVybiAoc2l6ZSkgPT4gYCR7cHJlZml4fSR7c2VwYXJhdG9yfSR7Z2VuZXJhdG9yKHNpemUpfWA7XG59O1xudmFyIGdlbmVyYXRlSWQgPSBjcmVhdGVJZEdlbmVyYXRvcigpO1xuXG4vLyBzcmMvZ2V0LWVycm9yLW1lc3NhZ2UudHNcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBcInVua25vd24gZXJyb3JcIjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbn1cblxuLy8gc3JjL2dldC1mcm9tLWFwaS50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gc3JjL3JlbW92ZS11bmRlZmluZWQtZW50cmllcy50c1xuZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkRW50cmllcyhyZWNvcmQpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhyZWNvcmQpLmZpbHRlcigoW19rZXksIHZhbHVlXSkgPT4gdmFsdWUgIT0gbnVsbClcbiAgKTtcbn1cblxuLy8gc3JjL2lzLWFib3J0LWVycm9yLnRzXG5mdW5jdGlvbiBpc0Fib3J0RXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgKGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiIHx8IGVycm9yLm5hbWUgPT09IFwiVGltZW91dEVycm9yXCIpO1xufVxuXG4vLyBzcmMvZ2V0LWZyb20tYXBpLnRzXG52YXIgZ2V0T3JpZ2luYWxGZXRjaCA9ICgpID0+IGdsb2JhbFRoaXMuZmV0Y2g7XG52YXIgZ2V0RnJvbUFwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyA9IHt9LFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaCA9IGdldE9yaWdpbmFsRmV0Y2goKVxufSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzOiByZW1vdmVVbmRlZmluZWRFbnRyaWVzKGhlYWRlcnMpLFxuICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckluZm9ybWF0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JJbmZvcm1hdGlvbiA9IGF3YWl0IGZhaWxlZFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiB7fVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvci5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3MgZXJyb3IgcmVzcG9uc2VcIixcbiAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHt9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JJbmZvcm1hdGlvbi52YWx1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHt9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgQVBJQ2FsbEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcIixcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczoge31cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiBlcnJvci5tZXNzYWdlID09PSBcImZldGNoIGZhaWxlZFwiKSB7XG4gICAgICBjb25zdCBjYXVzZSA9IGVycm9yLmNhdXNlO1xuICAgICAgaWYgKGNhdXNlICE9IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogYENhbm5vdCBjb25uZWN0IHRvIEFQSTogJHtjYXVzZS5tZXNzYWdlfWAsXG4gICAgICAgICAgY2F1c2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGlzUmV0cnlhYmxlOiB0cnVlLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiB7fVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIHNyYy9sb2FkLWFwaS1rZXkudHNcbmltcG9ydCB7IExvYWRBUElLZXlFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBsb2FkQXBpS2V5KHtcbiAgYXBpS2V5LFxuICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZSxcbiAgYXBpS2V5UGFyYW1ldGVyTmFtZSA9IFwiYXBpS2V5XCIsXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIGlmICh0eXBlb2YgYXBpS2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGFwaUtleTtcbiAgfVxuICBpZiAoYXBpS2V5ICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IG11c3QgYmUgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7YXBpS2V5UGFyYW1ldGVyTmFtZX0nIHBhcmFtZXRlci4gRW52aXJvbm1lbnQgdmFyaWFibGVzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC5gXG4gICAgfSk7XG4gIH1cbiAgYXBpS2V5ID0gcHJvY2Vzcy5lbnZbZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVdO1xuICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke2FwaUtleVBhcmFtZXRlck5hbWV9JyBwYXJhbWV0ZXIgb3IgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIGFwaUtleSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgbXVzdCBiZSBhIHN0cmluZy4gVGhlIHZhbHVlIG9mIHRoZSAke2Vudmlyb25tZW50VmFyaWFibGVOYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3QgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBhcGlLZXk7XG59XG5cbi8vIHNyYy9sb2FkLW9wdGlvbmFsLXNldHRpbmcudHNcbmZ1bmN0aW9uIGxvYWRPcHRpb25hbFNldHRpbmcoe1xuICBzZXR0aW5nVmFsdWUsXG4gIGVudmlyb25tZW50VmFyaWFibGVOYW1lXG59KSB7XG4gIGlmICh0eXBlb2Ygc2V0dGluZ1ZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbiAgfVxuICBpZiAoc2V0dGluZ1ZhbHVlICE9IG51bGwgfHwgdHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHNldHRpbmdWYWx1ZSA9IHByb2Nlc3MuZW52W2Vudmlyb25tZW50VmFyaWFibGVOYW1lXTtcbiAgaWYgKHNldHRpbmdWYWx1ZSA9PSBudWxsIHx8IHR5cGVvZiBzZXR0aW5nVmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBzZXR0aW5nVmFsdWU7XG59XG5cbi8vIHNyYy9sb2FkLXNldHRpbmcudHNcbmltcG9ydCB7IExvYWRTZXR0aW5nRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gbG9hZFNldHRpbmcoe1xuICBzZXR0aW5nVmFsdWUsXG4gIGVudmlyb25tZW50VmFyaWFibGVOYW1lLFxuICBzZXR0aW5nTmFtZSxcbiAgZGVzY3JpcHRpb25cbn0pIHtcbiAgaWYgKHR5cGVvZiBzZXR0aW5nVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xuICB9XG4gIGlmIChzZXR0aW5nVmFsdWUgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIG11c3QgYmUgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke3NldHRpbmdOYW1lfScgcGFyYW1ldGVyLiBFbnZpcm9ubWVudCB2YXJpYWJsZXMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LmBcbiAgICB9KTtcbiAgfVxuICBzZXR0aW5nVmFsdWUgPSBwcm9jZXNzLmVudltlbnZpcm9ubWVudFZhcmlhYmxlTmFtZV07XG4gIGlmIChzZXR0aW5nVmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke3NldHRpbmdOYW1lfScgcGFyYW1ldGVyIG9yIHRoZSAke2Vudmlyb25tZW50VmFyaWFibGVOYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZS5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZXR0aW5nVmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgTG9hZFNldHRpbmdFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gc2V0dGluZyBtdXN0IGJlIGEgc3RyaW5nLiBUaGUgdmFsdWUgb2YgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbn1cblxuLy8gc3JjL3BhcnNlLWpzb24udHNcbmltcG9ydCB7XG4gIEpTT05QYXJzZUVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3IyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgU2VjdXJlSlNPTiBmcm9tIFwic2VjdXJlLWpzb24tcGFyc2VcIjtcblxuLy8gc3JjL3ZhbGlkYXRlLXR5cGVzLnRzXG5pbXBvcnQgeyBUeXBlVmFsaWRhdGlvbkVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gc3JjL3ZhbGlkYXRvci50c1xudmFyIHZhbGlkYXRvclN5bWJvbCA9IFN5bWJvbC5mb3IoXCJ2ZXJjZWwuYWkudmFsaWRhdG9yXCIpO1xuZnVuY3Rpb24gdmFsaWRhdG9yKHZhbGlkYXRlKSB7XG4gIHJldHVybiB7IFt2YWxpZGF0b3JTeW1ib2xdOiB0cnVlLCB2YWxpZGF0ZSB9O1xufVxuZnVuY3Rpb24gaXNWYWxpZGF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWxpZGF0b3JTeW1ib2wgaW4gdmFsdWUgJiYgdmFsdWVbdmFsaWRhdG9yU3ltYm9sXSA9PT0gdHJ1ZSAmJiBcInZhbGlkYXRlXCIgaW4gdmFsdWU7XG59XG5mdW5jdGlvbiBhc1ZhbGlkYXRvcih2YWx1ZSkge1xuICByZXR1cm4gaXNWYWxpZGF0b3IodmFsdWUpID8gdmFsdWUgOiB6b2RWYWxpZGF0b3IodmFsdWUpO1xufVxuZnVuY3Rpb24gem9kVmFsaWRhdG9yKHpvZFNjaGVtYSkge1xuICByZXR1cm4gdmFsaWRhdG9yKCh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHpvZFNjaGVtYS5zYWZlUGFyc2UodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQuc3VjY2VzcyA/IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdC5kYXRhIH0gOiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmVzdWx0LmVycm9yIH07XG4gIH0pO1xufVxuXG4vLyBzcmMvdmFsaWRhdGUtdHlwZXMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZXMoe1xuICB2YWx1ZSxcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYVxufSkge1xuICBjb25zdCByZXN1bHQgPSBzYWZlVmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWE6IGlucHV0U2NoZW1hIH0pO1xuICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgVHlwZVZhbGlkYXRpb25FcnJvci53cmFwKHsgdmFsdWUsIGNhdXNlOiByZXN1bHQuZXJyb3IgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn1cbmZ1bmN0aW9uIHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgdmFsdWUsXG4gIHNjaGVtYVxufSkge1xuICBjb25zdCB2YWxpZGF0b3IyID0gYXNWYWxpZGF0b3Ioc2NoZW1hKTtcbiAgdHJ5IHtcbiAgICBpZiAodmFsaWRhdG9yMi52YWxpZGF0ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSB9O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IyLnZhbGlkYXRlKHZhbHVlKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBUeXBlVmFsaWRhdGlvbkVycm9yLndyYXAoeyB2YWx1ZSwgY2F1c2U6IHJlc3VsdC5lcnJvciB9KVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IFR5cGVWYWxpZGF0aW9uRXJyb3Iud3JhcCh7IHZhbHVlLCBjYXVzZTogZXJyb3IgfSlcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9wYXJzZS1qc29uLnRzXG5mdW5jdGlvbiBwYXJzZUpTT04oe1xuICB0ZXh0LFxuICBzY2hlbWFcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB2YWx1ZSA9IFNlY3VyZUpTT04ucGFyc2UodGV4dCk7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoSlNPTlBhcnNlRXJyb3IuaXNJbnN0YW5jZShlcnJvcikgfHwgVHlwZVZhbGlkYXRpb25FcnJvcjIuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSlNPTlBhcnNlRXJyb3IoeyB0ZXh0LCBjYXVzZTogZXJyb3IgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNhZmVQYXJzZUpTT04oe1xuICB0ZXh0LFxuICBzY2hlbWFcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB2YWx1ZSA9IFNlY3VyZUpTT04ucGFyc2UodGV4dCk7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSwgcmF3VmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBzYWZlVmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWEgfSk7XG4gICAgcmV0dXJuIHZhbGlkYXRpb25SZXN1bHQuc3VjY2VzcyA/IHsgLi4udmFsaWRhdGlvblJlc3VsdCwgcmF3VmFsdWU6IHZhbHVlIH0gOiB2YWxpZGF0aW9uUmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBKU09OUGFyc2VFcnJvci5pc0luc3RhbmNlKGVycm9yKSA/IGVycm9yIDogbmV3IEpTT05QYXJzZUVycm9yKHsgdGV4dCwgY2F1c2U6IGVycm9yIH0pXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQYXJzYWJsZUpzb24oaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICBTZWN1cmVKU09OLnBhcnNlKGlucHV0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBzcmMvcG9zdC10by1hcGkudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBnZXRPcmlnaW5hbEZldGNoMiA9ICgpID0+IGdsb2JhbFRoaXMuZmV0Y2g7XG52YXIgcG9zdEpzb25Ub0FwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2hcbn0pID0+IHBvc3RUb0FwaSh7XG4gIHVybCxcbiAgaGVhZGVyczoge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIC4uLmhlYWRlcnNcbiAgfSxcbiAgYm9keToge1xuICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgIHZhbHVlczogYm9keVxuICB9LFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaFxufSk7XG52YXIgcG9zdFRvQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzID0ge30sXG4gIGJvZHksXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoID0gZ2V0T3JpZ2luYWxGZXRjaDIoKVxufSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogcmVtb3ZlVW5kZWZpbmVkRW50cmllcyhoZWFkZXJzKSxcbiAgICAgIGJvZHk6IGJvZHkuY29udGVudCxcbiAgICAgIHNpZ25hbDogYWJvcnRTaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsZXQgZXJyb3JJbmZvcm1hdGlvbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9ySW5mb3JtYXRpb24gPSBhd2FpdCBmYWlsZWRSZXNwb25zZUhhbmRsZXIoe1xuICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSB8fCBBUElDYWxsRXJyb3IyLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3MgZXJyb3IgcmVzcG9uc2VcIixcbiAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JJbmZvcm1hdGlvbi52YWx1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgQVBJQ2FsbEVycm9yMi5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yMih7XG4gICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3Mgc3VjY2Vzc2Z1bCByZXNwb25zZVwiLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVycm9yLm1lc3NhZ2UgPT09IFwiZmV0Y2ggZmFpbGVkXCIpIHtcbiAgICAgIGNvbnN0IGNhdXNlID0gZXJyb3IuY2F1c2U7XG4gICAgICBpZiAoY2F1c2UgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yMih7XG4gICAgICAgICAgbWVzc2FnZTogYENhbm5vdCBjb25uZWN0IHRvIEFQSTogJHtjYXVzZS5tZXNzYWdlfWAsXG4gICAgICAgICAgY2F1c2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlcyxcbiAgICAgICAgICBpc1JldHJ5YWJsZTogdHJ1ZVxuICAgICAgICAgIC8vIHJldHJ5IHdoZW4gbmV0d29yayBlcnJvclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIHNyYy9yZXNvbHZlLnRzXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbn1cblxuLy8gc3JjL3Jlc3BvbnNlLWhhbmRsZXIudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IzLCBFbXB0eVJlc3BvbnNlQm9keUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIEV2ZW50U291cmNlUGFyc2VyU3RyZWFtXG59IGZyb20gXCJldmVudHNvdXJjZS1wYXJzZXIvc3RyZWFtXCI7XG52YXIgY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyID0gKHtcbiAgZXJyb3JTY2hlbWEsXG4gIGVycm9yVG9NZXNzYWdlLFxuICBpc1JldHJ5YWJsZVxufSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2VCb2R5LnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjMoe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkRXJyb3IgPSBwYXJzZUpTT04oe1xuICAgICAgdGV4dDogcmVzcG9uc2VCb2R5LFxuICAgICAgc2NoZW1hOiBlcnJvclNjaGVtYVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjMoe1xuICAgICAgICBtZXNzYWdlOiBlcnJvclRvTWVzc2FnZShwYXJzZWRFcnJvciksXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXNwb25zZUJvZHksXG4gICAgICAgIGRhdGE6IHBhcnNlZEVycm9yLFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlLCBwYXJzZWRFcnJvcilcbiAgICAgIH0pXG4gICAgfTtcbiAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjMoe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9O1xuICB9XG59O1xudmFyIGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyID0gKGNodW5rU2NoZW1hKSA9PiBhc3luYyAoeyByZXNwb25zZSB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVtcHR5UmVzcG9uc2VCb2R5RXJyb3Ioe30pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChuZXcgRXZlbnRTb3VyY2VQYXJzZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKHsgZGF0YSB9LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKGRhdGEgPT09IFwiW0RPTkVdXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgc2FmZVBhcnNlSlNPTih7XG4gICAgICAgICAgICAgIHRleHQ6IGRhdGEsXG4gICAgICAgICAgICAgIHNjaGVtYTogY2h1bmtTY2hlbWFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gIH07XG59O1xudmFyIGNyZWF0ZUpzb25TdHJlYW1SZXNwb25zZUhhbmRsZXIgPSAoY2h1bmtTY2hlbWEpID0+IGFzeW5jICh7IHJlc3BvbnNlIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmIChyZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRW1wdHlSZXNwb25zZUJvZHlFcnJvcih7fSk7XG4gIH1cbiAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oY2h1bmtUZXh0LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKGNodW5rVGV4dC5lbmRzV2l0aChcIlxcblwiKSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBzYWZlUGFyc2VKU09OKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBidWZmZXIgKyBjaHVua1RleHQsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBjaHVua1NjaGVtYVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjaHVua1RleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgfTtcbn07XG52YXIgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlciA9IChyZXNwb25zZVNjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGNvbnN0IHBhcnNlZFJlc3VsdCA9IHNhZmVQYXJzZUpTT04oe1xuICAgIHRleHQ6IHJlc3BvbnNlQm9keSxcbiAgICBzY2hlbWE6IHJlc3BvbnNlU2NoZW1hXG4gIH0pO1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKCFwYXJzZWRSZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3IzKHtcbiAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBKU09OIHJlc3BvbnNlXCIsXG4gICAgICBjYXVzZTogcGFyc2VkUmVzdWx0LmVycm9yLFxuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcGFyc2VkUmVzdWx0LnZhbHVlLFxuICAgIHJhd1ZhbHVlOiBwYXJzZWRSZXN1bHQucmF3VmFsdWVcbiAgfTtcbn07XG52YXIgY3JlYXRlQmluYXJ5UmVzcG9uc2VIYW5kbGVyID0gKCkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcjMoe1xuICAgICAgbWVzc2FnZTogXCJSZXNwb25zZSBib2R5IGlzIGVtcHR5XCIsXG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHJlc3BvbnNlQm9keTogdm9pZCAwXG4gICAgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBidWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcjMoe1xuICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcmVhZCByZXNwb25zZSBhcyBhcnJheSBidWZmZXJcIixcbiAgICAgIHVybCxcbiAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5OiB2b2lkIDAsXG4gICAgICBjYXVzZTogZXJyb3JcbiAgICB9KTtcbiAgfVxufTtcbnZhciBjcmVhdGVTdGF0dXNDb2RlRXJyb3JSZXNwb25zZUhhbmRsZXIgPSAoKSA9PiBhc3luYyAoeyByZXNwb25zZSwgdXJsLCByZXF1ZXN0Qm9keVZhbHVlcyB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiBuZXcgQVBJQ2FsbEVycm9yMyh7XG4gICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICByZXNwb25zZUJvZHlcbiAgICB9KVxuICB9O1xufTtcblxuLy8gc3JjL3VpbnQ4LXV0aWxzLnRzXG52YXIgeyBidG9hLCBhdG9iIH0gPSBnbG9iYWxUaGlzO1xuZnVuY3Rpb24gY29udmVydEJhc2U2NFRvVWludDhBcnJheShiYXNlNjRTdHJpbmcpIHtcbiAgY29uc3QgYmFzZTY0VXJsID0gYmFzZTY0U3RyaW5nLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICBjb25zdCBsYXRpbjFzdHJpbmcgPSBhdG9iKGJhc2U2NFVybCk7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20obGF0aW4xc3RyaW5nLCAoYnl0ZSkgPT4gYnl0ZS5jb2RlUG9pbnRBdCgwKSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KGFycmF5KSB7XG4gIGxldCBsYXRpbjFzdHJpbmcgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgbGF0aW4xc3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGFycmF5W2ldKTtcbiAgfVxuICByZXR1cm4gYnRvYShsYXRpbjFzdHJpbmcpO1xufVxuXG4vLyBzcmMvd2l0aG91dC10cmFpbGluZy1zbGFzaC50c1xuZnVuY3Rpb24gd2l0aG91dFRyYWlsaW5nU2xhc2godXJsKSB7XG4gIHJldHVybiB1cmwgPT0gbnVsbCA/IHZvaWQgMCA6IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG59XG5leHBvcnQge1xuICBhc1ZhbGlkYXRvcixcbiAgY29tYmluZUhlYWRlcnMsXG4gIGNvbnZlcnRBc3luY0l0ZXJhdG9yVG9SZWFkYWJsZVN0cmVhbSxcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCxcbiAgY3JlYXRlQmluYXJ5UmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSWRHZW5lcmF0b3IsXG4gIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSnNvblN0cmVhbVJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlU3RhdHVzQ29kZUVycm9yUmVzcG9uc2VIYW5kbGVyLFxuICBkZWxheSxcbiAgZXh0cmFjdFJlc3BvbnNlSGVhZGVycyxcbiAgZ2VuZXJhdGVJZCxcbiAgZ2V0RXJyb3JNZXNzYWdlLFxuICBnZXRGcm9tQXBpLFxuICBpc0Fib3J0RXJyb3IsXG4gIGlzUGFyc2FibGVKc29uLFxuICBpc1ZhbGlkYXRvcixcbiAgbG9hZEFwaUtleSxcbiAgbG9hZE9wdGlvbmFsU2V0dGluZyxcbiAgbG9hZFNldHRpbmcsXG4gIHBhcnNlSlNPTixcbiAgcG9zdEpzb25Ub0FwaSxcbiAgcG9zdFRvQXBpLFxuICByZW1vdmVVbmRlZmluZWRFbnRyaWVzLFxuICByZXNvbHZlLFxuICBzYWZlUGFyc2VKU09OLFxuICBzYWZlVmFsaWRhdGVUeXBlcyxcbiAgdmFsaWRhdGVUeXBlcyxcbiAgdmFsaWRhdG9yLFxuICB2YWxpZGF0b3JTeW1ib2wsXG4gIHdpdGhvdXRUcmFpbGluZ1NsYXNoLFxuICB6b2RWYWxpZGF0b3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbImNvbWJpbmVIZWFkZXJzIiwiaGVhZGVycyIsInJlZHVjZSIsImNvbWJpbmVkSGVhZGVycyIsImN1cnJlbnRIZWFkZXJzIiwiY29udmVydEFzeW5jSXRlcmF0b3JUb1JlYWRhYmxlU3RyZWFtIiwiaXRlcmF0b3IiLCJSZWFkYWJsZVN0cmVhbSIsInB1bGwiLCJjb250cm9sbGVyIiwidmFsdWUiLCJkb25lIiwibmV4dCIsImNsb3NlIiwiZW5xdWV1ZSIsImVycm9yIiwiY2FuY2VsIiwiZGVsYXkiLCJkZWxheUluTXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc29sdmUyIiwic2V0VGltZW91dCIsImV4dHJhY3RSZXNwb25zZUhlYWRlcnMiLCJyZXNwb25zZSIsImZvckVhY2giLCJrZXkiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsImN1c3RvbUFscGhhYmV0IiwiY3JlYXRlSWRHZW5lcmF0b3IiLCJwcmVmaXgiLCJzaXplIiwiZGVmYXVsdFNpemUiLCJhbHBoYWJldCIsInNlcGFyYXRvciIsImdlbmVyYXRvciIsImluY2x1ZGVzIiwiYXJndW1lbnQiLCJtZXNzYWdlIiwiZ2VuZXJhdGVJZCIsImdldEVycm9yTWVzc2FnZSIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsIkFQSUNhbGxFcnJvciIsInJlbW92ZVVuZGVmaW5lZEVudHJpZXMiLCJyZWNvcmQiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJmaWx0ZXIiLCJfa2V5IiwiaXNBYm9ydEVycm9yIiwibmFtZSIsImdldE9yaWdpbmFsRmV0Y2giLCJnbG9iYWxUaGlzIiwiZmV0Y2giLCJnZXRGcm9tQXBpIiwidXJsIiwic3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlciIsImZhaWxlZFJlc3BvbnNlSGFuZGxlciIsImFib3J0U2lnbmFsIiwibWV0aG9kIiwic2lnbmFsIiwicmVzcG9uc2VIZWFkZXJzIiwib2siLCJlcnJvckluZm9ybWF0aW9uIiwicmVxdWVzdEJvZHlWYWx1ZXMiLCJpc0luc3RhbmNlIiwiY2F1c2UiLCJzdGF0dXNDb2RlIiwic3RhdHVzIiwiVHlwZUVycm9yIiwiaXNSZXRyeWFibGUiLCJMb2FkQVBJS2V5RXJyb3IiLCJsb2FkQXBpS2V5IiwiYXBpS2V5IiwiZW52aXJvbm1lbnRWYXJpYWJsZU5hbWUiLCJhcGlLZXlQYXJhbWV0ZXJOYW1lIiwiZGVzY3JpcHRpb24iLCJwcm9jZXNzIiwiZW52IiwibG9hZE9wdGlvbmFsU2V0dGluZyIsInNldHRpbmdWYWx1ZSIsIkxvYWRTZXR0aW5nRXJyb3IiLCJsb2FkU2V0dGluZyIsInNldHRpbmdOYW1lIiwiSlNPTlBhcnNlRXJyb3IiLCJUeXBlVmFsaWRhdGlvbkVycm9yIiwiVHlwZVZhbGlkYXRpb25FcnJvcjIiLCJTZWN1cmVKU09OIiwidmFsaWRhdG9yU3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwidmFsaWRhdG9yIiwidmFsaWRhdGUiLCJpc1ZhbGlkYXRvciIsImFzVmFsaWRhdG9yIiwiem9kVmFsaWRhdG9yIiwiem9kU2NoZW1hIiwicmVzdWx0Iiwic2FmZVBhcnNlIiwic3VjY2VzcyIsImRhdGEiLCJ2YWxpZGF0ZVR5cGVzIiwic2NoZW1hIiwiaW5wdXRTY2hlbWEiLCJzYWZlVmFsaWRhdGVUeXBlcyIsIndyYXAiLCJ2YWxpZGF0b3IyIiwicGFyc2VKU09OIiwidGV4dCIsInBhcnNlIiwic2FmZVBhcnNlSlNPTiIsInJhd1ZhbHVlIiwidmFsaWRhdGlvblJlc3VsdCIsImlzUGFyc2FibGVKc29uIiwiaW5wdXQiLCJlIiwiQVBJQ2FsbEVycm9yMiIsImdldE9yaWdpbmFsRmV0Y2gyIiwicG9zdEpzb25Ub0FwaSIsImJvZHkiLCJwb3N0VG9BcGkiLCJjb250ZW50IiwidmFsdWVzIiwiQVBJQ2FsbEVycm9yMyIsIkVtcHR5UmVzcG9uc2VCb2R5RXJyb3IiLCJFdmVudFNvdXJjZVBhcnNlclN0cmVhbSIsImNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlciIsImVycm9yU2NoZW1hIiwiZXJyb3JUb01lc3NhZ2UiLCJyZXNwb25zZUJvZHkiLCJ0cmltIiwic3RhdHVzVGV4dCIsInBhcnNlZEVycm9yIiwicGFyc2VFcnJvciIsImNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyIiwiY2h1bmtTY2hlbWEiLCJwaXBlVGhyb3VnaCIsIlRleHREZWNvZGVyU3RyZWFtIiwiVHJhbnNmb3JtU3RyZWFtIiwidHJhbnNmb3JtIiwiY3JlYXRlSnNvblN0cmVhbVJlc3BvbnNlSGFuZGxlciIsImJ1ZmZlciIsImNodW5rVGV4dCIsImVuZHNXaXRoIiwiY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlciIsInJlc3BvbnNlU2NoZW1hIiwicGFyc2VkUmVzdWx0IiwiY3JlYXRlQmluYXJ5UmVzcG9uc2VIYW5kbGVyIiwiYXJyYXlCdWZmZXIiLCJVaW50OEFycmF5IiwiY3JlYXRlU3RhdHVzQ29kZUVycm9yUmVzcG9uc2VIYW5kbGVyIiwiYnRvYSIsImF0b2IiLCJjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IiwiYmFzZTY0U3RyaW5nIiwiYmFzZTY0VXJsIiwicmVwbGFjZSIsImxhdGluMXN0cmluZyIsImZyb20iLCJieXRlIiwiY29kZVBvaW50QXQiLCJjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0IiwiYXJyYXkiLCJpIiwibGVuZ3RoIiwiU3RyaW5nIiwiZnJvbUNvZGVQb2ludCIsIndpdGhvdXRUcmFpbGluZ1NsYXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ai-sdk/provider/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@ai-sdk/provider/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* binding */ AISDKError),\n/* harmony export */   APICallError: () => (/* binding */ APICallError),\n/* harmony export */   EmptyResponseBodyError: () => (/* binding */ EmptyResponseBodyError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidPromptError: () => (/* binding */ InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* binding */ InvalidResponseDataError),\n/* harmony export */   JSONParseError: () => (/* binding */ JSONParseError),\n/* harmony export */   LoadAPIKeyError: () => (/* binding */ LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* binding */ LoadSettingError),\n/* harmony export */   NoContentGeneratedError: () => (/* binding */ NoContentGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* binding */ TooManyEmbeddingValuesForCallError),\n/* harmony export */   TypeValidationError: () => (/* binding */ TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* binding */ UnsupportedFunctionalityError),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isJSONArray: () => (/* binding */ isJSONArray),\n/* harmony export */   isJSONObject: () => (/* binding */ isJSONObject),\n/* harmony export */   isJSONValue: () => (/* binding */ isJSONValue)\n/* harmony export */ });\n// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError extends Error {\n    /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */ constructor({ name: name14, message, cause }){\n        super(message);\n        this[_a] = true;\n        this.name = name14;\n        this.cause = cause;\n    }\n    /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */ static isInstance(error) {\n        return _AISDKError.hasMarker(error, marker);\n    }\n    static hasMarker(error, marker15) {\n        const markerSymbol = Symbol.for(marker15);\n        return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n    }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n    constructor({ message, url, requestBodyValues, statusCode, responseHeaders, responseBody, cause, isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500), // server error\n    data }){\n        super({\n            name,\n            message,\n            cause\n        });\n        this[_a2] = true;\n        this.url = url;\n        this.requestBodyValues = requestBodyValues;\n        this.statusCode = statusCode;\n        this.responseHeaders = responseHeaders;\n        this.responseBody = responseBody;\n        this.isRetryable = isRetryable;\n        this.data = data;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker2);\n    }\n};\n_a2 = symbol2;\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message = \"Empty response body\" } = {}){\n        super({\n            name: name2,\n            message\n        });\n        this[_a3] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker3);\n    }\n};\n_a3 = symbol3;\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n    if (error == null) {\n        return \"unknown error\";\n    }\n    if (typeof error === \"string\") {\n        return error;\n    }\n    if (error instanceof Error) {\n        return error.message;\n    }\n    return JSON.stringify(error);\n}\n// src/errors/invalid-argument-error.ts\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n    constructor({ message, cause, argument }){\n        super({\n            name: name3,\n            message,\n            cause\n        });\n        this[_a4] = true;\n        this.argument = argument;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker4);\n    }\n};\n_a4 = symbol4;\n// src/errors/invalid-prompt-error.ts\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidPromptError = class extends AISDKError {\n    constructor({ prompt, message, cause }){\n        super({\n            name: name4,\n            message: `Invalid prompt: ${message}`,\n            cause\n        });\n        this[_a5] = true;\n        this.prompt = prompt;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker5);\n    }\n};\n_a5 = symbol5;\n// src/errors/invalid-response-data-error.ts\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidResponseDataError = class extends AISDKError {\n    constructor({ data, message = `Invalid response data: ${JSON.stringify(data)}.` }){\n        super({\n            name: name5,\n            message\n        });\n        this[_a6] = true;\n        this.data = data;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker6);\n    }\n};\n_a6 = symbol6;\n// src/errors/json-parse-error.ts\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n    constructor({ text, cause }){\n        super({\n            name: name6,\n            message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n            cause\n        });\n        this[_a7] = true;\n        this.text = text;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker7);\n    }\n};\n_a7 = symbol7;\n// src/errors/load-api-key-error.ts\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadAPIKeyError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message }){\n        super({\n            name: name7,\n            message\n        });\n        this[_a8] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker8);\n    }\n};\n_a8 = symbol8;\n// src/errors/load-setting-error.ts\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar LoadSettingError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message }){\n        super({\n            name: name8,\n            message\n        });\n        this[_a9] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker9);\n    }\n};\n_a9 = symbol9;\n// src/errors/no-content-generated-error.ts\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoContentGeneratedError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message = \"No content generated.\" } = {}){\n        super({\n            name: name9,\n            message\n        });\n        this[_a10] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker10);\n    }\n};\n_a10 = symbol10;\n// src/errors/no-such-model-error.ts\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar NoSuchModelError = class extends AISDKError {\n    constructor({ errorName = name10, modelId, modelType, message = `No such ${modelType}: ${modelId}` }){\n        super({\n            name: errorName,\n            message\n        });\n        this[_a11] = true;\n        this.modelId = modelId;\n        this.modelType = modelType;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker11);\n    }\n};\n_a11 = symbol11;\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError {\n    constructor(options){\n        super({\n            name: name11,\n            message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n        });\n        this[_a12] = true;\n        this.provider = options.provider;\n        this.modelId = options.modelId;\n        this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n        this.values = options.values;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker12);\n    }\n};\n_a12 = symbol12;\n// src/errors/type-validation-error.ts\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError extends AISDKError {\n    constructor({ value, cause }){\n        super({\n            name: name12,\n            message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n            cause\n        });\n        this[_a13] = true;\n        this.value = value;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker13);\n    }\n    /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */ static wrap({ value, cause }) {\n        return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({\n            value,\n            cause\n        });\n    }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\n// src/errors/unsupported-functionality-error.ts\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n    constructor({ functionality, message = `'${functionality}' functionality not supported.` }){\n        super({\n            name: name13,\n            message\n        });\n        this[_a14] = true;\n        this.functionality = functionality;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker14);\n    }\n};\n_a14 = symbol14;\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n    if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n        return true;\n    }\n    if (Array.isArray(value)) {\n        return value.every(isJSONValue);\n    }\n    if (typeof value === \"object\") {\n        return Object.entries(value).every(([key, val])=>typeof key === \"string\" && isJSONValue(val));\n    }\n    return false;\n}\nfunction isJSONArray(value) {\n    return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n    return value != null && typeof value === \"object\" && Object.entries(value).every(([key, val])=>typeof key === \"string\" && isJSONValue(val));\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw2QkFBNkI7QUFDN0IsSUFBSUEsU0FBUztBQUNiLElBQUlDLFNBQVNDLE9BQU9DLEdBQUcsQ0FBQ0g7QUFDeEIsSUFBSUk7QUFDSixJQUFJQyxjQUFjLE1BQU1BLG9CQUFvQkM7SUFDMUM7Ozs7Ozs7R0FPQyxHQUNEQyxZQUFZLEVBQ1ZDLE1BQU1DLE1BQU0sRUFDWkMsT0FBTyxFQUNQQyxLQUFLLEVBQ04sQ0FBRTtRQUNELEtBQUssQ0FBQ0Q7UUFDTixJQUFJLENBQUNOLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0ksSUFBSSxHQUFHQztRQUNaLElBQUksQ0FBQ0UsS0FBSyxHQUFHQTtJQUNmO0lBQ0E7Ozs7R0FJQyxHQUNELE9BQU9DLFdBQVdDLEtBQUssRUFBRTtRQUN2QixPQUFPUixZQUFZUyxTQUFTLENBQUNELE9BQU9iO0lBQ3RDO0lBQ0EsT0FBT2MsVUFBVUQsS0FBSyxFQUFFRSxRQUFRLEVBQUU7UUFDaEMsTUFBTUMsZUFBZWQsT0FBT0MsR0FBRyxDQUFDWTtRQUNoQyxPQUFPRixTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZRyxnQkFBZ0JILFNBQVMsT0FBT0EsS0FBSyxDQUFDRyxhQUFhLEtBQUssYUFBYUgsS0FBSyxDQUFDRyxhQUFhLEtBQUs7SUFDcEo7QUFDRjtBQUNBWixLQUFLSDtBQUNMLElBQUlnQixhQUFhWjtBQUVqQiwrQkFBK0I7QUFDL0IsSUFBSUcsT0FBTztBQUNYLElBQUlVLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRVYsS0FBSyxDQUFDO0FBQ3ZDLElBQUlXLFVBQVVqQixPQUFPQyxHQUFHLENBQUNlO0FBQ3pCLElBQUlFO0FBQ0osSUFBSUMsZUFBZSxjQUFjSjtJQUMvQlYsWUFBWSxFQUNWRyxPQUFPLEVBQ1BZLEdBQUcsRUFDSEMsaUJBQWlCLEVBQ2pCQyxVQUFVLEVBQ1ZD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SUFDckI7SUFDQSxJQUFJLE9BQU9ULFVBQVUsVUFBVTtRQUM3QixPQUFPYSxPQUFPQyxPQUFPLENBQUNkLE9BQU9ZLEtBQUssQ0FDaEMsQ0FBQyxDQUFDRyxLQUFLQyxJQUFJLEdBQUssT0FBT0QsUUFBUSxZQUFZTixZQUFZTztJQUUzRDtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNDLFlBQVlqQixLQUFLO0lBQ3hCLE9BQU9VLE1BQU1DLE9BQU8sQ0FBQ1gsVUFBVUEsTUFBTVksS0FBSyxDQUFDSDtBQUM3QztBQUNBLFNBQVNTLGFBQWFsQixLQUFLO0lBQ3pCLE9BQU9BLFNBQVMsUUFBUSxPQUFPQSxVQUFVLFlBQVlhLE9BQU9DLE9BQU8sQ0FBQ2QsT0FBT1ksS0FBSyxDQUM5RSxDQUFDLENBQUNHLEtBQUtDLElBQUksR0FBSyxPQUFPRCxRQUFRLFlBQVlOLFlBQVlPO0FBRTNEO0FBb0JFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hlcmxvZy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AYWktc2RrL3Byb3ZpZGVyL2Rpc3QvaW5kZXgubWpzPzVmYjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Vycm9ycy9haS1zZGstZXJyb3IudHNcbnZhciBtYXJrZXIgPSBcInZlcmNlbC5haS5lcnJvclwiO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBfQUlTREtFcnJvciA9IGNsYXNzIF9BSVNES0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3Vua25vd259IFtwYXJhbXMuY2F1c2VdIC0gVGhlIHVuZGVybHlpbmcgY2F1c2Ugb2YgdGhlIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWU6IG5hbWUxNCxcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzW19hXSA9IHRydWU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTE0O1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIF9BSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuICBzdGF0aWMgaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNSkge1xuICAgIGNvbnN0IG1hcmtlclN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyMTUpO1xuICAgIHJldHVybiBlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBtYXJrZXJTeW1ib2wgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yW21hcmtlclN5bWJvbF0gPT09IFwiYm9vbGVhblwiICYmIGVycm9yW21hcmtlclN5bWJvbF0gPT09IHRydWU7XG4gIH1cbn07XG5fYSA9IHN5bWJvbDtcbnZhciBBSVNES0Vycm9yID0gX0FJU0RLRXJyb3I7XG5cbi8vIHNyYy9lcnJvcnMvYXBpLWNhbGwtZXJyb3IudHNcbnZhciBuYW1lID0gXCJBSV9BUElDYWxsRXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbnZhciBzeW1ib2wyID0gU3ltYm9sLmZvcihtYXJrZXIyKTtcbnZhciBfYTI7XG52YXIgQVBJQ2FsbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgdXJsLFxuICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHJlc3BvbnNlQm9keSxcbiAgICBjYXVzZSxcbiAgICBpc1JldHJ5YWJsZSA9IHN0YXR1c0NvZGUgIT0gbnVsbCAmJiAoc3RhdHVzQ29kZSA9PT0gNDA4IHx8IC8vIHJlcXVlc3QgdGltZW91dFxuICAgIHN0YXR1c0NvZGUgPT09IDQwOSB8fCAvLyBjb25mbGljdFxuICAgIHN0YXR1c0NvZGUgPT09IDQyOSB8fCAvLyB0b28gbWFueSByZXF1ZXN0c1xuICAgIHN0YXR1c0NvZGUgPj0gNTAwKSxcbiAgICAvLyBzZXJ2ZXIgZXJyb3JcbiAgICBkYXRhXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5yZXF1ZXN0Qm9keVZhbHVlcyA9IHJlcXVlc3RCb2R5VmFsdWVzO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnM7XG4gICAgdGhpcy5yZXNwb25zZUJvZHkgPSByZXNwb25zZUJvZHk7XG4gICAgdGhpcy5pc1JldHJ5YWJsZSA9IGlzUmV0cnlhYmxlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIpO1xuICB9XG59O1xuX2EyID0gc3ltYm9sMjtcblxuLy8gc3JjL2Vycm9ycy9lbXB0eS1yZXNwb25zZS1ib2R5LWVycm9yLnRzXG52YXIgbmFtZTIgPSBcIkFJX0VtcHR5UmVzcG9uc2VCb2R5RXJyb3JcIjtcbnZhciBtYXJrZXIzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMyA9IFN5bWJvbC5mb3IobWFya2VyMyk7XG52YXIgX2EzO1xudmFyIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlID0gXCJFbXB0eSByZXNwb25zZSBib2R5XCIgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hM10gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIzKTtcbiAgfVxufTtcbl9hMyA9IHN5bWJvbDM7XG5cbi8vIHNyYy9lcnJvcnMvZ2V0LWVycm9yLW1lc3NhZ2UudHNcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBcInVua25vd24gZXJyb3JcIjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbn1cblxuLy8gc3JjL2Vycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG52YXIgbmFtZTMgPSBcIkFJX0ludmFsaWRBcmd1bWVudEVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNDtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlLFxuICAgIGFyZ3VtZW50XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUzLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNF0gPSB0cnVlO1xuICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtcHJvbXB0LWVycm9yLnRzXG52YXIgbmFtZTQgPSBcIkFJX0ludmFsaWRQcm9tcHRFcnJvclwiO1xudmFyIG1hcmtlcjUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTR9YDtcbnZhciBzeW1ib2w1ID0gU3ltYm9sLmZvcihtYXJrZXI1KTtcbnZhciBfYTU7XG52YXIgSW52YWxpZFByb21wdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHByb21wdCxcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlOiBgSW52YWxpZCBwcm9tcHQ6ICR7bWVzc2FnZX1gLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMucHJvbXB0ID0gcHJvbXB0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI1KTtcbiAgfVxufTtcbl9hNSA9IHN5bWJvbDU7XG5cbi8vIHNyYy9lcnJvcnMvaW52YWxpZC1yZXNwb25zZS1kYXRhLWVycm9yLnRzXG52YXIgbmFtZTUgPSBcIkFJX0ludmFsaWRSZXNwb25zZURhdGFFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTV9YDtcbnZhciBzeW1ib2w2ID0gU3ltYm9sLmZvcihtYXJrZXI2KTtcbnZhciBfYTY7XG52YXIgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRhdGEsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIHJlc3BvbnNlIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG5cbi8vIHNyYy9lcnJvcnMvanNvbi1wYXJzZS1lcnJvci50c1xudmFyIG5hbWU2ID0gXCJBSV9KU09OUGFyc2VFcnJvclwiO1xudmFyIG1hcmtlcjcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTZ9YDtcbnZhciBzeW1ib2w3ID0gU3ltYm9sLmZvcihtYXJrZXI3KTtcbnZhciBfYTc7XG52YXIgSlNPTlBhcnNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IHRleHQsIGNhdXNlIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lNixcbiAgICAgIG1lc3NhZ2U6IGBKU09OIHBhcnNpbmcgZmFpbGVkOiBUZXh0OiAke3RleHR9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2E3XSA9IHRydWU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbn07XG5fYTcgPSBzeW1ib2w3O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtYXBpLWtleS1lcnJvci50c1xudmFyIG5hbWU3ID0gXCJBSV9Mb2FkQVBJS2V5RXJyb3JcIjtcbnZhciBtYXJrZXI4ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU3fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4O1xudmFyIExvYWRBUElLZXlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTcsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYThdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyOCk7XG4gIH1cbn07XG5fYTggPSBzeW1ib2w4O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtc2V0dGluZy1lcnJvci50c1xudmFyIG5hbWU4ID0gXCJBSV9Mb2FkU2V0dGluZ0Vycm9yXCI7XG52YXIgbWFya2VyOSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOH1gO1xudmFyIHN5bWJvbDkgPSBTeW1ib2wuZm9yKG1hcmtlcjkpO1xudmFyIF9hOTtcbnZhciBMb2FkU2V0dGluZ0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOV0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxufTtcbl9hOSA9IHN5bWJvbDk7XG5cbi8vIHNyYy9lcnJvcnMvbm8tY29udGVudC1nZW5lcmF0ZWQtZXJyb3IudHNcbnZhciBuYW1lOSA9IFwiQUlfTm9Db250ZW50R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXIxMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOX1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMDtcbnZhciBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gY29udGVudCBnZW5lcmF0ZWQuXCJcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTBdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTApO1xuICB9XG59O1xuX2ExMCA9IHN5bWJvbDEwO1xuXG4vLyBzcmMvZXJyb3JzL25vLXN1Y2gtbW9kZWwtZXJyb3IudHNcbnZhciBuYW1lMTAgPSBcIkFJX05vU3VjaE1vZGVsRXJyb3JcIjtcbnZhciBtYXJrZXIxMSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTB9YDtcbnZhciBzeW1ib2wxMSA9IFN5bWJvbC5mb3IobWFya2VyMTEpO1xudmFyIF9hMTE7XG52YXIgTm9TdWNoTW9kZWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlcnJvck5hbWUgPSBuYW1lMTAsXG4gICAgbW9kZWxJZCxcbiAgICBtb2RlbFR5cGUsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoICR7bW9kZWxUeXBlfTogJHttb2RlbElkfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogZXJyb3JOYW1lLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExMV0gPSB0cnVlO1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5tb2RlbFR5cGUgPSBtb2RlbFR5cGU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjExKTtcbiAgfVxufTtcbl9hMTEgPSBzeW1ib2wxMTtcblxuLy8gc3JjL2Vycm9ycy90b28tbWFueS1lbWJlZGRpbmctdmFsdWVzLWZvci1jYWxsLWVycm9yLnRzXG52YXIgbmFtZTExID0gXCJBSV9Ub29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yXCI7XG52YXIgbWFya2VyMTIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTExfWA7XG52YXIgc3ltYm9sMTIgPSBTeW1ib2wuZm9yKG1hcmtlcjEyKTtcbnZhciBfYTEyO1xudmFyIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTExLFxuICAgICAgbWVzc2FnZTogYFRvbyBtYW55IHZhbHVlcyBmb3IgYSBzaW5nbGUgZW1iZWRkaW5nIGNhbGwuIFRoZSAke29wdGlvbnMucHJvdmlkZXJ9IG1vZGVsIFwiJHtvcHRpb25zLm1vZGVsSWR9XCIgY2FuIG9ubHkgZW1iZWQgdXAgdG8gJHtvcHRpb25zLm1heEVtYmVkZGluZ3NQZXJDYWxsfSB2YWx1ZXMgcGVyIGNhbGwsIGJ1dCAke29wdGlvbnMudmFsdWVzLmxlbmd0aH0gdmFsdWVzIHdlcmUgcHJvdmlkZWQuYFxuICAgIH0pO1xuICAgIHRoaXNbX2ExMl0gPSB0cnVlO1xuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRpb25zLnByb3ZpZGVyO1xuICAgIHRoaXMubW9kZWxJZCA9IG9wdGlvbnMubW9kZWxJZDtcbiAgICB0aGlzLm1heEVtYmVkZGluZ3NQZXJDYWxsID0gb3B0aW9ucy5tYXhFbWJlZGRpbmdzUGVyQ2FsbDtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMik7XG4gIH1cbn07XG5fYTEyID0gc3ltYm9sMTI7XG5cbi8vIHNyYy9lcnJvcnMvdHlwZS12YWxpZGF0aW9uLWVycm9yLnRzXG52YXIgbmFtZTEyID0gXCJBSV9UeXBlVmFsaWRhdGlvbkVycm9yXCI7XG52YXIgbWFya2VyMTMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEyfWA7XG52YXIgc3ltYm9sMTMgPSBTeW1ib2wuZm9yKG1hcmtlcjEzKTtcbnZhciBfYTEzO1xudmFyIF9UeXBlVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgX1R5cGVWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3IoeyB2YWx1ZSwgY2F1c2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMixcbiAgICAgIG1lc3NhZ2U6IGBUeXBlIHZhbGlkYXRpb24gZmFpbGVkOiBWYWx1ZTogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2ExM10gPSB0cnVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTMpO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwcyBhbiBlcnJvciBpbnRvIGEgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICogSWYgdGhlIGNhdXNlIGlzIGFscmVhZHkgYSBUeXBlVmFsaWRhdGlvbkVycm9yIHdpdGggdGhlIHNhbWUgdmFsdWUsIGl0IHJldHVybnMgdGhlIGNhdXNlLlxuICAgKiBPdGhlcndpc2UsIGl0IGNyZWF0ZXMgYSBuZXcgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB3cmFwcGluZyB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLnZhbHVlIC0gVGhlIHZhbHVlIHRoYXQgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLmNhdXNlIC0gVGhlIG9yaWdpbmFsIGVycm9yIG9yIGNhdXNlIG9mIHRoZSB2YWxpZGF0aW9uIGZhaWx1cmUuXG4gICAqIEByZXR1cm5zIHtUeXBlVmFsaWRhdGlvbkVycm9yfSBBIFR5cGVWYWxpZGF0aW9uRXJyb3IgaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgd3JhcCh7XG4gICAgdmFsdWUsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHJldHVybiBfVHlwZVZhbGlkYXRpb25FcnJvci5pc0luc3RhbmNlKGNhdXNlKSAmJiBjYXVzZS52YWx1ZSA9PT0gdmFsdWUgPyBjYXVzZSA6IG5ldyBfVHlwZVZhbGlkYXRpb25FcnJvcih7IHZhbHVlLCBjYXVzZSB9KTtcbiAgfVxufTtcbl9hMTMgPSBzeW1ib2wxMztcbnZhciBUeXBlVmFsaWRhdGlvbkVycm9yID0gX1R5cGVWYWxpZGF0aW9uRXJyb3I7XG5cbi8vIHNyYy9lcnJvcnMvdW5zdXBwb3J0ZWQtZnVuY3Rpb25hbGl0eS1lcnJvci50c1xudmFyIG5hbWUxMyA9IFwiQUlfVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3JcIjtcbnZhciBtYXJrZXIxNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTN9YDtcbnZhciBzeW1ib2wxNCA9IFN5bWJvbC5mb3IobWFya2VyMTQpO1xudmFyIF9hMTQ7XG52YXIgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZnVuY3Rpb25hbGl0eSxcbiAgICBtZXNzYWdlID0gYCcke2Z1bmN0aW9uYWxpdHl9JyBmdW5jdGlvbmFsaXR5IG5vdCBzdXBwb3J0ZWQuYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTMsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE0XSA9IHRydWU7XG4gICAgdGhpcy5mdW5jdGlvbmFsaXR5ID0gZnVuY3Rpb25hbGl0eTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTQpO1xuICB9XG59O1xuX2ExNCA9IHN5bWJvbDE0O1xuXG4vLyBzcmMvanNvbi12YWx1ZS9pcy1qc29uLnRzXG5mdW5jdGlvbiBpc0pTT05WYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGlzSlNPTlZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAgIChba2V5LCB2YWxdKSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGlzSlNPTlZhbHVlKHZhbClcbiAgICApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSlNPTkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShpc0pTT05WYWx1ZSk7XG59XG5mdW5jdGlvbiBpc0pTT05PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAoW2tleSwgdmFsXSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiBpc0pTT05WYWx1ZSh2YWwpXG4gICk7XG59XG5leHBvcnQge1xuICBBSVNES0Vycm9yLFxuICBBUElDYWxsRXJyb3IsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTG9hZFNldHRpbmdFcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yLFxuICBnZXRFcnJvck1lc3NhZ2UsXG4gIGlzSlNPTkFycmF5LFxuICBpc0pTT05PYmplY3QsXG4gIGlzSlNPTlZhbHVlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJtYXJrZXIiLCJzeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJfYSIsIl9BSVNES0Vycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJuYW1lMTQiLCJtZXNzYWdlIiwiY2F1c2UiLCJpc0luc3RhbmNlIiwiZXJyb3IiLCJoYXNNYXJrZXIiLCJtYXJrZXIxNSIsIm1hcmtlclN5bWJvbCIsIkFJU0RLRXJyb3IiLCJtYXJrZXIyIiwic3ltYm9sMiIsIl9hMiIsIkFQSUNhbGxFcnJvciIsInVybCIsInJlcXVlc3RCb2R5VmFsdWVzIiwic3RhdHVzQ29kZSIsInJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlQm9keSIsImlzUmV0cnlhYmxlIiwiZGF0YSIsIm5hbWUyIiwibWFya2VyMyIsInN5bWJvbDMiLCJfYTMiLCJFbXB0eVJlc3BvbnNlQm9keUVycm9yIiwiZ2V0RXJyb3JNZXNzYWdlIiwiSlNPTiIsInN0cmluZ2lmeSIsIm5hbWUzIiwibWFya2VyNCIsInN5bWJvbDQiLCJfYTQiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsImFyZ3VtZW50IiwibmFtZTQiLCJtYXJrZXI1Iiwic3ltYm9sNSIsIl9hNSIsIkludmFsaWRQcm9tcHRFcnJvciIsInByb21wdCIsIm5hbWU1IiwibWFya2VyNiIsInN5bWJvbDYiLCJfYTYiLCJJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IiLCJuYW1lNiIsIm1hcmtlcjciLCJzeW1ib2w3IiwiX2E3IiwiSlNPTlBhcnNlRXJyb3IiLCJ0ZXh0IiwibmFtZTciLCJtYXJrZXI4Iiwic3ltYm9sOCIsIl9hOCIsIkxvYWRBUElLZXlFcnJvciIsIm5hbWU4IiwibWFya2VyOSIsInN5bWJvbDkiLCJfYTkiLCJMb2FkU2V0dGluZ0Vycm9yIiwibmFtZTkiLCJtYXJrZXIxMCIsInN5bWJvbDEwIiwiX2ExMCIsIk5vQ29udGVudEdlbmVyYXRlZEVycm9yIiwibmFtZTEwIiwibWFya2VyMTEiLCJzeW1ib2wxMSIsIl9hMTEiLCJOb1N1Y2hNb2RlbEVycm9yIiwiZXJyb3JOYW1lIiwibW9kZWxJZCIsIm1vZGVsVHlwZSIsIm5hbWUxMSIsIm1hcmtlcjEyIiwic3ltYm9sMTIiLCJfYTEyIiwiVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvciIsIm9wdGlvbnMiLCJwcm92aWRlciIsIm1heEVtYmVkZGluZ3NQZXJDYWxsIiwidmFsdWVzIiwibGVuZ3RoIiwibmFtZTEyIiwibWFya2VyMTMiLCJzeW1ib2wxMyIsIl9hMTMiLCJfVHlwZVZhbGlkYXRpb25FcnJvciIsInZhbHVlIiwid3JhcCIsIlR5cGVWYWxpZGF0aW9uRXJyb3IiLCJuYW1lMTMiLCJtYXJrZXIxNCIsInN5bWJvbDE0IiwiX2ExNCIsIlVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yIiwiZnVuY3Rpb25hbGl0eSIsImlzSlNPTlZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwiZXZlcnkiLCJPYmplY3QiLCJlbnRyaWVzIiwia2V5IiwidmFsIiwiaXNKU09OQXJyYXkiLCJpc0pTT05PYmplY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/provider/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ai-sdk/react/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@ai-sdk/react/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useObject: () => (/* binding */ experimental_useObject),\n/* harmony export */   useAssistant: () => (/* binding */ useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(ssr)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(ssr)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/dist/index/index.mjs\");\n/* harmony import */ var throttleit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! throttleit */ \"(ssr)/./node_modules/throttleit/index.js\");\n// src/use-assistant.ts\n\n\n\nvar getOriginalFetch = ()=>fetch;\nfunction useAssistant({ api, threadId: threadIdParam, credentials, headers, body, onError, fetch: fetch2 }) {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [currentThreadId, setCurrentThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const handleInputChange = (event)=>{\n        setInput(event.target.value);\n    };\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const append = async (message, requestOptions)=>{\n        var _a, _b;\n        setStatus(\"in_progress\");\n        setMessages((messages2)=>{\n            var _a2;\n            return [\n                ...messages2,\n                {\n                    ...message,\n                    id: (_a2 = message.id) != null ? _a2 : (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_1__.generateId)()\n                }\n            ];\n        });\n        setInput(\"\");\n        const abortController = new AbortController();\n        try {\n            abortControllerRef.current = abortController;\n            const actualFetch = fetch2 != null ? fetch2 : getOriginalFetch();\n            const response = await actualFetch(api, {\n                method: \"POST\",\n                credentials,\n                signal: abortController.signal,\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...headers\n                },\n                body: JSON.stringify({\n                    ...body,\n                    // always use user-provided threadId when available:\n                    threadId: (_a = threadIdParam != null ? threadIdParam : currentThreadId) != null ? _a : null,\n                    message: message.content,\n                    // optional request data:\n                    data: requestOptions == null ? void 0 : requestOptions.data\n                })\n            });\n            if (!response.ok) {\n                throw new Error((_b = await response.text()) != null ? _b : \"Failed to fetch the assistant response.\");\n            }\n            if (response.body == null) {\n                throw new Error(\"The response body is empty.\");\n            }\n            await (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.processAssistantStream)({\n                stream: response.body,\n                onAssistantMessagePart (value) {\n                    setMessages((messages2)=>[\n                            ...messages2,\n                            {\n                                id: value.id,\n                                role: value.role,\n                                content: value.content[0].text.value,\n                                parts: []\n                            }\n                        ]);\n                },\n                onTextPart (value) {\n                    setMessages((messages2)=>{\n                        const lastMessage = messages2[messages2.length - 1];\n                        return [\n                            ...messages2.slice(0, messages2.length - 1),\n                            {\n                                id: lastMessage.id,\n                                role: lastMessage.role,\n                                content: lastMessage.content + value,\n                                parts: lastMessage.parts\n                            }\n                        ];\n                    });\n                },\n                onAssistantControlDataPart (value) {\n                    setCurrentThreadId(value.threadId);\n                    setMessages((messages2)=>{\n                        const lastMessage = messages2[messages2.length - 1];\n                        lastMessage.id = value.messageId;\n                        return [\n                            ...messages2.slice(0, messages2.length - 1),\n                            lastMessage\n                        ];\n                    });\n                },\n                onDataMessagePart (value) {\n                    setMessages((messages2)=>{\n                        var _a2;\n                        return [\n                            ...messages2,\n                            {\n                                id: (_a2 = value.id) != null ? _a2 : (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_1__.generateId)(),\n                                role: \"data\",\n                                content: \"\",\n                                data: value.data,\n                                parts: []\n                            }\n                        ];\n                    });\n                },\n                onErrorPart (value) {\n                    setError(new Error(value));\n                }\n            });\n        } catch (error2) {\n            if ((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_1__.isAbortError)(error2) && abortController.signal.aborted) {\n                abortControllerRef.current = null;\n                return;\n            }\n            if (onError && error2 instanceof Error) {\n                onError(error2);\n            }\n            setError(error2);\n        } finally{\n            abortControllerRef.current = null;\n            setStatus(\"awaiting_message\");\n        }\n    };\n    const submitMessage = async (event, requestOptions)=>{\n        var _a;\n        (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n        if (input === \"\") {\n            return;\n        }\n        append({\n            role: \"user\",\n            content: input,\n            parts: []\n        }, requestOptions);\n    };\n    const setThreadId = (threadId)=>{\n        setCurrentThreadId(threadId);\n        setMessages([]);\n    };\n    return {\n        append,\n        messages,\n        setMessages,\n        threadId: currentThreadId,\n        setThreadId,\n        input,\n        setInput,\n        handleInputChange,\n        submitMessage,\n        status,\n        error,\n        stop\n    };\n}\n// src/use-chat.ts\n\n\n\n// src/throttle.ts\n\nfunction throttle(fn, waitMs) {\n    return waitMs != null ? throttleit__WEBPACK_IMPORTED_MODULE_3__(fn, waitMs) : fn;\n}\n// src/use-chat.ts\nfunction useChat({ api = \"/api/chat\", id, initialMessages, initialInput = \"\", sendExtraMessageFields, onToolCall, experimental_prepareRequestBody, maxSteps = 1, streamProtocol = \"data\", onResponse, onFinish, onError, credentials, headers, body, generateId: generateId2 = _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_1__.generateId, fetch: fetch2, keepLastMessageOnError = true, experimental_throttle: throttleWaitMs } = {}) {\n    const [hookId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(generateId2);\n    const chatId = id != null ? id : hookId;\n    const chatKey = typeof api === \"string\" ? [\n        api,\n        chatId\n    ] : chatId;\n    const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n        chatKey,\n        \"messages\"\n    ], null, {\n        fallbackData: initialMessages != null ? (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.fillMessageParts)(initialMessages) : initialMessagesFallback\n    });\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n        chatKey,\n        \"streamData\"\n    ], null);\n    const streamDataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(streamData);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        streamDataRef.current = streamData;\n    }, [\n        streamData\n    ]);\n    const { data: status = \"ready\", mutate: mutateStatus } = (0,swr__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n        chatKey,\n        \"status\"\n    ], null);\n    const { data: error = void 0, mutate: setError } = (0,swr__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n        chatKey,\n        \"error\"\n    ], null);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        var _a, _b;\n        mutateStatus(\"submitted\");\n        setError(void 0);\n        const chatMessages = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.fillMessageParts)(chatRequest.messages);\n        const messageCount = chatMessages.length;\n        const maxStep = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.extractMaxToolInvocationStep)((_a = chatMessages[chatMessages.length - 1]) == null ? void 0 : _a.toolInvocations);\n        try {\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            const throttledMutate = throttle(mutate, throttleWaitMs);\n            const throttledMutateStreamData = throttle(mutateStreamData, throttleWaitMs);\n            const previousMessages = messagesRef.current;\n            throttledMutate(chatMessages, false);\n            const constructedMessagesPayload = sendExtraMessageFields ? chatMessages : chatMessages.map(({ role, content, experimental_attachments, data, annotations, toolInvocations, parts })=>({\n                    role,\n                    content,\n                    ...experimental_attachments !== void 0 && {\n                        experimental_attachments\n                    },\n                    ...data !== void 0 && {\n                        data\n                    },\n                    ...annotations !== void 0 && {\n                        annotations\n                    },\n                    ...toolInvocations !== void 0 && {\n                        toolInvocations\n                    },\n                    ...parts !== void 0 && {\n                        parts\n                    }\n                }));\n            const existingData = streamDataRef.current;\n            await (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.callChatApi)({\n                api,\n                body: (_b = experimental_prepareRequestBody == null ? void 0 : experimental_prepareRequestBody({\n                    id: chatId,\n                    messages: chatMessages,\n                    requestData: chatRequest.data,\n                    requestBody: chatRequest.body\n                })) != null ? _b : {\n                    id: chatId,\n                    messages: constructedMessagesPayload,\n                    data: chatRequest.data,\n                    ...extraMetadataRef.current.body,\n                    ...chatRequest.body\n                },\n                streamProtocol,\n                credentials: extraMetadataRef.current.credentials,\n                headers: {\n                    ...extraMetadataRef.current.headers,\n                    ...chatRequest.headers\n                },\n                abortController: ()=>abortControllerRef.current,\n                restoreMessagesOnFailure () {\n                    if (!keepLastMessageOnError) {\n                        throttledMutate(previousMessages, false);\n                    }\n                },\n                onResponse,\n                onUpdate ({ message, data, replaceLastMessage }) {\n                    mutateStatus(\"streaming\");\n                    throttledMutate([\n                        ...replaceLastMessage ? chatMessages.slice(0, chatMessages.length - 1) : chatMessages,\n                        message\n                    ], false);\n                    if (data == null ? void 0 : data.length) {\n                        throttledMutateStreamData([\n                            ...existingData != null ? existingData : [],\n                            ...data\n                        ], false);\n                    }\n                },\n                onToolCall,\n                onFinish,\n                generateId: generateId2,\n                fetch: fetch2,\n                lastMessage: chatMessages[chatMessages.length - 1]\n            });\n            abortControllerRef.current = null;\n            mutateStatus(\"ready\");\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                mutateStatus(\"ready\");\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n            mutateStatus(\"error\");\n        }\n        const messages2 = messagesRef.current;\n        if ((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.shouldResubmitMessages)({\n            originalMaxToolInvocationStep: maxStep,\n            originalMessageCount: messageCount,\n            maxSteps,\n            messages: messages2\n        })) {\n            await triggerRequest({\n                messages: messages2\n            });\n        }\n    }, [\n        mutate,\n        mutateStatus,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamDataRef,\n        streamProtocol,\n        sendExtraMessageFields,\n        experimental_prepareRequestBody,\n        onToolCall,\n        maxSteps,\n        messagesRef,\n        abortControllerRef,\n        generateId2,\n        fetch2,\n        keepLastMessageOnError,\n        throttleWaitMs,\n        chatId\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message, { data, headers: headers2, body: body2, experimental_attachments } = {})=>{\n        var _a, _b;\n        const attachmentsForRequest = await (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.prepareAttachmentsForRequest)(experimental_attachments);\n        const messages2 = messagesRef.current.concat({\n            ...message,\n            id: (_a = message.id) != null ? _a : generateId2(),\n            createdAt: (_b = message.createdAt) != null ? _b : /* @__PURE__ */ new Date(),\n            experimental_attachments: attachmentsForRequest.length > 0 ? attachmentsForRequest : void 0,\n            parts: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.getMessageParts)(message)\n        });\n        return triggerRequest({\n            messages: messages2,\n            headers: headers2,\n            body: body2,\n            data\n        });\n    }, [\n        triggerRequest,\n        generateId2\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ data, headers: headers2, body: body2 } = {})=>{\n        const messages2 = messagesRef.current;\n        if (messages2.length === 0) {\n            return null;\n        }\n        const lastMessage = messages2[messages2.length - 1];\n        return triggerRequest({\n            messages: lastMessage.role === \"assistant\" ? messages2.slice(0, -1) : messages2,\n            headers: headers2,\n            body: body2,\n            data\n        });\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        if (typeof messages2 === \"function\") {\n            messages2 = messages2(messagesRef.current);\n        }\n        const messagesWithParts = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.fillMessageParts)(messages2);\n        mutate(messagesWithParts, false);\n        messagesRef.current = messagesWithParts;\n    }, [\n        mutate\n    ]);\n    const setData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((data)=>{\n        if (typeof data === \"function\") {\n            data = data(streamDataRef.current);\n        }\n        mutateStreamData(data, false);\n        streamDataRef.current = data;\n    }, [\n        mutateStreamData\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (event, options = {}, metadata)=>{\n        var _a;\n        (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n        if (!input && !options.allowEmptySubmit) return;\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        const attachmentsForRequest = await (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.prepareAttachmentsForRequest)(options.experimental_attachments);\n        const messages2 = messagesRef.current.concat({\n            id: generateId2(),\n            createdAt: /* @__PURE__ */ new Date(),\n            role: \"user\",\n            content: input,\n            experimental_attachments: attachmentsForRequest.length > 0 ? attachmentsForRequest : void 0,\n            parts: [\n                {\n                    type: \"text\",\n                    text: input\n                }\n            ]\n        });\n        const chatRequest = {\n            messages: messages2,\n            headers: options.headers,\n            body: options.body,\n            data: options.data\n        };\n        triggerRequest(chatRequest);\n        setInput(\"\");\n    }, [\n        input,\n        generateId2,\n        triggerRequest\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    const addToolResult = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ toolCallId, result })=>{\n        const currentMessages = messagesRef.current;\n        (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.updateToolCallResult)({\n            messages: currentMessages,\n            toolCallId,\n            toolResult: result\n        });\n        mutate(currentMessages, false);\n        const lastMessage = currentMessages[currentMessages.length - 1];\n        if ((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.isAssistantMessageWithCompletedToolCalls)(lastMessage)) {\n            triggerRequest({\n                messages: currentMessages\n            });\n        }\n    }, [\n        mutate,\n        triggerRequest\n    ]);\n    return {\n        messages: messages != null ? messages : [],\n        id: chatId,\n        setMessages,\n        data: streamData,\n        setData,\n        error,\n        append,\n        reload,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading: status === \"submitted\" || status === \"streaming\",\n        status,\n        addToolResult\n    };\n}\n// src/use-completion.ts\n\n\n\nfunction useCompletion({ api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, streamProtocol = \"data\", fetch: fetch2, onResponse, onFinish, onError, experimental_throttle: throttleWaitMs } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n        completionId,\n        \"streamData\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.callCompletionApi)({\n            api,\n            prompt,\n            credentials: extraMetadataRef.current.credentials,\n            headers: {\n                ...extraMetadataRef.current.headers,\n                ...options == null ? void 0 : options.headers\n            },\n            body: {\n                ...extraMetadataRef.current.body,\n                ...options == null ? void 0 : options.body\n            },\n            streamProtocol,\n            fetch: fetch2,\n            // throttle streamed ui updates:\n            setCompletion: throttle((completion2)=>mutate(completion2, false), throttleWaitMs),\n            onData: throttle((data2)=>mutateStreamData([\n                    ...streamData != null ? streamData : [],\n                    ...data2 != null ? data2 : []\n                ], false), throttleWaitMs),\n            setLoading: mutateLoading,\n            setError,\n            setAbortController,\n            onResponse,\n            onFinish,\n            onError\n        }), [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        streamData,\n        streamProtocol,\n        fetch2,\n        mutateStreamData,\n        throttleWaitMs\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        var _a;\n        (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n        return input ? complete(input) : void 0;\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        setInput(e.target.value);\n    }, [\n        setInput\n    ]);\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// src/use-object.ts\n\n\n\n\nvar getOriginalFetch2 = ()=>fetch;\nfunction useObject({ api, id, schema, // required, in the future we will use it for validation\ninitialValue, fetch: fetch2, onError, onFinish, headers }) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id != null ? id : hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialValue\n    });\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        var _a;\n        try {\n            (_a = abortControllerRef.current) == null ? void 0 : _a.abort();\n        } catch (ignored) {} finally{\n            setIsLoading(false);\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const submit = async (input)=>{\n        var _a;\n        try {\n            mutate(void 0);\n            setIsLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            const actualFetch = fetch2 != null ? fetch2 : getOriginalFetch2();\n            const response = await actualFetch(api, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...headers\n                },\n                signal: abortController.signal,\n                body: JSON.stringify(input)\n            });\n            if (!response.ok) {\n                throw new Error((_a = await response.text()) != null ? _a : \"Failed to fetch the response.\");\n            }\n            if (response.body == null) {\n                throw new Error(\"The response body is empty.\");\n            }\n            let accumulatedText = \"\";\n            let latestObject = void 0;\n            await response.body.pipeThrough(new TextDecoderStream()).pipeTo(new WritableStream({\n                write (chunk) {\n                    accumulatedText += chunk;\n                    const { value } = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.parsePartialJson)(accumulatedText);\n                    const currentObject = value;\n                    if (!(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.isDeepEqualData)(latestObject, currentObject)) {\n                        latestObject = currentObject;\n                        mutate(currentObject);\n                    }\n                },\n                close () {\n                    setIsLoading(false);\n                    abortControllerRef.current = null;\n                    if (onFinish != null) {\n                        const validationResult = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n                            value: latestObject,\n                            schema: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema)\n                        });\n                        onFinish(validationResult.success ? {\n                            object: validationResult.value,\n                            error: void 0\n                        } : {\n                            object: void 0,\n                            error: validationResult.error\n                        });\n                    }\n                }\n            }));\n        } catch (error2) {\n            if ((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_1__.isAbortError)(error2)) {\n                return;\n            }\n            if (onError && error2 instanceof Error) {\n                onError(error2);\n            }\n            setIsLoading(false);\n            setError(error2 instanceof Error ? error2 : new Error(String(error2)));\n        }\n    };\n    return {\n        submit,\n        object: data,\n        error,\n        isLoading,\n        stop\n    };\n}\nvar experimental_useObject = useObject;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yZWFjdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSx1QkFBdUI7QUFDK0I7QUFJNUI7QUFDNEI7QUFDdEQsSUFBSU0sbUJBQW1CLElBQU1DO0FBQzdCLFNBQVNDLGFBQWEsRUFDcEJDLEdBQUcsRUFDSEMsVUFBVUMsYUFBYSxFQUN2QkMsV0FBVyxFQUNYQyxPQUFPLEVBQ1BDLElBQUksRUFDSkMsT0FBTyxFQUNQUixPQUFPUyxNQUFNLEVBQ2Q7SUFDQyxNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR2IsK0NBQVFBLENBQUMsRUFBRTtJQUMzQyxNQUFNLENBQUNjLE9BQU9DLFNBQVMsR0FBR2YsK0NBQVFBLENBQUM7SUFDbkMsTUFBTSxDQUFDZ0IsaUJBQWlCQyxtQkFBbUIsR0FBR2pCLCtDQUFRQSxDQUNwRCxLQUFLO0lBRVAsTUFBTSxDQUFDa0IsUUFBUUMsVUFBVSxHQUFHbkIsK0NBQVFBLENBQUM7SUFDckMsTUFBTSxDQUFDb0IsT0FBT0MsU0FBUyxHQUFHckIsK0NBQVFBLENBQUMsS0FBSztJQUN4QyxNQUFNc0Isb0JBQW9CLENBQUNDO1FBQ3pCUixTQUFTUSxNQUFNQyxNQUFNLENBQUNDLEtBQUs7SUFDN0I7SUFDQSxNQUFNQyxxQkFBcUIzQiw2Q0FBTUEsQ0FBQztJQUNsQyxNQUFNNEIsT0FBTzdCLGtEQUFXQSxDQUFDO1FBQ3ZCLElBQUk0QixtQkFBbUJFLE9BQU8sRUFBRTtZQUM5QkYsbUJBQW1CRSxPQUFPLENBQUNDLEtBQUs7WUFDaENILG1CQUFtQkUsT0FBTyxHQUFHO1FBQy9CO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsTUFBTUUsU0FBUyxPQUFPQyxTQUFTQztRQUM3QixJQUFJQyxJQUFJQztRQUNSZixVQUFVO1FBQ1ZOLFlBQVksQ0FBQ3NCO1lBQ1gsSUFBSUM7WUFDSixPQUFPO21CQUNGRDtnQkFDSDtvQkFDRSxHQUFHSixPQUFPO29CQUNWTSxJQUFJLENBQUNE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TCxPQUFPd0wsaUJBQWlCeEwsS0FBSzt3QkFBQztvQkFFbkk7Z0JBQ0Y7WUFDRjtRQUVKLEVBQUUsT0FBTzJDLFFBQVE7WUFDZixJQUFJa0gsOERBQWFBLENBQUNsSCxTQUFTO2dCQUN6QjtZQUNGO1lBQ0EsSUFBSXJELFdBQVdxRCxrQkFBa0JkLE9BQU87Z0JBQ3RDdkMsUUFBUXFEO1lBQ1Y7WUFDQWdJLGFBQWE7WUFDYjFLLFNBQVMwQyxrQkFBa0JkLFFBQVFjLFNBQVMsSUFBSWQsTUFBTThKLE9BQU9oSjtRQUMvRDtJQUNGO0lBQ0EsT0FBTztRQUNMa0k7UUFDQWEsUUFBUS9KO1FBQ1IzQjtRQUNBd0k7UUFDQWpJO0lBQ0Y7QUFDRjtBQUNBLElBQUlxTCx5QkFBeUJwQjtBQU0zQixDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NoZXJsb2ctZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yZWFjdC9kaXN0L2luZGV4Lm1qcz9iYzI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91c2UtYXNzaXN0YW50LnRzXG5pbXBvcnQgeyBpc0Fib3J0RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVJZCxcbiAgcHJvY2Vzc0Fzc2lzdGFudFN0cmVhbVxufSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBnZXRPcmlnaW5hbEZldGNoID0gKCkgPT4gZmV0Y2g7XG5mdW5jdGlvbiB1c2VBc3Npc3RhbnQoe1xuICBhcGksXG4gIHRocmVhZElkOiB0aHJlYWRJZFBhcmFtLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgb25FcnJvcixcbiAgZmV0Y2g6IGZldGNoMlxufSkge1xuICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZShcIlwiKTtcbiAgY29uc3QgW2N1cnJlbnRUaHJlYWRJZCwgc2V0Q3VycmVudFRocmVhZElkXSA9IHVzZVN0YXRlKFxuICAgIHZvaWQgMFxuICApO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gdXNlU3RhdGUoXCJhd2FpdGluZ19tZXNzYWdlXCIpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKHZvaWQgMCk7XG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgc2V0SW5wdXQoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgfTtcbiAgY29uc3QgYWJvcnRDb250cm9sbGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCkge1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQuYWJvcnQoKTtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgYXBwZW5kID0gYXN5bmMgKG1lc3NhZ2UsIHJlcXVlc3RPcHRpb25zKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBzZXRTdGF0dXMoXCJpbl9wcm9ncmVzc1wiKTtcbiAgICBzZXRNZXNzYWdlcygobWVzc2FnZXMyKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLi4ubWVzc2FnZXMyLFxuICAgICAgICB7XG4gICAgICAgICAgLi4ubWVzc2FnZSxcbiAgICAgICAgICBpZDogKF9hMiA9IG1lc3NhZ2UuaWQpICE9IG51bGwgPyBfYTIgOiBnZW5lcmF0ZUlkKClcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9KTtcbiAgICBzZXRJbnB1dChcIlwiKTtcbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdHJ5IHtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gYWJvcnRDb250cm9sbGVyO1xuICAgICAgY29uc3QgYWN0dWFsRmV0Y2ggPSBmZXRjaDIgIT0gbnVsbCA/IGZldGNoMiA6IGdldE9yaWdpbmFsRmV0Y2goKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWN0dWFsRmV0Y2goYXBpLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsIC4uLmhlYWRlcnMgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIC4uLmJvZHksXG4gICAgICAgICAgLy8gYWx3YXlzIHVzZSB1c2VyLXByb3ZpZGVkIHRocmVhZElkIHdoZW4gYXZhaWxhYmxlOlxuICAgICAgICAgIHRocmVhZElkOiAoX2EgPSB0aHJlYWRJZFBhcmFtICE9IG51bGwgPyB0aHJlYWRJZFBhcmFtIDogY3VycmVudFRocmVhZElkKSAhPSBudWxsID8gX2EgOiBudWxsLFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgICAvLyBvcHRpb25hbCByZXF1ZXN0IGRhdGE6XG4gICAgICAgICAgZGF0YTogcmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHJlcXVlc3RPcHRpb25zLmRhdGFcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgKF9iID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpKSAhPSBudWxsID8gX2IgOiBcIkZhaWxlZCB0byBmZXRjaCB0aGUgYXNzaXN0YW50IHJlc3BvbnNlLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHByb2Nlc3NBc3Npc3RhbnRTdHJlYW0oe1xuICAgICAgICBzdHJlYW06IHJlc3BvbnNlLmJvZHksXG4gICAgICAgIG9uQXNzaXN0YW50TWVzc2FnZVBhcnQodmFsdWUpIHtcbiAgICAgICAgICBzZXRNZXNzYWdlcygobWVzc2FnZXMyKSA9PiBbXG4gICAgICAgICAgICAuLi5tZXNzYWdlczIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkOiB2YWx1ZS5pZCxcbiAgICAgICAgICAgICAgcm9sZTogdmFsdWUucm9sZSxcbiAgICAgICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudFswXS50ZXh0LnZhbHVlLFxuICAgICAgICAgICAgICBwYXJ0czogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UZXh0UGFydCh2YWx1ZSkge1xuICAgICAgICAgIHNldE1lc3NhZ2VzKChtZXNzYWdlczIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXMyW21lc3NhZ2VzMi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIC4uLm1lc3NhZ2VzMi5zbGljZSgwLCBtZXNzYWdlczIubGVuZ3RoIC0gMSksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogbGFzdE1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgcm9sZTogbGFzdE1lc3NhZ2Uucm9sZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBsYXN0TWVzc2FnZS5jb250ZW50ICsgdmFsdWUsXG4gICAgICAgICAgICAgICAgcGFydHM6IGxhc3RNZXNzYWdlLnBhcnRzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQXNzaXN0YW50Q29udHJvbERhdGFQYXJ0KHZhbHVlKSB7XG4gICAgICAgICAgc2V0Q3VycmVudFRocmVhZElkKHZhbHVlLnRocmVhZElkKTtcbiAgICAgICAgICBzZXRNZXNzYWdlcygobWVzc2FnZXMyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzMlttZXNzYWdlczIubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBsYXN0TWVzc2FnZS5pZCA9IHZhbHVlLm1lc3NhZ2VJZDtcbiAgICAgICAgICAgIHJldHVybiBbLi4ubWVzc2FnZXMyLnNsaWNlKDAsIG1lc3NhZ2VzMi5sZW5ndGggLSAxKSwgbGFzdE1lc3NhZ2VdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkRhdGFNZXNzYWdlUGFydCh2YWx1ZSkge1xuICAgICAgICAgIHNldE1lc3NhZ2VzKChtZXNzYWdlczIpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAuLi5tZXNzYWdlczIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogKF9hMiA9IHZhbHVlLmlkKSAhPSBudWxsID8gX2EyIDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgICAgICAgIHJvbGU6IFwiZGF0YVwiLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogdmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgICBwYXJ0czogW11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvclBhcnQodmFsdWUpIHtcbiAgICAgICAgICBzZXRFcnJvcihuZXcgRXJyb3IodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yMikgJiYgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9uRXJyb3IgJiYgZXJyb3IyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnJvcjIpO1xuICAgICAgfVxuICAgICAgc2V0RXJyb3IoZXJyb3IyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgc2V0U3RhdHVzKFwiYXdhaXRpbmdfbWVzc2FnZVwiKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN1Ym1pdE1lc3NhZ2UgPSBhc3luYyAoZXZlbnQsIHJlcXVlc3RPcHRpb25zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IGV2ZW50ID09IG51bGwgPyB2b2lkIDAgOiBldmVudC5wcmV2ZW50RGVmYXVsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoZXZlbnQpO1xuICAgIGlmIChpbnB1dCA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhcHBlbmQoeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogaW5wdXQsIHBhcnRzOiBbXSB9LCByZXF1ZXN0T3B0aW9ucyk7XG4gIH07XG4gIGNvbnN0IHNldFRocmVhZElkID0gKHRocmVhZElkKSA9PiB7XG4gICAgc2V0Q3VycmVudFRocmVhZElkKHRocmVhZElkKTtcbiAgICBzZXRNZXNzYWdlcyhbXSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgYXBwZW5kLFxuICAgIG1lc3NhZ2VzLFxuICAgIHNldE1lc3NhZ2VzLFxuICAgIHRocmVhZElkOiBjdXJyZW50VGhyZWFkSWQsXG4gICAgc2V0VGhyZWFkSWQsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgc3VibWl0TWVzc2FnZSxcbiAgICBzdGF0dXMsXG4gICAgZXJyb3IsXG4gICAgc3RvcFxuICB9O1xufVxuXG4vLyBzcmMvdXNlLWNoYXQudHNcbmltcG9ydCB7XG4gIGNhbGxDaGF0QXBpLFxuICBleHRyYWN0TWF4VG9vbEludm9jYXRpb25TdGVwLFxuICBmaWxsTWVzc2FnZVBhcnRzLFxuICBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRGdW5jLFxuICBnZXRNZXNzYWdlUGFydHMsXG4gIGlzQXNzaXN0YW50TWVzc2FnZVdpdGhDb21wbGV0ZWRUb29sQ2FsbHMsXG4gIHByZXBhcmVBdHRhY2htZW50c0ZvclJlcXVlc3QsXG4gIHNob3VsZFJlc3VibWl0TWVzc2FnZXMsXG4gIHVwZGF0ZVRvb2xDYWxsUmVzdWx0XG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsIHVzZUVmZmVjdCwgdXNlUmVmIGFzIHVzZVJlZjIsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHVzZVNXUiBmcm9tIFwic3dyXCI7XG5cbi8vIHNyYy90aHJvdHRsZS50c1xuaW1wb3J0IHRocm90dGxlRnVuY3Rpb24gZnJvbSBcInRocm90dGxlaXRcIjtcbmZ1bmN0aW9uIHRocm90dGxlKGZuLCB3YWl0TXMpIHtcbiAgcmV0dXJuIHdhaXRNcyAhPSBudWxsID8gdGhyb3R0bGVGdW5jdGlvbihmbiwgd2FpdE1zKSA6IGZuO1xufVxuXG4vLyBzcmMvdXNlLWNoYXQudHNcbmZ1bmN0aW9uIHVzZUNoYXQoe1xuICBhcGkgPSBcIi9hcGkvY2hhdFwiLFxuICBpZCxcbiAgaW5pdGlhbE1lc3NhZ2VzLFxuICBpbml0aWFsSW5wdXQgPSBcIlwiLFxuICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICBvblRvb2xDYWxsLFxuICBleHBlcmltZW50YWxfcHJlcGFyZVJlcXVlc3RCb2R5LFxuICBtYXhTdGVwcyA9IDEsXG4gIHN0cmVhbVByb3RvY29sID0gXCJkYXRhXCIsXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBnZW5lcmF0ZUlkRnVuYyxcbiAgZmV0Y2g6IGZldGNoMixcbiAga2VlcExhc3RNZXNzYWdlT25FcnJvciA9IHRydWUsXG4gIGV4cGVyaW1lbnRhbF90aHJvdHRsZTogdGhyb3R0bGVXYWl0TXNcbn0gPSB7fSkge1xuICBjb25zdCBbaG9va0lkXSA9IHVzZVN0YXRlMihnZW5lcmF0ZUlkMik7XG4gIGNvbnN0IGNoYXRJZCA9IGlkICE9IG51bGwgPyBpZCA6IGhvb2tJZDtcbiAgY29uc3QgY2hhdEtleSA9IHR5cGVvZiBhcGkgPT09IFwic3RyaW5nXCIgPyBbYXBpLCBjaGF0SWRdIDogY2hhdElkO1xuICBjb25zdCBbaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2tdID0gdXNlU3RhdGUyKFtdKTtcbiAgY29uc3QgeyBkYXRhOiBtZXNzYWdlcywgbXV0YXRlIH0gPSB1c2VTV1IoXG4gICAgW2NoYXRLZXksIFwibWVzc2FnZXNcIl0sXG4gICAgbnVsbCxcbiAgICB7XG4gICAgICBmYWxsYmFja0RhdGE6IGluaXRpYWxNZXNzYWdlcyAhPSBudWxsID8gZmlsbE1lc3NhZ2VQYXJ0cyhpbml0aWFsTWVzc2FnZXMpIDogaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2tcbiAgICB9XG4gICk7XG4gIGNvbnN0IG1lc3NhZ2VzUmVmID0gdXNlUmVmMihtZXNzYWdlcyB8fCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbWVzc2FnZXNSZWYuY3VycmVudCA9IG1lc3NhZ2VzIHx8IFtdO1xuICB9LCBbbWVzc2FnZXNdKTtcbiAgY29uc3QgeyBkYXRhOiBzdHJlYW1EYXRhLCBtdXRhdGU6IG11dGF0ZVN0cmVhbURhdGEgfSA9IHVzZVNXUihbY2hhdEtleSwgXCJzdHJlYW1EYXRhXCJdLCBudWxsKTtcbiAgY29uc3Qgc3RyZWFtRGF0YVJlZiA9IHVzZVJlZjIoc3RyZWFtRGF0YSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc3RyZWFtRGF0YVJlZi5jdXJyZW50ID0gc3RyZWFtRGF0YTtcbiAgfSwgW3N0cmVhbURhdGFdKTtcbiAgY29uc3QgeyBkYXRhOiBzdGF0dXMgPSBcInJlYWR5XCIsIG11dGF0ZTogbXV0YXRlU3RhdHVzIH0gPSB1c2VTV1IoW2NoYXRLZXksIFwic3RhdHVzXCJdLCBudWxsKTtcbiAgY29uc3QgeyBkYXRhOiBlcnJvciA9IHZvaWQgMCwgbXV0YXRlOiBzZXRFcnJvciB9ID0gdXNlU1dSKFtjaGF0S2V5LCBcImVycm9yXCJdLCBudWxsKTtcbiAgY29uc3QgYWJvcnRDb250cm9sbGVyUmVmID0gdXNlUmVmMihudWxsKTtcbiAgY29uc3QgZXh0cmFNZXRhZGF0YVJlZiA9IHVzZVJlZjIoe1xuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keVxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSwgW2NyZWRlbnRpYWxzLCBoZWFkZXJzLCBib2R5XSk7XG4gIGNvbnN0IHRyaWdnZXJSZXF1ZXN0ID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jIChjaGF0UmVxdWVzdCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIG11dGF0ZVN0YXR1cyhcInN1Ym1pdHRlZFwiKTtcbiAgICAgIHNldEVycm9yKHZvaWQgMCk7XG4gICAgICBjb25zdCBjaGF0TWVzc2FnZXMgPSBmaWxsTWVzc2FnZVBhcnRzKGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VDb3VudCA9IGNoYXRNZXNzYWdlcy5sZW5ndGg7XG4gICAgICBjb25zdCBtYXhTdGVwID0gZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcChcbiAgICAgICAgKF9hID0gY2hhdE1lc3NhZ2VzW2NoYXRNZXNzYWdlcy5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRvb2xJbnZvY2F0aW9uc1xuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IHRocm90dGxlZE11dGF0ZSA9IHRocm90dGxlKG11dGF0ZSwgdGhyb3R0bGVXYWl0TXMpO1xuICAgICAgICBjb25zdCB0aHJvdHRsZWRNdXRhdGVTdHJlYW1EYXRhID0gdGhyb3R0bGUoXG4gICAgICAgICAgbXV0YXRlU3RyZWFtRGF0YSxcbiAgICAgICAgICB0aHJvdHRsZVdhaXRNc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBwcmV2aW91c01lc3NhZ2VzID0gbWVzc2FnZXNSZWYuY3VycmVudDtcbiAgICAgICAgdGhyb3R0bGVkTXV0YXRlKGNoYXRNZXNzYWdlcywgZmFsc2UpO1xuICAgICAgICBjb25zdCBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCA9IHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMgPyBjaGF0TWVzc2FnZXMgOiBjaGF0TWVzc2FnZXMubWFwKFxuICAgICAgICAgICh7XG4gICAgICAgICAgICByb2xlLFxuICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9hdHRhY2htZW50cyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgICAgIHRvb2xJbnZvY2F0aW9ucyxcbiAgICAgICAgICAgIHBhcnRzXG4gICAgICAgICAgfSkgPT4gKHtcbiAgICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgLi4uZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzICE9PSB2b2lkIDAgJiYge1xuICAgICAgICAgICAgICBleHBlcmltZW50YWxfYXR0YWNobWVudHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5kYXRhICE9PSB2b2lkIDAgJiYgeyBkYXRhIH0sXG4gICAgICAgICAgICAuLi5hbm5vdGF0aW9ucyAhPT0gdm9pZCAwICYmIHsgYW5ub3RhdGlvbnMgfSxcbiAgICAgICAgICAgIC4uLnRvb2xJbnZvY2F0aW9ucyAhPT0gdm9pZCAwICYmIHsgdG9vbEludm9jYXRpb25zIH0sXG4gICAgICAgICAgICAuLi5wYXJ0cyAhPT0gdm9pZCAwICYmIHsgcGFydHMgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRGF0YSA9IHN0cmVhbURhdGFSZWYuY3VycmVudDtcbiAgICAgICAgYXdhaXQgY2FsbENoYXRBcGkoe1xuICAgICAgICAgIGFwaSxcbiAgICAgICAgICBib2R5OiAoX2IgPSBleHBlcmltZW50YWxfcHJlcGFyZVJlcXVlc3RCb2R5ID09IG51bGwgPyB2b2lkIDAgOiBleHBlcmltZW50YWxfcHJlcGFyZVJlcXVlc3RCb2R5KHtcbiAgICAgICAgICAgIGlkOiBjaGF0SWQsXG4gICAgICAgICAgICBtZXNzYWdlczogY2hhdE1lc3NhZ2VzLFxuICAgICAgICAgICAgcmVxdWVzdERhdGE6IGNoYXRSZXF1ZXN0LmRhdGEsXG4gICAgICAgICAgICByZXF1ZXN0Qm9keTogY2hhdFJlcXVlc3QuYm9keVxuICAgICAgICAgIH0pKSAhPSBudWxsID8gX2IgOiB7XG4gICAgICAgICAgICBpZDogY2hhdElkLFxuICAgICAgICAgICAgbWVzc2FnZXM6IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkLFxuICAgICAgICAgICAgZGF0YTogY2hhdFJlcXVlc3QuZGF0YSxcbiAgICAgICAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgICAgICAgLi4uY2hhdFJlcXVlc3QuYm9keVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RyZWFtUHJvdG9jb2wsXG4gICAgICAgICAgY3JlZGVudGlhbHM6IGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5jcmVkZW50aWFscyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuaGVhZGVycyxcbiAgICAgICAgICAgIC4uLmNoYXRSZXF1ZXN0LmhlYWRlcnNcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFib3J0Q29udHJvbGxlcjogKCkgPT4gYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQsXG4gICAgICAgICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCkge1xuICAgICAgICAgICAgaWYgKCFrZWVwTGFzdE1lc3NhZ2VPbkVycm9yKSB7XG4gICAgICAgICAgICAgIHRocm90dGxlZE11dGF0ZShwcmV2aW91c01lc3NhZ2VzLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblJlc3BvbnNlLFxuICAgICAgICAgIG9uVXBkYXRlKHsgbWVzc2FnZSwgZGF0YSwgcmVwbGFjZUxhc3RNZXNzYWdlIH0pIHtcbiAgICAgICAgICAgIG11dGF0ZVN0YXR1cyhcInN0cmVhbWluZ1wiKTtcbiAgICAgICAgICAgIHRocm90dGxlZE11dGF0ZShcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC4uLnJlcGxhY2VMYXN0TWVzc2FnZSA/IGNoYXRNZXNzYWdlcy5zbGljZSgwLCBjaGF0TWVzc2FnZXMubGVuZ3RoIC0gMSkgOiBjaGF0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdHRsZWRNdXRhdGVTdHJlYW1EYXRhKFxuICAgICAgICAgICAgICAgIFsuLi5leGlzdGluZ0RhdGEgIT0gbnVsbCA/IGV4aXN0aW5nRGF0YSA6IFtdLCAuLi5kYXRhXSxcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25Ub29sQ2FsbCxcbiAgICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMixcbiAgICAgICAgICBmZXRjaDogZmV0Y2gyLFxuICAgICAgICAgIGxhc3RNZXNzYWdlOiBjaGF0TWVzc2FnZXNbY2hhdE1lc3NhZ2VzLmxlbmd0aCAtIDFdXG4gICAgICAgIH0pO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIG11dGF0ZVN0YXR1cyhcInJlYWR5XCIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgbXV0YXRlU3RhdHVzKFwicmVhZHlcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRXJyb3IgJiYgZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RXJyb3IoZXJyKTtcbiAgICAgICAgbXV0YXRlU3RhdHVzKFwiZXJyb3JcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXNzYWdlczIgPSBtZXNzYWdlc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKHNob3VsZFJlc3VibWl0TWVzc2FnZXMoe1xuICAgICAgICBvcmlnaW5hbE1heFRvb2xJbnZvY2F0aW9uU3RlcDogbWF4U3RlcCxcbiAgICAgICAgb3JpZ2luYWxNZXNzYWdlQ291bnQ6IG1lc3NhZ2VDb3VudCxcbiAgICAgICAgbWF4U3RlcHMsXG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlczJcbiAgICAgIH0pKSB7XG4gICAgICAgIGF3YWl0IHRyaWdnZXJSZXF1ZXN0KHsgbWVzc2FnZXM6IG1lc3NhZ2VzMiB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIG11dGF0ZSxcbiAgICAgIG11dGF0ZVN0YXR1cyxcbiAgICAgIGFwaSxcbiAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICBvblJlc3BvbnNlLFxuICAgICAgb25GaW5pc2gsXG4gICAgICBvbkVycm9yLFxuICAgICAgc2V0RXJyb3IsXG4gICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgICAgc3RyZWFtRGF0YVJlZixcbiAgICAgIHN0cmVhbVByb3RvY29sLFxuICAgICAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgICAgIGV4cGVyaW1lbnRhbF9wcmVwYXJlUmVxdWVzdEJvZHksXG4gICAgICBvblRvb2xDYWxsLFxuICAgICAgbWF4U3RlcHMsXG4gICAgICBtZXNzYWdlc1JlZixcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZixcbiAgICAgIGdlbmVyYXRlSWQyLFxuICAgICAgZmV0Y2gyLFxuICAgICAga2VlcExhc3RNZXNzYWdlT25FcnJvcixcbiAgICAgIHRocm90dGxlV2FpdE1zLFxuICAgICAgY2hhdElkXG4gICAgXVxuICApO1xuICBjb25zdCBhcHBlbmQgPSB1c2VDYWxsYmFjazIoXG4gICAgYXN5bmMgKG1lc3NhZ2UsIHtcbiAgICAgIGRhdGEsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzMixcbiAgICAgIGJvZHk6IGJvZHkyLFxuICAgICAgZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzXG4gICAgfSA9IHt9KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgYXR0YWNobWVudHNGb3JSZXF1ZXN0ID0gYXdhaXQgcHJlcGFyZUF0dGFjaG1lbnRzRm9yUmVxdWVzdChcbiAgICAgICAgZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzXG4gICAgICApO1xuICAgICAgY29uc3QgbWVzc2FnZXMyID0gbWVzc2FnZXNSZWYuY3VycmVudC5jb25jYXQoe1xuICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICBpZDogKF9hID0gbWVzc2FnZS5pZCkgIT0gbnVsbCA/IF9hIDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgY3JlYXRlZEF0OiAoX2IgPSBtZXNzYWdlLmNyZWF0ZWRBdCkgIT0gbnVsbCA/IF9iIDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgIGV4cGVyaW1lbnRhbF9hdHRhY2htZW50czogYXR0YWNobWVudHNGb3JSZXF1ZXN0Lmxlbmd0aCA+IDAgPyBhdHRhY2htZW50c0ZvclJlcXVlc3QgOiB2b2lkIDAsXG4gICAgICAgIHBhcnRzOiBnZXRNZXNzYWdlUGFydHMobWVzc2FnZSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KHsgbWVzc2FnZXM6IG1lc3NhZ2VzMiwgaGVhZGVyczogaGVhZGVyczIsIGJvZHk6IGJvZHkyLCBkYXRhIH0pO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0LCBnZW5lcmF0ZUlkMl1cbiAgKTtcbiAgY29uc3QgcmVsb2FkID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jICh7IGRhdGEsIGhlYWRlcnM6IGhlYWRlcnMyLCBib2R5OiBib2R5MiB9ID0ge30pID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzMiA9IG1lc3NhZ2VzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAobWVzc2FnZXMyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXMyW21lc3NhZ2VzMi5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdCh7XG4gICAgICAgIG1lc3NhZ2VzOiBsYXN0TWVzc2FnZS5yb2xlID09PSBcImFzc2lzdGFudFwiID8gbWVzc2FnZXMyLnNsaWNlKDAsIC0xKSA6IG1lc3NhZ2VzMixcbiAgICAgICAgaGVhZGVyczogaGVhZGVyczIsXG4gICAgICAgIGJvZHk6IGJvZHkyLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF1cbiAgKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrMigoKSA9PiB7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50KSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudC5hYm9ydCgpO1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBzZXRNZXNzYWdlcyA9IHVzZUNhbGxiYWNrMihcbiAgICAobWVzc2FnZXMyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2VzMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG1lc3NhZ2VzMiA9IG1lc3NhZ2VzMihtZXNzYWdlc1JlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lc3NhZ2VzV2l0aFBhcnRzID0gZmlsbE1lc3NhZ2VQYXJ0cyhtZXNzYWdlczIpO1xuICAgICAgbXV0YXRlKG1lc3NhZ2VzV2l0aFBhcnRzLCBmYWxzZSk7XG4gICAgICBtZXNzYWdlc1JlZi5jdXJyZW50ID0gbWVzc2FnZXNXaXRoUGFydHM7XG4gICAgfSxcbiAgICBbbXV0YXRlXVxuICApO1xuICBjb25zdCBzZXREYXRhID0gdXNlQ2FsbGJhY2syKFxuICAgIChkYXRhKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBkYXRhID0gZGF0YShzdHJlYW1EYXRhUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgbXV0YXRlU3RyZWFtRGF0YShkYXRhLCBmYWxzZSk7XG4gICAgICBzdHJlYW1EYXRhUmVmLmN1cnJlbnQgPSBkYXRhO1xuICAgIH0sXG4gICAgW211dGF0ZVN0cmVhbURhdGFdXG4gICk7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUyKGluaXRpYWxJbnB1dCk7XG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrMihcbiAgICBhc3luYyAoZXZlbnQsIG9wdGlvbnMgPSB7fSwgbWV0YWRhdGEpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IGV2ZW50ID09IG51bGwgPyB2b2lkIDAgOiBldmVudC5wcmV2ZW50RGVmYXVsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoZXZlbnQpO1xuICAgICAgaWYgKCFpbnB1dCAmJiAhb3B0aW9ucy5hbGxvd0VtcHR5U3VibWl0KVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCxcbiAgICAgICAgICAuLi5tZXRhZGF0YVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgYXR0YWNobWVudHNGb3JSZXF1ZXN0ID0gYXdhaXQgcHJlcGFyZUF0dGFjaG1lbnRzRm9yUmVxdWVzdChcbiAgICAgICAgb3B0aW9ucy5leHBlcmltZW50YWxfYXR0YWNobWVudHNcbiAgICAgICk7XG4gICAgICBjb25zdCBtZXNzYWdlczIgPSBtZXNzYWdlc1JlZi5jdXJyZW50LmNvbmNhdCh7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkMigpLFxuICAgICAgICBjcmVhdGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgY29udGVudDogaW5wdXQsXG4gICAgICAgIGV4cGVyaW1lbnRhbF9hdHRhY2htZW50czogYXR0YWNobWVudHNGb3JSZXF1ZXN0Lmxlbmd0aCA+IDAgPyBhdHRhY2htZW50c0ZvclJlcXVlc3QgOiB2b2lkIDAsXG4gICAgICAgIHBhcnRzOiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogaW5wdXQgfV1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgY2hhdFJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlczIsXG4gICAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGFcbiAgICAgIH07XG4gICAgICB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdCk7XG4gICAgICBzZXRJbnB1dChcIlwiKTtcbiAgICB9LFxuICAgIFtpbnB1dCwgZ2VuZXJhdGVJZDIsIHRyaWdnZXJSZXF1ZXN0XVxuICApO1xuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChlKSA9PiB7XG4gICAgc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICB9O1xuICBjb25zdCBhZGRUb29sUmVzdWx0ID0gdXNlQ2FsbGJhY2syKFxuICAgICh7IHRvb2xDYWxsSWQsIHJlc3VsdCB9KSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50TWVzc2FnZXMgPSBtZXNzYWdlc1JlZi5jdXJyZW50O1xuICAgICAgdXBkYXRlVG9vbENhbGxSZXN1bHQoe1xuICAgICAgICBtZXNzYWdlczogY3VycmVudE1lc3NhZ2VzLFxuICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICB0b29sUmVzdWx0OiByZXN1bHRcbiAgICAgIH0pO1xuICAgICAgbXV0YXRlKGN1cnJlbnRNZXNzYWdlcywgZmFsc2UpO1xuICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBjdXJyZW50TWVzc2FnZXNbY3VycmVudE1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGlzQXNzaXN0YW50TWVzc2FnZVdpdGhDb21wbGV0ZWRUb29sQ2FsbHMobGFzdE1lc3NhZ2UpKSB7XG4gICAgICAgIHRyaWdnZXJSZXF1ZXN0KHsgbWVzc2FnZXM6IGN1cnJlbnRNZXNzYWdlcyB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFttdXRhdGUsIHRyaWdnZXJSZXF1ZXN0XVxuICApO1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyAhPSBudWxsID8gbWVzc2FnZXMgOiBbXSxcbiAgICBpZDogY2hhdElkLFxuICAgIHNldE1lc3NhZ2VzLFxuICAgIGRhdGE6IHN0cmVhbURhdGEsXG4gICAgc2V0RGF0YSxcbiAgICBlcnJvcixcbiAgICBhcHBlbmQsXG4gICAgcmVsb2FkLFxuICAgIHN0b3AsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZzogc3RhdHVzID09PSBcInN1Ym1pdHRlZFwiIHx8IHN0YXR1cyA9PT0gXCJzdHJlYW1pbmdcIixcbiAgICBzdGF0dXMsXG4gICAgYWRkVG9vbFJlc3VsdFxuICB9O1xufVxuXG4vLyBzcmMvdXNlLWNvbXBsZXRpb24udHNcbmltcG9ydCB7XG4gIGNhbGxDb21wbGV0aW9uQXBpXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazMsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyLCB1c2VJZCwgdXNlUmVmIGFzIHVzZVJlZjMsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHVzZVNXUjIgZnJvbSBcInN3clwiO1xuZnVuY3Rpb24gdXNlQ29tcGxldGlvbih7XG4gIGFwaSA9IFwiL2FwaS9jb21wbGV0aW9uXCIsXG4gIGlkLFxuICBpbml0aWFsQ29tcGxldGlvbiA9IFwiXCIsXG4gIGluaXRpYWxJbnB1dCA9IFwiXCIsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBzdHJlYW1Qcm90b2NvbCA9IFwiZGF0YVwiLFxuICBmZXRjaDogZmV0Y2gyLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgZXhwZXJpbWVudGFsX3Rocm90dGxlOiB0aHJvdHRsZVdhaXRNc1xufSA9IHt9KSB7XG4gIGNvbnN0IGhvb2tJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IGNvbXBsZXRpb25JZCA9IGlkIHx8IGhvb2tJZDtcbiAgY29uc3QgeyBkYXRhLCBtdXRhdGUgfSA9IHVzZVNXUjIoW2FwaSwgY29tcGxldGlvbklkXSwgbnVsbCwge1xuICAgIGZhbGxiYWNrRGF0YTogaW5pdGlhbENvbXBsZXRpb25cbiAgfSk7XG4gIGNvbnN0IHsgZGF0YTogaXNMb2FkaW5nID0gZmFsc2UsIG11dGF0ZTogbXV0YXRlTG9hZGluZyB9ID0gdXNlU1dSMihcbiAgICBbY29tcGxldGlvbklkLCBcImxvYWRpbmdcIl0sXG4gICAgbnVsbFxuICApO1xuICBjb25zdCB7IGRhdGE6IHN0cmVhbURhdGEsIG11dGF0ZTogbXV0YXRlU3RyZWFtRGF0YSB9ID0gdXNlU1dSMihbY29tcGxldGlvbklkLCBcInN0cmVhbURhdGFcIl0sIG51bGwpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlMyh2b2lkIDApO1xuICBjb25zdCBjb21wbGV0aW9uID0gZGF0YTtcbiAgY29uc3QgW2Fib3J0Q29udHJvbGxlciwgc2V0QWJvcnRDb250cm9sbGVyXSA9IHVzZVN0YXRlMyhudWxsKTtcbiAgY29uc3QgZXh0cmFNZXRhZGF0YVJlZiA9IHVzZVJlZjMoe1xuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keVxuICB9KTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sIFtjcmVkZW50aWFscywgaGVhZGVycywgYm9keV0pO1xuICBjb25zdCB0cmlnZ2VyUmVxdWVzdCA9IHVzZUNhbGxiYWNrMyhcbiAgICBhc3luYyAocHJvbXB0LCBvcHRpb25zKSA9PiBjYWxsQ29tcGxldGlvbkFwaSh7XG4gICAgICBhcGksXG4gICAgICBwcm9tcHQsXG4gICAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVyczogeyAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuaGVhZGVycywgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzIH0sXG4gICAgICBib2R5OiB7XG4gICAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmJvZHlcbiAgICAgIH0sXG4gICAgICBzdHJlYW1Qcm90b2NvbCxcbiAgICAgIGZldGNoOiBmZXRjaDIsXG4gICAgICAvLyB0aHJvdHRsZSBzdHJlYW1lZCB1aSB1cGRhdGVzOlxuICAgICAgc2V0Q29tcGxldGlvbjogdGhyb3R0bGUoXG4gICAgICAgIChjb21wbGV0aW9uMikgPT4gbXV0YXRlKGNvbXBsZXRpb24yLCBmYWxzZSksXG4gICAgICAgIHRocm90dGxlV2FpdE1zXG4gICAgICApLFxuICAgICAgb25EYXRhOiB0aHJvdHRsZShcbiAgICAgICAgKGRhdGEyKSA9PiBtdXRhdGVTdHJlYW1EYXRhKFsuLi5zdHJlYW1EYXRhICE9IG51bGwgPyBzdHJlYW1EYXRhIDogW10sIC4uLmRhdGEyICE9IG51bGwgPyBkYXRhMiA6IFtdXSwgZmFsc2UpLFxuICAgICAgICB0aHJvdHRsZVdhaXRNc1xuICAgICAgKSxcbiAgICAgIHNldExvYWRpbmc6IG11dGF0ZUxvYWRpbmcsXG4gICAgICBzZXRFcnJvcixcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcixcbiAgICAgIG9uUmVzcG9uc2UsXG4gICAgICBvbkZpbmlzaCxcbiAgICAgIG9uRXJyb3JcbiAgICB9KSxcbiAgICBbXG4gICAgICBtdXRhdGUsXG4gICAgICBtdXRhdGVMb2FkaW5nLFxuICAgICAgYXBpLFxuICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcixcbiAgICAgIG9uUmVzcG9uc2UsXG4gICAgICBvbkZpbmlzaCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBzZXRFcnJvcixcbiAgICAgIHN0cmVhbURhdGEsXG4gICAgICBzdHJlYW1Qcm90b2NvbCxcbiAgICAgIGZldGNoMixcbiAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgICB0aHJvdHRsZVdhaXRNc1xuICAgIF1cbiAgKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrMygoKSA9PiB7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlcikge1xuICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgfVxuICB9LCBbYWJvcnRDb250cm9sbGVyXSk7XG4gIGNvbnN0IHNldENvbXBsZXRpb24gPSB1c2VDYWxsYmFjazMoXG4gICAgKGNvbXBsZXRpb24yKSA9PiB7XG4gICAgICBtdXRhdGUoY29tcGxldGlvbjIsIGZhbHNlKTtcbiAgICB9LFxuICAgIFttdXRhdGVdXG4gICk7XG4gIGNvbnN0IGNvbXBsZXRlID0gdXNlQ2FsbGJhY2szKFxuICAgIGFzeW5jIChwcm9tcHQsIG9wdGlvbnMpID0+IHtcbiAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChwcm9tcHQsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0XVxuICApO1xuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlMyhpbml0aWFsSW5wdXQpO1xuICBjb25zdCBoYW5kbGVTdWJtaXQgPSB1c2VDYWxsYmFjazMoXG4gICAgKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBldmVudCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnQucHJldmVudERlZmF1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGV2ZW50KTtcbiAgICAgIHJldHVybiBpbnB1dCA/IGNvbXBsZXRlKGlucHV0KSA6IHZvaWQgMDtcbiAgICB9LFxuICAgIFtpbnB1dCwgY29tcGxldGVdXG4gICk7XG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gdXNlQ2FsbGJhY2szKFxuICAgIChlKSA9PiB7XG4gICAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gICAgfSxcbiAgICBbc2V0SW5wdXRdXG4gICk7XG4gIHJldHVybiB7XG4gICAgY29tcGxldGlvbixcbiAgICBjb21wbGV0ZSxcbiAgICBlcnJvcixcbiAgICBzZXRDb21wbGV0aW9uLFxuICAgIHN0b3AsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZyxcbiAgICBkYXRhOiBzdHJlYW1EYXRhXG4gIH07XG59XG5cbi8vIHNyYy91c2Utb2JqZWN0LnRzXG5pbXBvcnQge1xuICBpc0Fib3J0RXJyb3IgYXMgaXNBYm9ydEVycm9yMixcbiAgc2FmZVZhbGlkYXRlVHlwZXNcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7XG4gIGFzU2NoZW1hLFxuICBpc0RlZXBFcXVhbERhdGEsXG4gIHBhcnNlUGFydGlhbEpzb25cbn0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrNCwgdXNlSWQgYXMgdXNlSWQyLCB1c2VSZWYgYXMgdXNlUmVmNCwgdXNlU3RhdGUgYXMgdXNlU3RhdGU0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdXNlU1dSMyBmcm9tIFwic3dyXCI7XG52YXIgZ2V0T3JpZ2luYWxGZXRjaDIgPSAoKSA9PiBmZXRjaDtcbmZ1bmN0aW9uIHVzZU9iamVjdCh7XG4gIGFwaSxcbiAgaWQsXG4gIHNjaGVtYSxcbiAgLy8gcmVxdWlyZWQsIGluIHRoZSBmdXR1cmUgd2Ugd2lsbCB1c2UgaXQgZm9yIHZhbGlkYXRpb25cbiAgaW5pdGlhbFZhbHVlLFxuICBmZXRjaDogZmV0Y2gyLFxuICBvbkVycm9yLFxuICBvbkZpbmlzaCxcbiAgaGVhZGVyc1xufSkge1xuICBjb25zdCBob29rSWQgPSB1c2VJZDIoKTtcbiAgY29uc3QgY29tcGxldGlvbklkID0gaWQgIT0gbnVsbCA/IGlkIDogaG9va0lkO1xuICBjb25zdCB7IGRhdGEsIG11dGF0ZSB9ID0gdXNlU1dSMyhcbiAgICBbYXBpLCBjb21wbGV0aW9uSWRdLFxuICAgIG51bGwsXG4gICAgeyBmYWxsYmFja0RhdGE6IGluaXRpYWxWYWx1ZSB9XG4gICk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU0KHZvaWQgMCk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZTQoZmFsc2UpO1xuICBjb25zdCBhYm9ydENvbnRyb2xsZXJSZWYgPSB1c2VSZWY0KG51bGwpO1xuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2s0KCgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgdHJ5IHtcbiAgICAgIChfYSA9IGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuYWJvcnQoKTtcbiAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHN1Ym1pdCA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICB0cnkge1xuICAgICAgbXV0YXRlKHZvaWQgMCk7XG4gICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICBzZXRFcnJvcih2b2lkIDApO1xuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICBjb25zdCBhY3R1YWxGZXRjaCA9IGZldGNoMiAhPSBudWxsID8gZmV0Y2gyIDogZ2V0T3JpZ2luYWxGZXRjaDIoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWN0dWFsRmV0Y2goYXBpLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoaW5wdXQpXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIChfYSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9hIDogXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIHJlc3BvbnNlLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBhY2N1bXVsYXRlZFRleHQgPSBcIlwiO1xuICAgICAgbGV0IGxhdGVzdE9iamVjdCA9IHZvaWQgMDtcbiAgICAgIGF3YWl0IHJlc3BvbnNlLmJvZHkucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLnBpcGVUbyhcbiAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICB3cml0ZShjaHVuaykge1xuICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0ICs9IGNodW5rO1xuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gcGFyc2VQYXJ0aWFsSnNvbihhY2N1bXVsYXRlZFRleHQpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE9iamVjdCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbERhdGEobGF0ZXN0T2JqZWN0LCBjdXJyZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICBsYXRlc3RPYmplY3QgPSBjdXJyZW50T2JqZWN0O1xuICAgICAgICAgICAgICBtdXRhdGUoY3VycmVudE9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICBpZiAob25GaW5pc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gc2FmZVZhbGlkYXRlVHlwZXMoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsYXRlc3RPYmplY3QsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBhc1NjaGVtYShzY2hlbWEpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBvbkZpbmlzaChcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MgPyB7IG9iamVjdDogdmFsaWRhdGlvblJlc3VsdC52YWx1ZSwgZXJyb3I6IHZvaWQgMCB9IDogeyBvYmplY3Q6IHZvaWQgMCwgZXJyb3I6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3IgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICBpZiAoaXNBYm9ydEVycm9yMihlcnJvcjIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvbkVycm9yICYmIGVycm9yMiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyb3IyKTtcbiAgICAgIH1cbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICBzZXRFcnJvcihlcnJvcjIgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yMiA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IyKSkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzdWJtaXQsXG4gICAgb2JqZWN0OiBkYXRhLFxuICAgIGVycm9yLFxuICAgIGlzTG9hZGluZyxcbiAgICBzdG9wXG4gIH07XG59XG52YXIgZXhwZXJpbWVudGFsX3VzZU9iamVjdCA9IHVzZU9iamVjdDtcbmV4cG9ydCB7XG4gIGV4cGVyaW1lbnRhbF91c2VPYmplY3QsXG4gIHVzZUFzc2lzdGFudCxcbiAgdXNlQ2hhdCxcbiAgdXNlQ29tcGxldGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiaXNBYm9ydEVycm9yIiwiZ2VuZXJhdGVJZCIsInByb2Nlc3NBc3Npc3RhbnRTdHJlYW0iLCJ1c2VDYWxsYmFjayIsInVzZVJlZiIsInVzZVN0YXRlIiwiZ2V0T3JpZ2luYWxGZXRjaCIsImZldGNoIiwidXNlQXNzaXN0YW50IiwiYXBpIiwidGhyZWFkSWQiLCJ0aHJlYWRJZFBhcmFtIiwiY3JlZGVudGlhbHMiLCJoZWFkZXJzIiwiYm9keSIsIm9uRXJyb3IiLCJmZXRjaDIiLCJtZXNzYWdlcyIsInNldE1lc3NhZ2VzIiwiaW5wdXQiLCJzZXRJbnB1dCIsImN1cnJlbnRUaHJlYWRJZCIsInNldEN1cnJlbnRUaHJlYWRJZCIsInN0YXR1cyIsInNldFN0YXR1cyIsImVycm9yIiwic2V0RXJyb3IiLCJoYW5kbGVJbnB1dENoYW5nZSIsImV2ZW50IiwidGFyZ2V0IiwidmFsdWUiLCJhYm9ydENvbnRyb2xsZXJSZWYiLCJzdG9wIiwiY3VycmVudCIsImFib3J0IiwiYXBwZW5kIiwibWVzc2FnZSIsInJlcXVlc3RPcHRpb25zIiwiX2EiLCJfYiIsIm1lc3NhZ2VzMiIsIl9hMiIsImlkIiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiYWN0dWFsRmV0Y2giLCJyZXNwb25zZSIsIm1ldGhvZCIsInNpZ25hbCIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb250ZW50IiwiZGF0YSIsIm9rIiwiRXJyb3IiLCJ0ZXh0Iiwic3RyZWFtIiwib25Bc3Npc3RhbnRNZXNzYWdlUGFydCIsInJvbGUiLCJwYXJ0cyIsIm9uVGV4dFBhcnQiLCJsYXN0TWVzc2FnZSIsImxlbmd0aCIsInNsaWNlIiwib25Bc3Npc3RhbnRDb250cm9sRGF0YVBhcnQiLCJtZXNzYWdlSWQiLCJvbkRhdGFNZXNzYWdlUGFydCIsIm9uRXJyb3JQYXJ0IiwiZXJyb3IyIiwiYWJvcnRlZCIsInN1Ym1pdE1lc3NhZ2UiLCJwcmV2ZW50RGVmYXVsdCIsImNhbGwiLCJzZXRUaHJlYWRJZCIsImNhbGxDaGF0QXBpIiwiZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcCIsImZpbGxNZXNzYWdlUGFydHMiLCJnZW5lcmF0ZUlkRnVuYyIsImdldE1lc3NhZ2VQYXJ0cyIsImlzQXNzaXN0YW50TWVzc2FnZVdpdGhDb21wbGV0ZWRUb29sQ2FsbHMiLCJwcmVwYXJlQXR0YWNobWVudHNGb3JSZXF1ZXN0Iiwic2hvdWxkUmVzdWJtaXRNZXNzYWdlcyIsInVwZGF0ZVRvb2xDYWxsUmVzdWx0IiwidXNlQ2FsbGJhY2syIiwidXNlRWZmZWN0IiwidXNlUmVmMiIsInVzZVN0YXRlMiIsInVzZVNXUiIsInRocm90dGxlRnVuY3Rpb24iLCJ0aHJvdHRsZSIsImZuIiwid2FpdE1zIiwidXNlQ2hhdCIsImluaXRpYWxNZXNzYWdlcyIsImluaXRpYWxJbnB1dCIsInNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMiLCJvblRvb2xDYWxsIiwiZXhwZXJpbWVudGFsX3ByZXBhcmVSZXF1ZXN0Qm9keSIsIm1heFN0ZXBzIiwic3RyZWFtUHJvdG9jb2wiLCJvblJlc3BvbnNlIiwib25GaW5pc2giLCJnZW5lcmF0ZUlkMiIsImtlZXBMYXN0TWVzc2FnZU9uRXJyb3IiLCJleHBlcmltZW50YWxfdGhyb3R0bGUiLCJ0aHJvdHRsZVdhaXRNcyIsImhvb2tJZCIsImNoYXRJZCIsImNoYXRLZXkiLCJpbml0aWFsTWVzc2FnZXNGYWxsYmFjayIsIm11dGF0ZSIsImZhbGxiYWNrRGF0YSIsIm1lc3NhZ2VzUmVmIiwic3RyZWFtRGF0YSIsIm11dGF0ZVN0cmVhbURhdGEiLCJzdHJlYW1EYXRhUmVmIiwibXV0YXRlU3RhdHVzIiwiZXh0cmFNZXRhZGF0YVJlZiIsInRyaWdnZXJSZXF1ZXN0IiwiY2hhdFJlcXVlc3QiLCJjaGF0TWVzc2FnZXMiLCJtZXNzYWdlQ291bnQiLCJtYXhTdGVwIiwidG9vbEludm9jYXRpb25zIiwidGhyb3R0bGVkTXV0YXRlIiwidGhyb3R0bGVkTXV0YXRlU3RyZWFtRGF0YSIsInByZXZpb3VzTWVzc2FnZXMiLCJjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCIsIm1hcCIsImV4cGVyaW1lbnRhbF9hdHRhY2htZW50cyIsImFubm90YXRpb25zIiwiZXhpc3RpbmdEYXRhIiwicmVxdWVzdERhdGEiLCJyZXF1ZXN0Qm9keSIsInJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSIsIm9uVXBkYXRlIiwicmVwbGFjZUxhc3RNZXNzYWdlIiwiZXJyIiwibmFtZSIsIm9yaWdpbmFsTWF4VG9vbEludm9jYXRpb25TdGVwIiwib3JpZ2luYWxNZXNzYWdlQ291bnQiLCJoZWFkZXJzMiIsImJvZHkyIiwiYXR0YWNobWVudHNGb3JSZXF1ZXN0IiwiY29uY2F0IiwiY3JlYXRlZEF0IiwiRGF0ZSIsInJlbG9hZCIsIm1lc3NhZ2VzV2l0aFBhcnRzIiwic2V0RGF0YSIsImhhbmRsZVN1Ym1pdCIsIm9wdGlvbnMiLCJtZXRhZGF0YSIsImFsbG93RW1wdHlTdWJtaXQiLCJ0eXBlIiwiZSIsImFkZFRvb2xSZXN1bHQiLCJ0b29sQ2FsbElkIiwicmVzdWx0IiwiY3VycmVudE1lc3NhZ2VzIiwidG9vbFJlc3VsdCIsImlzTG9hZGluZyIsImNhbGxDb21wbGV0aW9uQXBpIiwidXNlQ2FsbGJhY2szIiwidXNlRWZmZWN0MiIsInVzZUlkIiwidXNlUmVmMyIsInVzZVN0YXRlMyIsInVzZVNXUjIiLCJ1c2VDb21wbGV0aW9uIiwiaW5pdGlhbENvbXBsZXRpb24iLCJjb21wbGV0aW9uSWQiLCJtdXRhdGVMb2FkaW5nIiwiY29tcGxldGlvbiIsInNldEFib3J0Q29udHJvbGxlciIsInByb21wdCIsInNldENvbXBsZXRpb24iLCJjb21wbGV0aW9uMiIsIm9uRGF0YSIsImRhdGEyIiwic2V0TG9hZGluZyIsImNvbXBsZXRlIiwiaXNBYm9ydEVycm9yMiIsInNhZmVWYWxpZGF0ZVR5cGVzIiwiYXNTY2hlbWEiLCJpc0RlZXBFcXVhbERhdGEiLCJwYXJzZVBhcnRpYWxKc29uIiwidXNlQ2FsbGJhY2s0IiwidXNlSWQyIiwidXNlUmVmNCIsInVzZVN0YXRlNCIsInVzZVNXUjMiLCJnZXRPcmlnaW5hbEZldGNoMiIsInVzZU9iamVjdCIsInNjaGVtYSIsImluaXRpYWxWYWx1ZSIsInNldElzTG9hZGluZyIsImlnbm9yZWQiLCJzdWJtaXQiLCJhY2N1bXVsYXRlZFRleHQiLCJsYXRlc3RPYmplY3QiLCJwaXBlVGhyb3VnaCIsIlRleHREZWNvZGVyU3RyZWFtIiwicGlwZVRvIiwiV3JpdGFibGVTdHJlYW0iLCJ3cml0ZSIsImNodW5rIiwiY3VycmVudE9iamVjdCIsImNsb3NlIiwidmFsaWRhdGlvblJlc3VsdCIsInN1Y2Nlc3MiLCJvYmplY3QiLCJTdHJpbmciLCJleHBlcmltZW50YWxfdXNlT2JqZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/react/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@ai-sdk/ui-utils/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asSchema: () => (/* binding */ asSchema),\n/* harmony export */   callChatApi: () => (/* binding */ callChatApi),\n/* harmony export */   callCompletionApi: () => (/* binding */ callCompletionApi),\n/* harmony export */   extractMaxToolInvocationStep: () => (/* binding */ extractMaxToolInvocationStep),\n/* harmony export */   fillMessageParts: () => (/* binding */ fillMessageParts),\n/* harmony export */   formatAssistantStreamPart: () => (/* binding */ formatAssistantStreamPart),\n/* harmony export */   formatDataStreamPart: () => (/* binding */ formatDataStreamPart),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId),\n/* harmony export */   getMessageParts: () => (/* binding */ getMessageParts),\n/* harmony export */   getTextFromDataUrl: () => (/* binding */ getTextFromDataUrl),\n/* harmony export */   isAssistantMessageWithCompletedToolCalls: () => (/* binding */ isAssistantMessageWithCompletedToolCalls),\n/* harmony export */   isDeepEqualData: () => (/* binding */ isDeepEqualData),\n/* harmony export */   jsonSchema: () => (/* binding */ jsonSchema),\n/* harmony export */   parseAssistantStreamPart: () => (/* binding */ parseAssistantStreamPart),\n/* harmony export */   parseDataStreamPart: () => (/* binding */ parseDataStreamPart),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson),\n/* harmony export */   prepareAttachmentsForRequest: () => (/* binding */ prepareAttachmentsForRequest),\n/* harmony export */   processAssistantStream: () => (/* binding */ processAssistantStream),\n/* harmony export */   processDataStream: () => (/* binding */ processDataStream),\n/* harmony export */   processTextStream: () => (/* binding */ processTextStream),\n/* harmony export */   shouldResubmitMessages: () => (/* binding */ shouldResubmitMessages),\n/* harmony export */   updateToolCallResult: () => (/* binding */ updateToolCallResult),\n/* harmony export */   zodSchema: () => (/* binding */ zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(ssr)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod-to-json-schema */ \"(ssr)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n// src/index.ts\n\n// src/assistant-stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar assistantStreamParts = [\n    textStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart\n];\nvar assistantStreamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code\n};\nvar validCodes = assistantStreamParts.map((part)=>part.code);\nvar parseAssistantStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return assistantStreamPartsByCode[code].parse(jsonValue);\n};\nfunction formatAssistantStreamPart(type, value) {\n    const streamPart = assistantStreamParts.find((part)=>part.name === type);\n    if (!streamPart) {\n        throw new Error(`Invalid stream part type: ${type}`);\n    }\n    return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n// src/process-chat-response.ts\n\n// src/duplicated/usage.ts\nfunction calculateLanguageModelUsage({ promptTokens, completionTokens }) {\n    return {\n        promptTokens,\n        completionTokens,\n        totalTokens: promptTokens + completionTokens\n    };\n}\n// src/parse-partial-json.ts\n\n// src/fix-json.ts\nfunction fixJson(input) {\n    const stack = [\n        \"ROOT\"\n    ];\n    let lastValidIndex = -1;\n    let literalStart = null;\n    function processValueStart(char, i, swapState) {\n        {\n            switch(char){\n                case '\"':\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_STRING\");\n                        break;\n                    }\n                case \"f\":\n                case \"t\":\n                case \"n\":\n                    {\n                        lastValidIndex = i;\n                        literalStart = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_LITERAL\");\n                        break;\n                    }\n                case \"-\":\n                    {\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_NUMBER\");\n                        break;\n                    }\n                case \"0\":\n                case \"1\":\n                case \"2\":\n                case \"3\":\n                case \"4\":\n                case \"5\":\n                case \"6\":\n                case \"7\":\n                case \"8\":\n                case \"9\":\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_NUMBER\");\n                        break;\n                    }\n                case \"{\":\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_OBJECT_START\");\n                        break;\n                    }\n                case \"[\":\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_ARRAY_START\");\n                        break;\n                    }\n            }\n        }\n    }\n    function processAfterObjectValue(char, i) {\n        switch(char){\n            case \",\":\n                {\n                    stack.pop();\n                    stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n                    break;\n                }\n            case \"}\":\n                {\n                    lastValidIndex = i;\n                    stack.pop();\n                    break;\n                }\n        }\n    }\n    function processAfterArrayValue(char, i) {\n        switch(char){\n            case \",\":\n                {\n                    stack.pop();\n                    stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n                    break;\n                }\n            case \"]\":\n                {\n                    lastValidIndex = i;\n                    stack.pop();\n                    break;\n                }\n        }\n    }\n    for(let i = 0; i < input.length; i++){\n        const char = input[i];\n        const currentState = stack[stack.length - 1];\n        switch(currentState){\n            case \"ROOT\":\n                processValueStart(char, i, \"FINISH\");\n                break;\n            case \"INSIDE_OBJECT_START\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_KEY\");\n                                break;\n                            }\n                        case \"}\":\n                            {\n                                lastValidIndex = i;\n                                stack.pop();\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_AFTER_COMMA\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_KEY\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_KEY\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_AFTER_KEY\":\n                {\n                    switch(char){\n                        case \":\":\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_BEFORE_VALUE\":\n                {\n                    processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n                    break;\n                }\n            case \"INSIDE_OBJECT_AFTER_VALUE\":\n                {\n                    processAfterObjectValue(char, i);\n                    break;\n                }\n            case \"INSIDE_STRING\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                lastValidIndex = i;\n                                break;\n                            }\n                        case \"\\\\\":\n                            {\n                                stack.push(\"INSIDE_STRING_ESCAPE\");\n                                break;\n                            }\n                        default:\n                            {\n                                lastValidIndex = i;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_ARRAY_START\":\n                {\n                    switch(char){\n                        case \"]\":\n                            {\n                                lastValidIndex = i;\n                                stack.pop();\n                                break;\n                            }\n                        default:\n                            {\n                                lastValidIndex = i;\n                                processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_ARRAY_AFTER_VALUE\":\n                {\n                    switch(char){\n                        case \",\":\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n                                break;\n                            }\n                        case \"]\":\n                            {\n                                lastValidIndex = i;\n                                stack.pop();\n                                break;\n                            }\n                        default:\n                            {\n                                lastValidIndex = i;\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_ARRAY_AFTER_COMMA\":\n                {\n                    processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n                    break;\n                }\n            case \"INSIDE_STRING_ESCAPE\":\n                {\n                    stack.pop();\n                    lastValidIndex = i;\n                    break;\n                }\n            case \"INSIDE_NUMBER\":\n                {\n                    switch(char){\n                        case \"0\":\n                        case \"1\":\n                        case \"2\":\n                        case \"3\":\n                        case \"4\":\n                        case \"5\":\n                        case \"6\":\n                        case \"7\":\n                        case \"8\":\n                        case \"9\":\n                            {\n                                lastValidIndex = i;\n                                break;\n                            }\n                        case \"e\":\n                        case \"E\":\n                        case \"-\":\n                        case \".\":\n                            {\n                                break;\n                            }\n                        case \",\":\n                            {\n                                stack.pop();\n                                if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                                    processAfterArrayValue(char, i);\n                                }\n                                if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                                    processAfterObjectValue(char, i);\n                                }\n                                break;\n                            }\n                        case \"}\":\n                            {\n                                stack.pop();\n                                if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                                    processAfterObjectValue(char, i);\n                                }\n                                break;\n                            }\n                        case \"]\":\n                            {\n                                stack.pop();\n                                if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                                    processAfterArrayValue(char, i);\n                                }\n                                break;\n                            }\n                        default:\n                            {\n                                stack.pop();\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_LITERAL\":\n                {\n                    const partialLiteral = input.substring(literalStart, i + 1);\n                    if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n                        stack.pop();\n                        if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                            processAfterObjectValue(char, i);\n                        } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                            processAfterArrayValue(char, i);\n                        }\n                    } else {\n                        lastValidIndex = i;\n                    }\n                    break;\n                }\n        }\n    }\n    let result = input.slice(0, lastValidIndex + 1);\n    for(let i = stack.length - 1; i >= 0; i--){\n        const state = stack[i];\n        switch(state){\n            case \"INSIDE_STRING\":\n                {\n                    result += '\"';\n                    break;\n                }\n            case \"INSIDE_OBJECT_KEY\":\n            case \"INSIDE_OBJECT_AFTER_KEY\":\n            case \"INSIDE_OBJECT_AFTER_COMMA\":\n            case \"INSIDE_OBJECT_START\":\n            case \"INSIDE_OBJECT_BEFORE_VALUE\":\n            case \"INSIDE_OBJECT_AFTER_VALUE\":\n                {\n                    result += \"}\";\n                    break;\n                }\n            case \"INSIDE_ARRAY_START\":\n            case \"INSIDE_ARRAY_AFTER_COMMA\":\n            case \"INSIDE_ARRAY_AFTER_VALUE\":\n                {\n                    result += \"]\";\n                    break;\n                }\n            case \"INSIDE_LITERAL\":\n                {\n                    const partialLiteral = input.substring(literalStart, input.length);\n                    if (\"true\".startsWith(partialLiteral)) {\n                        result += \"true\".slice(partialLiteral.length);\n                    } else if (\"false\".startsWith(partialLiteral)) {\n                        result += \"false\".slice(partialLiteral.length);\n                    } else if (\"null\".startsWith(partialLiteral)) {\n                        result += \"null\".slice(partialLiteral.length);\n                    }\n                }\n        }\n    }\n    return result;\n}\n// src/parse-partial-json.ts\nfunction parsePartialJson(jsonText) {\n    if (jsonText === void 0) {\n        return {\n            value: void 0,\n            state: \"undefined-input\"\n        };\n    }\n    let result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)({\n        text: jsonText\n    });\n    if (result.success) {\n        return {\n            value: result.value,\n            state: \"successful-parse\"\n        };\n    }\n    result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)({\n        text: fixJson(jsonText)\n    });\n    if (result.success) {\n        return {\n            value: result.value,\n            state: \"repaired-parse\"\n        };\n    }\n    return {\n        value: void 0,\n        state: \"failed-parse\"\n    };\n}\n// src/data-stream-parts.ts\nvar textStreamPart2 = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart2 = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"9\",\n    name: \"tool_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\") {\n            throw new Error('\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.');\n        }\n        return {\n            type: \"tool_call\",\n            value\n        };\n    }\n};\nvar toolResultStreamPart = {\n    code: \"a\",\n    name: \"tool_result\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"result\" in value)) {\n            throw new Error('\"tool_result\" parts expect an object with a \"toolCallId\" and a \"result\" property.');\n        }\n        return {\n            type: \"tool_result\",\n            value\n        };\n    }\n};\nvar toolCallStreamingStartStreamPart = {\n    code: \"b\",\n    name: \"tool_call_streaming_start\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\") {\n            throw new Error('\"tool_call_streaming_start\" parts expect an object with a \"toolCallId\" and \"toolName\" property.');\n        }\n        return {\n            type: \"tool_call_streaming_start\",\n            value\n        };\n    }\n};\nvar toolCallDeltaStreamPart = {\n    code: \"c\",\n    name: \"tool_call_delta\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"argsTextDelta\" in value) || typeof value.argsTextDelta !== \"string\") {\n            throw new Error('\"tool_call_delta\" parts expect an object with a \"toolCallId\" and \"argsTextDelta\" property.');\n        }\n        return {\n            type: \"tool_call_delta\",\n            value\n        };\n    }\n};\nvar finishMessageStreamPart = {\n    code: \"d\",\n    name: \"finish_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n            throw new Error('\"finish_message\" parts expect an object with a \"finishReason\" property.');\n        }\n        const result = {\n            finishReason: value.finishReason\n        };\n        if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n            result.usage = {\n                promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n                completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n            };\n        }\n        return {\n            type: \"finish_message\",\n            value: result\n        };\n    }\n};\nvar finishStepStreamPart = {\n    code: \"e\",\n    name: \"finish_step\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n            throw new Error('\"finish_step\" parts expect an object with a \"finishReason\" property.');\n        }\n        const result = {\n            finishReason: value.finishReason,\n            isContinued: false\n        };\n        if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n            result.usage = {\n                promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n                completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n            };\n        }\n        if (\"isContinued\" in value && typeof value.isContinued === \"boolean\") {\n            result.isContinued = value.isContinued;\n        }\n        return {\n            type: \"finish_step\",\n            value: result\n        };\n    }\n};\nvar startStepStreamPart = {\n    code: \"f\",\n    name: \"start_step\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"messageId\" in value) || typeof value.messageId !== \"string\") {\n            throw new Error('\"start_step\" parts expect an object with an \"id\" property.');\n        }\n        return {\n            type: \"start_step\",\n            value: {\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar reasoningStreamPart = {\n    code: \"g\",\n    name: \"reasoning\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"reasoning\" parts expect a string value.');\n        }\n        return {\n            type: \"reasoning\",\n            value\n        };\n    }\n};\nvar sourcePart = {\n    code: \"h\",\n    name: \"source\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\") {\n            throw new Error('\"source\" parts expect a Source object.');\n        }\n        return {\n            type: \"source\",\n            value\n        };\n    }\n};\nvar dataStreamParts = [\n    textStreamPart2,\n    dataStreamPart,\n    errorStreamPart2,\n    messageAnnotationsStreamPart,\n    toolCallStreamPart,\n    toolResultStreamPart,\n    toolCallStreamingStartStreamPart,\n    toolCallDeltaStreamPart,\n    finishMessageStreamPart,\n    finishStepStreamPart,\n    startStepStreamPart,\n    reasoningStreamPart,\n    sourcePart\n];\nvar dataStreamPartsByCode = Object.fromEntries(dataStreamParts.map((part)=>[\n        part.code,\n        part\n    ]));\nvar DataStreamStringPrefixes = Object.fromEntries(dataStreamParts.map((part)=>[\n        part.name,\n        part.code\n    ]));\nvar validCodes2 = dataStreamParts.map((part)=>part.code);\nvar parseDataStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes2.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return dataStreamPartsByCode[code].parse(jsonValue);\n};\nfunction formatDataStreamPart(type, value) {\n    const streamPart = dataStreamParts.find((part)=>part.name === type);\n    if (!streamPart) {\n        throw new Error(`Invalid stream part type: ${type}`);\n    }\n    return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n// src/process-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function processDataStream({ stream, onTextPart, onReasoningPart, onSourcePart, onDataPart, onErrorPart, onToolCallStreamingStartPart, onToolCallDeltaPart, onToolCallPart, onToolResultPart, onMessageAnnotationsPart, onFinishMessagePart, onFinishStepPart, onStartStepPart }) {\n    const reader = stream.getReader();\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseDataStreamPart);\n        for (const { type, value: value2 } of streamParts){\n            switch(type){\n                case \"text\":\n                    await (onTextPart == null ? void 0 : onTextPart(value2));\n                    break;\n                case \"reasoning\":\n                    await (onReasoningPart == null ? void 0 : onReasoningPart(value2));\n                    break;\n                case \"source\":\n                    await (onSourcePart == null ? void 0 : onSourcePart(value2));\n                    break;\n                case \"data\":\n                    await (onDataPart == null ? void 0 : onDataPart(value2));\n                    break;\n                case \"error\":\n                    await (onErrorPart == null ? void 0 : onErrorPart(value2));\n                    break;\n                case \"message_annotations\":\n                    await (onMessageAnnotationsPart == null ? void 0 : onMessageAnnotationsPart(value2));\n                    break;\n                case \"tool_call_streaming_start\":\n                    await (onToolCallStreamingStartPart == null ? void 0 : onToolCallStreamingStartPart(value2));\n                    break;\n                case \"tool_call_delta\":\n                    await (onToolCallDeltaPart == null ? void 0 : onToolCallDeltaPart(value2));\n                    break;\n                case \"tool_call\":\n                    await (onToolCallPart == null ? void 0 : onToolCallPart(value2));\n                    break;\n                case \"tool_result\":\n                    await (onToolResultPart == null ? void 0 : onToolResultPart(value2));\n                    break;\n                case \"finish_message\":\n                    await (onFinishMessagePart == null ? void 0 : onFinishMessagePart(value2));\n                    break;\n                case \"finish_step\":\n                    await (onFinishStepPart == null ? void 0 : onFinishStepPart(value2));\n                    break;\n                case \"start_step\":\n                    await (onStartStepPart == null ? void 0 : onStartStepPart(value2));\n                    break;\n                default:\n                    {\n                        const exhaustiveCheck = type;\n                        throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n                    }\n            }\n        }\n    }\n}\n// src/process-chat-response.ts\nasync function processChatResponse({ stream, update, onToolCall, onFinish, generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId, getCurrentDate = ()=>/* @__PURE__ */ new Date(), lastMessage }) {\n    var _a, _b;\n    const replaceLastMessage = (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\";\n    let step = replaceLastMessage ? 1 + // find max step in existing tool invocations:\n    ((_b = (_a = lastMessage.toolInvocations) == null ? void 0 : _a.reduce((max, toolInvocation)=>{\n        var _a2;\n        return Math.max(max, (_a2 = toolInvocation.step) != null ? _a2 : 0);\n    }, 0)) != null ? _b : 0) : 0;\n    const message = replaceLastMessage ? structuredClone(lastMessage) : {\n        id: generateId2(),\n        createdAt: getCurrentDate(),\n        role: \"assistant\",\n        content: \"\",\n        parts: []\n    };\n    let currentTextPart = void 0;\n    let currentReasoningPart = void 0;\n    function updateToolInvocationPart(toolCallId, invocation) {\n        const part = message.parts.find((part2)=>part2.type === \"tool-invocation\" && part2.toolInvocation.toolCallId === toolCallId);\n        if (part != null) {\n            part.toolInvocation = invocation;\n        } else {\n            message.parts.push({\n                type: \"tool-invocation\",\n                toolInvocation: invocation\n            });\n        }\n    }\n    const data = [];\n    let messageAnnotations = replaceLastMessage ? lastMessage == null ? void 0 : lastMessage.annotations : void 0;\n    const partialToolCalls = {};\n    let usage = {\n        completionTokens: NaN,\n        promptTokens: NaN,\n        totalTokens: NaN\n    };\n    let finishReason = \"unknown\";\n    function execUpdate() {\n        const copiedData = [\n            ...data\n        ];\n        if (messageAnnotations == null ? void 0 : messageAnnotations.length) {\n            message.annotations = messageAnnotations;\n        }\n        const copiedMessage = {\n            // deep copy the message to ensure that deep changes (msg attachments) are updated\n            // with SolidJS. SolidJS uses referential integration of sub-objects to detect changes.\n            ...structuredClone(message),\n            // add a revision id to ensure that the message is updated with SWR. SWR uses a\n            // hashing approach by default to detect changes, but it only works for shallow\n            // changes. This is why we need to add a revision id to ensure that the message\n            // is updated with SWR (without it, the changes get stuck in SWR and are not\n            // forwarded to rendering):\n            revisionId: generateId2()\n        };\n        update({\n            message: copiedMessage,\n            data: copiedData,\n            replaceLastMessage\n        });\n    }\n    await processDataStream({\n        stream,\n        onTextPart (value) {\n            if (currentTextPart == null) {\n                currentTextPart = {\n                    type: \"text\",\n                    text: value\n                };\n                message.parts.push(currentTextPart);\n            } else {\n                currentTextPart.text += value;\n            }\n            message.content += value;\n            execUpdate();\n        },\n        onReasoningPart (value) {\n            var _a2;\n            if (currentReasoningPart == null) {\n                currentReasoningPart = {\n                    type: \"reasoning\",\n                    reasoning: value\n                };\n                message.parts.push(currentReasoningPart);\n            } else {\n                currentReasoningPart.reasoning += value;\n            }\n            message.reasoning = ((_a2 = message.reasoning) != null ? _a2 : \"\") + value;\n            execUpdate();\n        },\n        onSourcePart (value) {\n            message.parts.push({\n                type: \"source\",\n                source: value\n            });\n            execUpdate();\n        },\n        onToolCallStreamingStartPart (value) {\n            if (message.toolInvocations == null) {\n                message.toolInvocations = [];\n            }\n            partialToolCalls[value.toolCallId] = {\n                text: \"\",\n                step,\n                toolName: value.toolName,\n                index: message.toolInvocations.length\n            };\n            const invocation = {\n                state: \"partial-call\",\n                step,\n                toolCallId: value.toolCallId,\n                toolName: value.toolName,\n                args: void 0\n            };\n            message.toolInvocations.push(invocation);\n            updateToolInvocationPart(value.toolCallId, invocation);\n            execUpdate();\n        },\n        onToolCallDeltaPart (value) {\n            const partialToolCall = partialToolCalls[value.toolCallId];\n            partialToolCall.text += value.argsTextDelta;\n            const { value: partialArgs } = parsePartialJson(partialToolCall.text);\n            const invocation = {\n                state: \"partial-call\",\n                step: partialToolCall.step,\n                toolCallId: value.toolCallId,\n                toolName: partialToolCall.toolName,\n                args: partialArgs\n            };\n            message.toolInvocations[partialToolCall.index] = invocation;\n            updateToolInvocationPart(value.toolCallId, invocation);\n            execUpdate();\n        },\n        async onToolCallPart (value) {\n            const invocation = {\n                state: \"call\",\n                step,\n                ...value\n            };\n            if (partialToolCalls[value.toolCallId] != null) {\n                message.toolInvocations[partialToolCalls[value.toolCallId].index] = invocation;\n            } else {\n                if (message.toolInvocations == null) {\n                    message.toolInvocations = [];\n                }\n                message.toolInvocations.push(invocation);\n            }\n            updateToolInvocationPart(value.toolCallId, invocation);\n            execUpdate();\n            if (onToolCall) {\n                const result = await onToolCall({\n                    toolCall: value\n                });\n                if (result != null) {\n                    const invocation2 = {\n                        state: \"result\",\n                        step,\n                        ...value,\n                        result\n                    };\n                    message.toolInvocations[message.toolInvocations.length - 1] = invocation2;\n                    updateToolInvocationPart(value.toolCallId, invocation2);\n                    execUpdate();\n                }\n            }\n        },\n        onToolResultPart (value) {\n            const toolInvocations = message.toolInvocations;\n            if (toolInvocations == null) {\n                throw new Error(\"tool_result must be preceded by a tool_call\");\n            }\n            const toolInvocationIndex = toolInvocations.findIndex((invocation2)=>invocation2.toolCallId === value.toolCallId);\n            if (toolInvocationIndex === -1) {\n                throw new Error(\"tool_result must be preceded by a tool_call with the same toolCallId\");\n            }\n            const invocation = {\n                ...toolInvocations[toolInvocationIndex],\n                state: \"result\",\n                ...value\n            };\n            toolInvocations[toolInvocationIndex] = invocation;\n            updateToolInvocationPart(value.toolCallId, invocation);\n            execUpdate();\n        },\n        onDataPart (value) {\n            data.push(...value);\n            execUpdate();\n        },\n        onMessageAnnotationsPart (value) {\n            if (messageAnnotations == null) {\n                messageAnnotations = [\n                    ...value\n                ];\n            } else {\n                messageAnnotations.push(...value);\n            }\n            execUpdate();\n        },\n        onFinishStepPart (value) {\n            step += 1;\n            currentTextPart = value.isContinued ? currentTextPart : void 0;\n            currentReasoningPart = void 0;\n        },\n        onStartStepPart (value) {\n            if (!replaceLastMessage) {\n                message.id = value.messageId;\n            }\n        },\n        onFinishMessagePart (value) {\n            finishReason = value.finishReason;\n            if (value.usage != null) {\n                usage = calculateLanguageModelUsage(value.usage);\n            }\n        },\n        onErrorPart (error) {\n            throw new Error(error);\n        }\n    });\n    onFinish == null ? void 0 : onFinish({\n        message,\n        finishReason,\n        usage\n    });\n}\n// src/process-chat-text-response.ts\n\n// src/process-text-stream.ts\nasync function processTextStream({ stream, onTextPart }) {\n    const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n    while(true){\n        const { done, value } = await reader.read();\n        if (done) {\n            break;\n        }\n        await onTextPart(value);\n    }\n}\n// src/process-chat-text-response.ts\nasync function processChatTextResponse({ stream, update, onFinish, getCurrentDate = ()=>/* @__PURE__ */ new Date(), generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId }) {\n    const textPart = {\n        type: \"text\",\n        text: \"\"\n    };\n    const resultMessage = {\n        id: generateId2(),\n        createdAt: getCurrentDate(),\n        role: \"assistant\",\n        content: \"\",\n        parts: [\n            textPart\n        ]\n    };\n    await processTextStream({\n        stream,\n        onTextPart: (chunk)=>{\n            resultMessage.content += chunk;\n            textPart.text += chunk;\n            update({\n                message: {\n                    ...resultMessage\n                },\n                data: [],\n                replaceLastMessage: false\n            });\n        }\n    });\n    onFinish == null ? void 0 : onFinish(resultMessage, {\n        usage: {\n            completionTokens: NaN,\n            promptTokens: NaN,\n            totalTokens: NaN\n        },\n        finishReason: \"unknown\"\n    });\n}\n// src/call-chat-api.ts\nvar getOriginalFetch = ()=>fetch;\nasync function callChatApi({ api, body, streamProtocol = \"data\", credentials, headers, abortController, restoreMessagesOnFailure, onResponse, onUpdate, onFinish, onToolCall, generateId: generateId2, fetch: fetch2 = getOriginalFetch(), lastMessage }) {\n    var _a, _b;\n    const response = await fetch2(api, {\n        method: \"POST\",\n        body: JSON.stringify(body),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error((_b = await response.text()) != null ? _b : \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    switch(streamProtocol){\n        case \"text\":\n            {\n                await processChatTextResponse({\n                    stream: response.body,\n                    update: onUpdate,\n                    onFinish,\n                    generateId: generateId2\n                });\n                return;\n            }\n        case \"data\":\n            {\n                await processChatResponse({\n                    stream: response.body,\n                    update: onUpdate,\n                    lastMessage,\n                    onToolCall,\n                    onFinish ({ message, finishReason, usage }) {\n                        if (onFinish && message != null) {\n                            onFinish(message, {\n                                usage,\n                                finishReason\n                            });\n                        }\n                    },\n                    generateId: generateId2\n                });\n                return;\n            }\n        default:\n            {\n                const exhaustiveCheck = streamProtocol;\n                throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n            }\n    }\n}\n// src/call-completion-api.ts\nvar getOriginalFetch2 = ()=>fetch;\nasync function callCompletionApi({ api, prompt, credentials, headers, body, streamProtocol = \"data\", setCompletion, setLoading, setError, setAbortController, onResponse, onFinish, onError, onData, fetch: fetch2 = getOriginalFetch2() }) {\n    var _a;\n    try {\n        setLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        setAbortController(abortController);\n        setCompletion(\"\");\n        const response = await fetch2(api, {\n            method: \"POST\",\n            body: JSON.stringify({\n                prompt,\n                ...body\n            }),\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            signal: abortController.signal\n        }).catch((err)=>{\n            throw err;\n        });\n        if (onResponse) {\n            try {\n                await onResponse(response);\n            } catch (err) {\n                throw err;\n            }\n        }\n        if (!response.ok) {\n            throw new Error((_a = await response.text()) != null ? _a : \"Failed to fetch the chat response.\");\n        }\n        if (!response.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        switch(streamProtocol){\n            case \"text\":\n                {\n                    await processTextStream({\n                        stream: response.body,\n                        onTextPart: (chunk)=>{\n                            result += chunk;\n                            setCompletion(result);\n                        }\n                    });\n                    break;\n                }\n            case \"data\":\n                {\n                    await processDataStream({\n                        stream: response.body,\n                        onTextPart (value) {\n                            result += value;\n                            setCompletion(result);\n                        },\n                        onDataPart (value) {\n                            onData == null ? void 0 : onData(value);\n                        },\n                        onErrorPart (value) {\n                            throw new Error(value);\n                        }\n                    });\n                    break;\n                }\n            default:\n                {\n                    const exhaustiveCheck = streamProtocol;\n                    throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n                }\n        }\n        if (onFinish) {\n            onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n    } catch (err) {\n        if (err.name === \"AbortError\") {\n            setAbortController(null);\n            return null;\n        }\n        if (err instanceof Error) {\n            if (onError) {\n                onError(err);\n            }\n        }\n        setError(err);\n    } finally{\n        setLoading(false);\n    }\n}\n// src/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n    const [header, base64Content] = dataUrl.split(\",\");\n    const mimeType = header.split(\";\")[0].split(\":\")[1];\n    if (mimeType == null || base64Content == null) {\n        throw new Error(\"Invalid data URL format\");\n    }\n    try {\n        return window.atob(base64Content);\n    } catch (error) {\n        throw new Error(`Error decoding data URL`);\n    }\n}\n// src/extract-max-tool-invocation-step.ts\nfunction extractMaxToolInvocationStep(toolInvocations) {\n    return toolInvocations == null ? void 0 : toolInvocations.reduce((max, toolInvocation)=>{\n        var _a;\n        return Math.max(max, (_a = toolInvocation.step) != null ? _a : 0);\n    }, 0);\n}\n// src/get-message-parts.ts\nfunction getMessageParts(message) {\n    var _a;\n    return (_a = message.parts) != null ? _a : [\n        ...message.toolInvocations ? message.toolInvocations.map((toolInvocation)=>({\n                type: \"tool-invocation\",\n                toolInvocation\n            })) : [],\n        ...message.reasoning ? [\n            {\n                type: \"reasoning\",\n                reasoning: message.reasoning\n            }\n        ] : [],\n        ...message.content ? [\n            {\n                type: \"text\",\n                text: message.content\n            }\n        ] : []\n    ];\n}\n// src/fill-message-parts.ts\nfunction fillMessageParts(messages) {\n    return messages.map((message)=>({\n            ...message,\n            parts: getMessageParts(message)\n        }));\n}\n// src/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n    if (obj1 === obj2) return true;\n    if (obj1 == null || obj2 == null) return false;\n    if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\") return obj1 === obj2;\n    if (obj1.constructor !== obj2.constructor) return false;\n    if (obj1 instanceof Date && obj2 instanceof Date) {\n        return obj1.getTime() === obj2.getTime();\n    }\n    if (Array.isArray(obj1)) {\n        if (obj1.length !== obj2.length) return false;\n        for(let i = 0; i < obj1.length; i++){\n            if (!isDeepEqualData(obj1[i], obj2[i])) return false;\n        }\n        return true;\n    }\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    for (const key of keys1){\n        if (!keys2.includes(key)) return false;\n        if (!isDeepEqualData(obj1[key], obj2[key])) return false;\n    }\n    return true;\n}\n// src/prepare-attachments-for-request.ts\nasync function prepareAttachmentsForRequest(attachmentsFromOptions) {\n    if (!attachmentsFromOptions) {\n        return [];\n    }\n    if (attachmentsFromOptions instanceof FileList) {\n        return Promise.all(Array.from(attachmentsFromOptions).map(async (attachment)=>{\n            const { name, type } = attachment;\n            const dataUrl = await new Promise((resolve, reject)=>{\n                const reader = new FileReader();\n                reader.onload = (readerEvent)=>{\n                    var _a;\n                    resolve((_a = readerEvent.target) == null ? void 0 : _a.result);\n                };\n                reader.onerror = (error)=>reject(error);\n                reader.readAsDataURL(attachment);\n            });\n            return {\n                name,\n                contentType: type,\n                url: dataUrl\n            };\n        }));\n    }\n    if (Array.isArray(attachmentsFromOptions)) {\n        return attachmentsFromOptions;\n    }\n    throw new Error(\"Invalid attachments type\");\n}\n// src/process-assistant-stream.ts\nvar NEWLINE2 = \"\\n\".charCodeAt(0);\nfunction concatChunks2(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function processAssistantStream({ stream, onTextPart, onErrorPart, onAssistantMessagePart, onAssistantControlDataPart, onDataMessagePart }) {\n    const reader = stream.getReader();\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE2) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks2(chunks, totalLength);\n        totalLength = 0;\n        const streamParts = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseAssistantStreamPart);\n        for (const { type, value: value2 } of streamParts){\n            switch(type){\n                case \"text\":\n                    await (onTextPart == null ? void 0 : onTextPart(value2));\n                    break;\n                case \"error\":\n                    await (onErrorPart == null ? void 0 : onErrorPart(value2));\n                    break;\n                case \"assistant_message\":\n                    await (onAssistantMessagePart == null ? void 0 : onAssistantMessagePart(value2));\n                    break;\n                case \"assistant_control_data\":\n                    await (onAssistantControlDataPart == null ? void 0 : onAssistantControlDataPart(value2));\n                    break;\n                case \"data_message\":\n                    await (onDataMessagePart == null ? void 0 : onDataMessagePart(value2));\n                    break;\n                default:\n                    {\n                        const exhaustiveCheck = type;\n                        throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n                    }\n            }\n        }\n    }\n}\n// src/schema.ts\n\n// src/zod-schema.ts\n\nfunction zodSchema(zodSchema2, options) {\n    var _a;\n    const useReferences = (_a = options == null ? void 0 : options.useReferences) != null ? _a : false;\n    return jsonSchema((0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(zodSchema2, {\n        $refStrategy: useReferences ? \"root\" : \"none\",\n        target: \"jsonSchema7\"\n    }), {\n        validate: (value)=>{\n            const result = zodSchema2.safeParse(value);\n            return result.success ? {\n                success: true,\n                value: result.data\n            } : {\n                success: false,\n                error: result.error\n            };\n        }\n    });\n}\n// src/schema.ts\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nfunction jsonSchema(jsonSchema2, { validate } = {}) {\n    return {\n        [schemaSymbol]: true,\n        _type: void 0,\n        // should never be used directly\n        [_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.validatorSymbol]: true,\n        jsonSchema: jsonSchema2,\n        validate\n    };\n}\nfunction isSchema(value) {\n    return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n    return isSchema(schema) ? schema : zodSchema(schema);\n}\n// src/should-resubmit-messages.ts\nfunction shouldResubmitMessages({ originalMaxToolInvocationStep, originalMessageCount, maxSteps, messages }) {\n    var _a;\n    const lastMessage = messages[messages.length - 1];\n    return(// check if the feature is enabled:\n    maxSteps > 1 && // ensure there is a last message:\n    lastMessage != null && // ensure we actually have new steps (to prevent infinite loops in case of errors):\n    (messages.length > originalMessageCount || extractMaxToolInvocationStep(lastMessage.toolInvocations) !== originalMaxToolInvocationStep) && // check that next step is possible:\n    isAssistantMessageWithCompletedToolCalls(lastMessage) && // check that assistant has not answered yet:\n    !isLastToolInvocationFollowedByText(lastMessage) && // limit the number of automatic steps:\n    ((_a = extractMaxToolInvocationStep(lastMessage.toolInvocations)) != null ? _a : 0) < maxSteps);\n}\nfunction isLastToolInvocationFollowedByText(message) {\n    let isLastToolInvocationFollowedByText2 = false;\n    message.parts.forEach((part)=>{\n        if (part.type === \"text\") {\n            isLastToolInvocationFollowedByText2 = true;\n        }\n        if (part.type === \"tool-invocation\") {\n            isLastToolInvocationFollowedByText2 = false;\n        }\n    });\n    return isLastToolInvocationFollowedByText2;\n}\nfunction isAssistantMessageWithCompletedToolCalls(message) {\n    return message.role === \"assistant\" && message.parts.filter((part)=>part.type === \"tool-invocation\").every((part)=>\"result\" in part.toolInvocation);\n}\n// src/update-tool-call-result.ts\nfunction updateToolCallResult({ messages, toolCallId, toolResult: result }) {\n    var _a;\n    const lastMessage = messages[messages.length - 1];\n    const invocationPart = lastMessage.parts.find((part)=>part.type === \"tool-invocation\" && part.toolInvocation.toolCallId === toolCallId);\n    if (invocationPart == null) {\n        return;\n    }\n    const toolResult = {\n        ...invocationPart.toolInvocation,\n        state: \"result\",\n        result\n    };\n    invocationPart.toolInvocation = toolResult;\n    lastMessage.toolInvocations = (_a = lastMessage.toolInvocations) == null ? void 0 : _a.map((toolInvocation)=>toolInvocation.toolCallId === toolCallId ? toolResult : toolInvocation);\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay91aS11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsZUFBZTtBQUNxQztBQUVwRCxnQ0FBZ0M7QUFDaEMsSUFBSUMsaUJBQWlCO0lBQ25CQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzdCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRUMsTUFBTTtZQUFRRjtRQUFNO0lBQy9CO0FBQ0Y7QUFDQSxJQUFJRyxrQkFBa0I7SUFDcEJOLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBQ0EsT0FBTztZQUFFQyxNQUFNO1lBQVNGO1FBQU07SUFDaEM7QUFDRjtBQUNBLElBQUlJLDZCQUE2QjtJQUMvQlAsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsU0FBUUEsS0FBSSxLQUFNLENBQUUsV0FBVUEsS0FBSSxLQUFNLENBQUUsY0FBYUEsS0FBSSxLQUFNLE9BQU9BLE1BQU1LLEVBQUUsS0FBSyxZQUFZLE9BQU9MLE1BQU1NLElBQUksS0FBSyxZQUFZTixNQUFNTSxJQUFJLEtBQUssZUFBZSxDQUFDQyxNQUFNQyxPQUFPLENBQUNSLE1BQU1TLE9BQU8sS0FBSyxDQUFDVCxNQUFNUyxPQUFPLENBQUNDLEtBQUssQ0FDeFEsQ0FBQ0MsT0FBU0EsUUFBUSxRQUFRLE9BQU9BLFNBQVMsWUFBWSxVQUFVQSxRQUFRQSxLQUFLVCxJQUFJLEtBQUssVUFBVSxVQUFVUyxRQUFRQSxLQUFLQyxJQUFJLElBQUksUUFBUSxPQUFPRCxLQUFLQyxJQUFJLEtBQUssWUFBWSxXQUFXRCxLQUFLQyxJQUFJLElBQUksT0FBT0QsS0FBS0MsSUFBSSxDQUFDWixLQUFLLEtBQUssV0FDMU47WUFDRCxNQUFNLElBQUlDLE1BQ1I7UUFFSjtRQUNBLE9BQU87WUFDTEMsTUFBTTtZQUNORjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLElBQUlhLGlDQUFpQztJQUNuQ2hCLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSUEsU0FBUyxRQUFRLE9BQU9BLFVBQVUsWUFBWSxDQUFFLGVBQWNBLEtBQUksS0FBTSxDQUFFLGdCQUFlQSxLQUFJLEtBQU0sT0FBT0EsTUFBTWMsUUFBUSxLQUFLLFlBQVksT0FBT2QsTUFBTWUsU0FBUyxLQUFLLFVBQVU7WUFDaEwsTUFBTSxJQUFJZCxNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTkYsT0FBTztnQkFDTGMsVUFBVWQsTUFBTWMsUUFBUTtnQkFDeEJDLFdBQVdmLE1BQU1lLFNBQVM7WUFDNUI7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJQyx3QkFBd0I7SUFDMUJuQixNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUlBLFNBQVMsUUFBUSxPQUFPQSxVQUFVLFlBQVksQ0FBRSxXQUFVQSxLQUFJLEtBQU0sQ0FBRSxXQUFVQSxLQUFJLEtBQU0sT0FBT0EsTUFBTU0sSUFBSSxLQUFLLFlBQVlOLE1BQU1NLElBQUksS0FBSyxRQUFRO1lBQ3JKLE1BQU0sSUFBSUwsTUFDUjtRQUVKO1FBQ0EsT0FBTztZQUNMQyxNQUFNO1lBQ05GO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSWlCLHVCQUF1QjtJQUN6QnJCO0lBQ0FPO0lBQ0FDO0lBQ0FTO0lBQ0FHO0NBQ0Q7QUFDRCxJQUFJRSw2QkFBNkI7SUFDL0IsQ0FBQ3RCLGVBQWVDLElBQUksQ0FBQyxFQUFFRDtJQUN2QixDQUFDTyxnQkFBZ0JOLElBQUksQ0FBQyxFQUFFTTtJQUN4QixDQUFDQywyQkFBMkJQLElBQUksQ0FBQyxFQUFFTztJQUNuQyxDQUFDUywrQkFBK0JoQixJQUFJLENBQUMsRUFBRWdCO0lBQ3ZDLENBQUNHLHNCQUFzQm5CLElBQUksQ0FBQyxFQUFFbUI7QUFDaEM7QUFDQSxJQUFJRyx1QkFBdUI7SUFDekIsQ0FBQ3ZCLGVBQWVFLElBQUksQ0FBQyxFQUFFRixlQUFlQyxJQUFJO0lBQzFDLENBQUNNLGdCQUFnQkwsSUFBSSxDQUFDLEVBQUVLLGdCQUFnQk4sSUFBSTtJQUM1QyxDQUFDTywyQkFBMkJOLElBQUksQ0FBQyxFQUFFTSwyQkFBMkJQLElBQUk7SUFDbEUsQ0FBQ2dCLCtCQUErQmYsSUFBSSxDQUFDLEVBQUVlLCtCQUErQmhCLElBQUk7SUFDMUUsQ0FBQ21CLHNCQUFzQmxCLElBQUksQ0FBQyxFQUFFa0Isc0JBQXNCbkIsSUFBSTtBQUMxRDtBQUNBLElBQUl1QixhQUFhSCxxQkFBcUJJLEdBQUcsQ0FBQyxDQUFDQyxPQUFTQSxLQUFLekIsSUFBSTtBQUM3RCxJQUFJMEIsMkJBQTJCLENBQUNDO0lBQzlCLE1BQU1DLHNCQUFzQkQsS0FBS0UsT0FBTyxDQUFDO0lBQ3pDLElBQUlELHdCQUF3QixDQUFDLEdBQUc7UUFDOUIsTUFBTSxJQUFJeEIsTUFBTTtJQUNsQjtJQUNBLE1BQU0wQixTQUFTSCxLQUFLSSxLQUFLLENBQUMsR0FBR0g7SUFDN0IsSUFBSSxDQUFDTCxXQUFXUyxRQUFRLENBQUNGLFNBQVM7UUFDaEMsTUFBTSxJQUFJMUIsTUFBTSxDQUFDLDRDQUE0QyxFQUFFMEIsT0FBTyxDQUFDLENBQUM7SUFDMUU7SUFDQSxNQUFNOUIsT0FBTzhCO0lBQ2IsTUFBTUcsWUFBWU4sS0FBS0ksS0FBSyxDQUFDSCxzQkFBc0I7SUFDbkQsTUFBTU0sWUFBWUMsS0FBS2pDLEtBQUssQ0FBQytCO0lBQzdCLE9BQU9aLDBCQUEwQixDQUFDckIsS0FBSyxDQUFDRSxLQUFLLENBQUNnQztBQUNoRDtBQUNBLFNBQVNFLDBCQUEwQi9CLElBQUksRUFBRUYsS0FBSztJQUM1QyxNQUFNa0MsYUFBYWpCLHFCQUFxQmtCLElBQUksQ0FBQyxDQUFDYixPQUFTQSxLQUFLeEIsSUFBSSxLQUFLSTtJQUNyRSxJQUFJLENBQUNnQyxZQUFZO1FBQ2YsTUFBTSxJQUFJakMsTUFBTSxDQUFDLDBCQUEwQixFQUFFQyxLQUFLLENBQUM7SUFDckQ7SUFDQSxPQUFPLENBQUMsRUFBRWdDLFdBQVdyQyxJQUFJLENBQUMsQ0FBQyxFQUFFbUMsS0FBS0ksU0FBUyxDQUFDcEMsT0FBTztBQUNyRCxDQUFDO0FBQ0Q7QUFFQSwrQkFBK0I7QUFDMkM7QUFFMUUsMEJBQTBCO0FBQzFCLFNBQVNzQyw0QkFBNEIsRUFDbkNDLFlBQVksRUFDWkMsZ0JBQWdCLEVBQ2pCO0lBQ0MsT0FBTztRQUNMRDtRQUNBQztRQUNBQyxhQUFhRixlQUFlQztJQUM5QjtBQUNGO0FBRUEsNEJBQTRCO0FBQzJCO0FBRXZELGtCQUFrQjtBQUNsQixTQUFTRyxRQUFRQyxLQUFLO0lBQ3BCLE1BQU1DLFFBQVE7UUFBQztLQUFPO0lBQ3RCLElBQUlDLGlCQUFpQixDQUFDO0lBQ3RCLElBQUlDLGVBQWU7SUFDbkIsU0FBU0Msa0JBQWtCQyxJQUFJLEVBQUVDLENBQUMsRUFBRUMsU0FBUztRQUMzQztZQUNFLE9BQVFGO2dCQUNOLEtBQUs7b0JBQUs7d0JBQ1JILGlCQUFpQkk7d0JBQ2pCTCxNQUFNTyxHQUFHO3dCQUNUUCxNQUFNUSxJQUFJLENBQUNGO3dCQUNYTixNQUFNUSxJQUFJLENBQUM7d0JBQ1g7b0JBQ0Y7Z0JBQ0EsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7b0JBQUs7d0JBQ1JQLGlCQUFpQkk7d0JBQ2pCSCxlQUFlRzt3QkFDZkwsTUFBTU8sR0FBRzt3QkFDVFAsTUFBTVEsSUFBSSxDQUFDRjt3QkFDWE4sTUFBTVEsSUFBSSxDQUFDO3dCQUNYO29CQUNGO2dCQUNBLEtBQUs7b0JBQUs7d0JBQ1JSLE1BQU1PLEdBQUc7d0JBQ1RQLE1BQU1RLElBQUksQ0FBQ0Y7d0JBQ1hOLE1BQU1RLElBQUksQ0FBQzt3QkFDWDtvQkFDRjtnQkFDQSxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO29CQUFLO3dCQUNSUCxpQkFBaUJJO3dCQUNqQkwsTUFBTU8sR0FBRzt3QkFDVFAsTUFBTVEsSUFBSSxDQUFDRjt3QkFDWE4sTUFBTVEsSUFBSSxDQUFDO3dCQUNYO29CQUNGO2dCQUNBLEtBQUs7b0JBQUs7d0JBQ1JQLGlCQUFpQkk7d0JBQ2pCTCxNQUFNTyxHQUFHO3dCQUNUUCxNQUFNUSxJQUFJLENBQUNGO3dCQUNYTixNQUFNUSxJQUFJLENBQUM7d0JBQ1g7b0JBQ0Y7Z0JBQ0EsS0FBSztvQkFBSzt3QkFDUlAsaUJBQWlCSTt3QkFDakJMLE1BQU1PLEdBQUc7d0JBQ1RQLE1BQU1RLElBQUksQ0FBQ0Y7d0JBQ1hOLE1BQU1RLElBQUksQ0FBQzt3QkFDWDtvQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLFNBQVNDLHdCQUF3QkwsSUFBSSxFQUFFQyxDQUFDO1FBQ3RDLE9BQVFEO1lBQ04sS0FBSztnQkFBSztvQkFDUkosTUFBTU8sR0FBRztvQkFDVFAsTUFBTVEsSUFBSSxDQUFDO29CQUNYO2dCQUNGO1lBQ0EsS0FBSztnQkFBSztvQkFDUlAsaUJBQWlCSTtvQkFDakJMLE1BQU1PLEdBQUc7b0JBQ1Q7Z0JBQ0Y7UUFDRjtJQUNGO0lBQ0EsU0FBU0csdUJBQXVCTixJQUFJLEVBQUVDLENBQUM7UUFDckMsT0FBUUQ7WUFDTixLQUFLO2dCQUFLO29CQUNSSixNQUFNTyxHQUFHO29CQUNUUCxNQUFNUSxJQUFJLENBQUM7b0JBQ1g7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUFLO29CQUNSUCxpQkFBaUJJO29CQUNqQkwsTUFBTU8sR0FBRztvQkFDVDtnQkFDRjtRQUNGO0lBQ0Y7SUFDQSxJQUFLLElBQUlGLElBQUksR0FBR0EsSUFBSU4sTUFBTVksTUFBTSxFQUFFTixJQUFLO1FBQ3JDLE1BQU1ELE9BQU9MLEtBQUssQ0FBQ00sRUFBRTtRQUNyQixNQUFNTyxlQUFlWixLQUFLLENBQUNBLE1BQU1XLE1BQU0sR0FBRyxFQUFFO1FBQzVDLE9BQVFDO1lBQ04sS0FBSztnQkFDSFQsa0JBQWtCQyxNQUFNQyxHQUFHO2dCQUMzQjtZQUNGLEtBQUs7Z0JBQXVCO29CQUMxQixPQUFRRDt3QkFDTixLQUFLOzRCQUFLO2dDQUNSSixNQUFNTyxHQUFHO2dDQUNUUCxNQUFNUSxJQUFJLENBQUM7Z0NBQ1g7NEJBQ0Y7d0JBQ0EsS0FBSzs0QkFBSztnQ0FDUlAsaUJBQWlCSTtnQ0FDakJMLE1BQU1PLEdBQUc7Z0NBQ1Q7NEJBQ0Y7b0JBQ0Y7b0JBQ0E7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUE2QjtvQkFDaEMsT0FBUUg7d0JBQ04sS0FBSzs0QkFBSztnQ0FDUkosTUFBTU8sR0FBRztnQ0FDVFAsTUFBTVEsSUFBSSxDQUFDO2dDQUNYOzRCQUNGO29CQUNGO29CQUNBO2dCQUNGO1lBQ0EsS0FBSztnQkFBcUI7b0JBQ3hCLE9BQVFKO3dCQUNOLEtBQUs7NEJBQUs7Z0NBQ1JKLE1BQU1PLEdBQUc7Z0NBQ1RQLE1BQU1RLElBQUksQ0FBQztnQ0FDWDs0QkFDRjtvQkFDRjtvQkFDQTtnQkFDRjtZQUNBLEtBQUs7Z0JBQTJCO29CQUM5QixPQUFRSjt3QkFDTixLQUFLOzRCQUFLO2dDQUNSSixNQUFNTyxHQUFHO2dDQUNUUCxNQUFNUSxJQUFJLENBQUM7Z0NBQ1g7NEJBQ0Y7b0JBQ0Y7b0JBQ0E7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUE4QjtvQkFDakNMLGtCQUFrQkMsTUFBTUMsR0FBRztvQkFDM0I7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUE2QjtvQkFDaENJLHdCQUF3QkwsTUFBTUM7b0JBQzlCO2dCQUNGO1lBQ0EsS0FBSztnQkFBaUI7b0JBQ3BCLE9BQVFEO3dCQUNOLEtBQUs7NEJBQUs7Z0NBQ1JKLE1BQU1PLEdBQUc7Z0NBQ1ROLGlCQUFpQkk7Z0NBQ2pCOzRCQUNGO3dCQUNBLEtBQUs7NEJBQU07Z0NBQ1RMLE1BQU1RLElBQUksQ0FBQztnQ0FDWDs0QkFDRjt3QkFDQTs0QkFBUztnQ0FDUFAsaUJBQWlCSTs0QkFDbkI7b0JBQ0Y7b0JBQ0E7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUFzQjtvQkFDekIsT0FBUUQ7d0JBQ04sS0FBSzs0QkFBSztnQ0FDUkgsaUJBQWlCSTtnQ0FDakJMLE1BQU1PLEdBQUc7Z0NBQ1Q7NEJBQ0Y7d0JBQ0E7NEJBQVM7Z0NBQ1BOLGlCQUFpQkk7Z0NBQ2pCRixrQkFBa0JDLE1BQU1DLEdBQUc7Z0NBQzNCOzRCQUNGO29CQUNGO29CQUNBO2dCQUNGO1lBQ0EsS0FBSztnQkFBNEI7b0JBQy9CLE9BQVFEO3dCQUNOLEtBQUs7NEJBQUs7Z0NBQ1JKLE1BQU1PLEdBQUc7Z0NBQ1RQLE1BQU1RLElBQUksQ0FBQztnQ0FDWDs0QkFDRjt3QkFDQSxLQUFLOzRCQUFLO2dDQUNSUCxpQkFBaUJJO2dDQUNqQkwsTUFBTU8sR0FBRztnQ0FDVDs0QkFDRjt3QkFDQTs0QkFBUztnQ0FDUE4saUJBQWlCSTtnQ0FDakI7NEJBQ0Y7b0JBQ0Y7b0JBQ0E7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUE0QjtvQkFDL0JGLGtCQUFrQkMsTUFBTUMsR0FBRztvQkFDM0I7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUF3QjtvQkFDM0JMLE1BQU1PLEdBQUc7b0JBQ1ROLGlCQUFpQkk7b0JBQ2pCO2dCQUNGO1lBQ0EsS0FBSztnQkFBaUI7b0JBQ3BCLE9BQVFEO3dCQUNOLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7NEJBQUs7Z0NBQ1JILGlCQUFpQkk7Z0NBQ2pCOzRCQUNGO3dCQUNBLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7NEJBQUs7Z0NBQ1I7NEJBQ0Y7d0JBQ0EsS0FBSzs0QkFBSztnQ0FDUkwsTUFBTU8sR0FBRztnQ0FDVCxJQUFJUCxLQUFLLENBQUNBLE1BQU1XLE1BQU0sR0FBRyxFQUFFLEtBQUssNEJBQTRCO29DQUMxREQsdUJBQXVCTixNQUFNQztnQ0FDL0I7Z0NBQ0EsSUFBSUwsS0FBSyxDQUFDQSxNQUFNVyxNQUFNLEdBQUcsRUFBRSxLQUFLLDZCQUE2QjtvQ0FDM0RGLHdCQUF3QkwsTUFBTUM7Z0NBQ2hDO2dDQUNBOzRCQUNGO3dCQUNBLEtBQUs7NEJBQUs7Z0NBQ1JMLE1BQU1PLEdBQUc7Z0NBQ1QsSUFBSVAsS0FBSyxDQUFDQSxNQUFNVyxNQUFNLEdBQUcsRUFBRSxLQUFLLDZCQUE2QjtvQ0FDM0RGLHdCQUF3QkwsTUFBTUM7Z0NBQ2hDO2dDQUNBOzRCQUNGO3dCQUNBLEtBQUs7NEJBQUs7Z0NBQ1JMLE1BQU1PLEdBQUc7Z0NBQ1QsSUFBSVAsS0FBSyxDQUFDQSxNQUFNVyxNQUFNLEdBQUcsRUFBRSxLQUFLLDRCQUE0QjtvQ0FDMURELHVCQUF1Qk4sTUFBTUM7Z0NBQy9CO2dDQUNBOzRCQUNGO3dCQUNBOzRCQUFTO2dDQUNQTCxNQUFNTyxHQUFHO2dDQUNUOzRCQUNGO29CQUNGO29CQUNBO2dCQUNGO1lBQ0EsS0FBSztnQkFBa0I7b0JBQ3JCLE1BQU1NLGlCQUFpQmQsTUFBTWUsU0FBUyxDQUFDWixjQUFjRyxJQUFJO29CQUN6RCxJQUFJLENBQUMsUUFBUVUsVUFBVSxDQUFDRixtQkFBbUIsQ0FBQyxPQUFPRSxVQUFVLENBQUNGLG1CQUFtQixDQUFDLE9BQU9FLFVBQVUsQ0FBQ0YsaUJBQWlCO3dCQUNuSGIsTUFBTU8sR0FBRzt3QkFDVCxJQUFJUCxLQUFLLENBQUNBLE1BQU1XLE1BQU0sR0FBRyxFQUFFLEtBQUssNkJBQTZCOzRCQUMzREYsd0JBQXdCTCxNQUFNQzt3QkFDaEMsT0FBTyxJQUFJTCxLQUFLLENBQUNBLE1BQU1XLE1BQU0sR0FBRyxFQUFFLEtBQUssNEJBQTRCOzRCQUNqRUQsdUJBQXVCTixNQUFNQzt3QkFDL0I7b0JBQ0YsT0FBTzt3QkFDTEosaUJBQWlCSTtvQkFDbkI7b0JBQ0E7Z0JBQ0Y7UUFDRjtJQUNGO0lBQ0EsSUFBSVcsU0FBU2pCLE1BQU1oQixLQUFLLENBQUMsR0FBR2tCLGlCQUFpQjtJQUM3QyxJQUFLLElBQUlJLElBQUlMLE1BQU1XLE1BQU0sR0FBRyxHQUFHTixLQUFLLEdBQUdBLElBQUs7UUFDMUMsTUFBTVksUUFBUWpCLEtBQUssQ0FBQ0ssRUFBRTtRQUN0QixPQUFRWTtZQUNOLEtBQUs7Z0JBQWlCO29CQUNwQkQsVUFBVTtvQkFDVjtnQkFDRjtZQUNBLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFBNkI7b0JBQ2hDQSxVQUFVO29CQUNWO2dCQUNGO1lBQ0EsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUE0QjtvQkFDL0JBLFVBQVU7b0JBQ1Y7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUFrQjtvQkFDckIsTUFBTUgsaUJBQWlCZCxNQUFNZSxTQUFTLENBQUNaLGNBQWNILE1BQU1ZLE1BQU07b0JBQ2pFLElBQUksT0FBT0ksVUFBVSxDQUFDRixpQkFBaUI7d0JBQ3JDRyxVQUFVLE9BQU9qQyxLQUFLLENBQUM4QixlQUFlRixNQUFNO29CQUM5QyxPQUFPLElBQUksUUFBUUksVUFBVSxDQUFDRixpQkFBaUI7d0JBQzdDRyxVQUFVLFFBQVFqQyxLQUFLLENBQUM4QixlQUFlRixNQUFNO29CQUMvQyxPQUFPLElBQUksT0FBT0ksVUFBVSxDQUFDRixpQkFBaUI7d0JBQzVDRyxVQUFVLE9BQU9qQyxLQUFLLENBQUM4QixlQUFlRixNQUFNO29CQUM5QztnQkFDRjtRQUNGO0lBQ0Y7SUFDQSxPQUFPSztBQUNUO0FBRUEsNEJBQTRCO0FBQzVCLFNBQVNFLGlCQUFpQkMsUUFBUTtJQUNoQyxJQUFJQSxhQUFhLEtBQUssR0FBRztRQUN2QixPQUFPO1lBQUVoRSxPQUFPLEtBQUs7WUFBRzhELE9BQU87UUFBa0I7SUFDbkQ7SUFDQSxJQUFJRCxTQUFTbkIscUVBQWFBLENBQUM7UUFBRTlCLE1BQU1vRDtJQUFTO0lBQzVDLElBQUlILE9BQU9JLE9BQU8sRUFBRTtRQUNsQixPQUFPO1lBQUVqRSxPQUFPNkQsT0FBTzdELEtBQUs7WUFBRThELE9BQU87UUFBbUI7SUFDMUQ7SUFDQUQsU0FBU25CLHFFQUFhQSxDQUFDO1FBQUU5QixNQUFNK0IsUUFBUXFCO0lBQVU7SUFDakQsSUFBSUgsT0FBT0ksT0FBTyxFQUFFO1FBQ2xCLE9BQU87WUFBRWpFLE9BQU82RCxPQUFPN0QsS0FBSztZQUFFOEQsT0FBTztRQUFpQjtJQUN4RDtJQUNBLE9BQU87UUFBRTlELE9BQU8sS0FBSztRQUFHOEQsT0FBTztJQUFlO0FBQ2hEO0FBRUEsMkJBQTJCO0FBQzNCLElBQUlJLGtCQUFrQjtJQUNwQnJFLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBQ0EsT0FBTztZQUFFQyxNQUFNO1lBQVFGO1FBQU07SUFDL0I7QUFDRjtBQUNBLElBQUltRSxpQkFBaUI7SUFDbkJ0RSxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksQ0FBQ08sTUFBTUMsT0FBTyxDQUFDUixRQUFRO1lBQ3pCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRUMsTUFBTTtZQUFRRjtRQUFNO0lBQy9CO0FBQ0Y7QUFDQSxJQUFJb0UsbUJBQW1CO0lBQ3JCdkUsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUM3QixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFDQSxPQUFPO1lBQUVDLE1BQU07WUFBU0Y7UUFBTTtJQUNoQztBQUNGO0FBQ0EsSUFBSXFFLCtCQUErQjtJQUNqQ3hFLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSSxDQUFDTyxNQUFNQyxPQUFPLENBQUNSLFFBQVE7WUFDekIsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBQ0EsT0FBTztZQUFFQyxNQUFNO1lBQXVCRjtRQUFNO0lBQzlDO0FBQ0Y7QUFDQSxJQUFJc0UscUJBQXFCO0lBQ3ZCekUsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsaUJBQWdCQSxLQUFJLEtBQU0sT0FBT0EsTUFBTXVFLFVBQVUsS0FBSyxZQUFZLENBQUUsZUFBY3ZFLEtBQUksS0FBTSxPQUFPQSxNQUFNd0UsUUFBUSxLQUFLLFlBQVksQ0FBRSxXQUFVeEUsS0FBSSxLQUFNLE9BQU9BLE1BQU15RSxJQUFJLEtBQUssVUFBVTtZQUMxTyxNQUFNLElBQUl4RSxNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTkY7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJMEUsdUJBQXVCO0lBQ3pCN0UsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsaUJBQWdCQSxLQUFJLEtBQU0sT0FBT0EsTUFBTXVFLFVBQVUsS0FBSyxZQUFZLENBQUUsYUFBWXZFLEtBQUksR0FBSTtZQUMxSSxNQUFNLElBQUlDLE1BQ1I7UUFFSjtRQUNBLE9BQU87WUFDTEMsTUFBTTtZQUNORjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLElBQUkyRSxtQ0FBbUM7SUFDckM5RSxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUlBLFNBQVMsUUFBUSxPQUFPQSxVQUFVLFlBQVksQ0FBRSxpQkFBZ0JBLEtBQUksS0FBTSxPQUFPQSxNQUFNdUUsVUFBVSxLQUFLLFlBQVksQ0FBRSxlQUFjdkUsS0FBSSxLQUFNLE9BQU9BLE1BQU13RSxRQUFRLEtBQUssVUFBVTtZQUNsTCxNQUFNLElBQUl2RSxNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTkY7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJNEUsMEJBQTBCO0lBQzVCL0UsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsaUJBQWdCQSxLQUFJLEtBQU0sT0FBT0EsTUFBTXVFLFVBQVUsS0FBSyxZQUFZLENBQUUsb0JBQW1CdkUsS0FBSSxLQUFNLE9BQU9BLE1BQU02RSxhQUFhLEtBQUssVUFBVTtZQUM1TCxNQUFNLElBQUk1RSxNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTkY7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJOEUsMEJBQTBCO0lBQzVCakYsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsbUJBQWtCQSxLQUFJLEtBQU0sT0FBT0EsTUFBTStFLFlBQVksS0FBSyxVQUFVO1lBQ3RILE1BQU0sSUFBSTlFLE1BQ1I7UUFFSjtRQUNBLE1BQU00RCxTQUFTO1lBQ2JrQixjQUFjL0UsTUFBTStFLFlBQVk7UUFDbEM7UUFDQSxJQUFJLFdBQVcvRSxTQUFTQSxNQUFNZ0YsS0FBSyxJQUFJLFFBQVEsT0FBT2hGLE1BQU1nRixLQUFLLEtBQUssWUFBWSxrQkFBa0JoRixNQUFNZ0YsS0FBSyxJQUFJLHNCQUFzQmhGLE1BQU1nRixLQUFLLEVBQUU7WUFDcEpuQixPQUFPbUIsS0FBSyxHQUFHO2dCQUNiekMsY0FBYyxPQUFPdkMsTUFBTWdGLEtBQUssQ0FBQ3pDLFlBQVksS0FBSyxXQUFXdkMsTUFBTWdGLEtBQUssQ0FBQ3pDLFlBQVksR0FBRzBDLE9BQU9DLEdBQUc7Z0JBQ2xHMUMsa0JBQWtCLE9BQU94QyxNQUFNZ0YsS0FBSyxDQUFDeEMsZ0JBQWdCLEtBQUssV0FBV3hDLE1BQU1nRixLQUFLLENBQUN4QyxnQkFBZ0IsR0FBR3lDLE9BQU9DLEdBQUc7WUFDaEg7UUFDRjtRQUNBLE9BQU87WUFDTGhGLE1BQU07WUFDTkYsT0FBTzZEO1FBQ1Q7SUFDRjtBQUNGO0FBQ0EsSUFBSXNCLHVCQUF1QjtJQUN6QnRGLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSUEsU0FBUyxRQUFRLE9BQU9BLFVBQVUsWUFBWSxDQUFFLG1CQUFrQkEsS0FBSSxLQUFNLE9BQU9BLE1BQU0rRSxZQUFZLEtBQUssVUFBVTtZQUN0SCxNQUFNLElBQUk5RSxNQUNSO1FBRUo7UUFDQSxNQUFNNEQsU0FBUztZQUNia0IsY0FBYy9FLE1BQU0rRSxZQUFZO1lBQ2hDSyxhQUFhO1FBQ2Y7UUFDQSxJQUFJLFdBQVdwRixTQUFTQSxNQUFNZ0YsS0FBSyxJQUFJLFFBQVEsT0FBT2hGLE1BQU1nRixLQUFLLEtBQUssWUFBWSxrQkFBa0JoRixNQUFNZ0YsS0FBSyxJQUFJLHNCQUFzQmhGLE1BQU1nRixLQUFLLEVBQUU7WUFDcEpuQixPQUFPbUIsS0FBSyxHQUFHO2dCQUNiekMsY0FBYyxPQUFPdkMsTUFBTWdGLEtBQUssQ0FBQ3pDLFlBQVksS0FBSyxXQUFXdkMsTUFBTWdGLEtBQUssQ0FBQ3pDLFlBQVksR0FBRzBDLE9BQU9DLEdBQUc7Z0JBQ2xHMUMsa0JBQWtCLE9BQU94QyxNQUFNZ0YsS0FBSyxDQUFDeEMsZ0JBQWdCLEtBQUssV0FBV3hDLE1BQU1nRixLQUFLLENBQUN4QyxnQkFBZ0IsR0FBR3lDLE9BQU9DLEdBQUc7WUFDaEg7UUFDRjtRQUNBLElBQUksaUJBQWlCbEYsU0FBUyxPQUFPQSxNQUFNb0YsV0FBVyxLQUFLLFdBQVc7WUFDcEV2QixPQUFPdUIsV0FBVyxHQUFHcEYsTUFBTW9GLFdBQVc7UUFDeEM7UUFDQSxPQUFPO1lBQ0xsRixNQUFNO1lBQ05GLE9BQU82RDtRQUNUO0lBQ0Y7QUFDRjtBQUNBLElBQUl3QixzQkFBc0I7SUFDeEJ4RixNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUlBLFNBQVMsUUFBUSxPQUFPQSxVQUFVLFlBQVksQ0FBRSxnQkFBZUEsS0FBSSxLQUFNLE9BQU9BLE1BQU1lLFNBQVMsS0FBSyxVQUFVO1lBQ2hILE1BQU0sSUFBSWQsTUFDUjtRQUVKO1FBQ0EsT0FBTztZQUNMQyxNQUFNO1lBQ05GLE9BQU87Z0JBQ0xlLFdBQVdmLE1BQU1lLFNBQVM7WUFDNUI7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJdUUsc0JBQXNCO0lBQ3hCekYsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUM3QixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFDQSxPQUFPO1lBQUVDLE1BQU07WUFBYUY7UUFBTTtJQUNwQztBQUNGO0FBQ0EsSUFBSXVGLGFBQWE7SUFDZjFGLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSUEsU0FBUyxRQUFRLE9BQU9BLFVBQVUsVUFBVTtZQUM5QyxNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTkY7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJd0Ysa0JBQWtCO0lBQ3BCdEI7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUk7SUFDQUM7SUFDQUM7SUFDQUU7SUFDQUs7SUFDQUU7SUFDQUM7SUFDQUM7Q0FDRDtBQUNELElBQUlFLHdCQUF3QkMsT0FBT0MsV0FBVyxDQUM1Q0gsZ0JBQWdCbkUsR0FBRyxDQUFDLENBQUNDLE9BQVM7UUFBQ0EsS0FBS3pCLElBQUk7UUFBRXlCO0tBQUs7QUFFakQsSUFBSXNFLDJCQUEyQkYsT0FBT0MsV0FBVyxDQUMvQ0gsZ0JBQWdCbkUsR0FBRyxDQUFDLENBQUNDLE9BQVM7UUFBQ0EsS0FBS3hCLElBQUk7UUFBRXdCLEtBQUt6QixJQUFJO0tBQUM7QUFFdEQsSUFBSWdHLGNBQWNMLGdCQUFnQm5FLEdBQUcsQ0FBQyxDQUFDQyxPQUFTQSxLQUFLekIsSUFBSTtBQUN6RCxJQUFJaUcsc0JBQXNCLENBQUN0RTtJQUN6QixNQUFNQyxzQkFBc0JELEtBQUtFLE9BQU8sQ0FBQztJQUN6QyxJQUFJRCx3QkFBd0IsQ0FBQyxHQUFHO1FBQzlCLE1BQU0sSUFBSXhCLE1BQU07SUFDbEI7SUFDQSxNQUFNMEIsU0FBU0gsS0FBS0ksS0FBSyxDQUFDLEdBQUdIO0lBQzdCLElBQUksQ0FBQ29FLFlBQVloRSxRQUFRLENBQUNGLFNBQVM7UUFDakMsTUFBTSxJQUFJMUIsTUFBTSxDQUFDLDRDQUE0QyxFQUFFMEIsT0FBTyxDQUFDLENBQUM7SUFDMUU7SUFDQSxNQUFNOUIsT0FBTzhCO0lBQ2IsTUFBTUcsWUFBWU4sS0FBS0ksS0FBSyxDQUFDSCxzQkFBc0I7SUFDbkQsTUFBTU0sWUFBWUMsS0FBS2pDLEtBQUssQ0FBQytCO0lBQzdCLE9BQU8yRCxxQkFBcUIsQ0FBQzVGLEtBQUssQ0FBQ0UsS0FBSyxDQUFDZ0M7QUFDM0M7QUFDQSxTQUFTZ0UscUJBQXFCN0YsSUFBSSxFQUFFRixLQUFLO0lBQ3ZDLE1BQU1rQyxhQUFhc0QsZ0JBQWdCckQsSUFBSSxDQUFDLENBQUNiLE9BQVNBLEtBQUt4QixJQUFJLEtBQUtJO0lBQ2hFLElBQUksQ0FBQ2dDLFlBQVk7UUFDZixNQUFNLElBQUlqQyxNQUFNLENBQUMsMEJBQTBCLEVBQUVDLEtBQUssQ0FBQztJQUNyRDtJQUNBLE9BQU8sQ0FBQyxFQUFFZ0MsV0FBV3JDLElBQUksQ0FBQyxDQUFDLEVBQUVtQyxLQUFLSSxTQUFTLENBQUNwQyxPQUFPO0FBQ3JELENBQUM7QUFDRDtBQUVBLDZCQUE2QjtBQUM3QixJQUFJZ0csVUFBVSxLQUFLQyxVQUFVLENBQUM7QUFDOUIsU0FBU0MsYUFBYUMsTUFBTSxFQUFFQyxXQUFXO0lBQ3ZDLE1BQU1DLHFCQUFxQixJQUFJQyxXQUFXRjtJQUMxQyxJQUFJRyxTQUFTO0lBQ2IsS0FBSyxNQUFNQyxTQUFTTCxPQUFRO1FBQzFCRSxtQkFBbUJJLEdBQUcsQ0FBQ0QsT0FBT0Q7UUFDOUJBLFVBQVVDLE1BQU1oRCxNQUFNO0lBQ3hCO0lBQ0EyQyxPQUFPM0MsTUFBTSxHQUFHO0lBQ2hCLE9BQU82QztBQUNUO0FBQ0EsZUFBZUssa0JBQWtCLEVBQy9CQyxNQUFNLEVBQ05DLFVBQVUsRUFDVkMsZUFBZSxFQUNmQyxZQUFZLEVBQ1pDLFVBQVUsRUFDVkMsV0FBVyxFQUNYQyw0QkFBNEIsRUFDNUJDLG1CQUFtQixFQUNuQkMsY0FBYyxFQUNkQyxnQkFBZ0IsRUFDaEJDLHdCQUF3QixFQUN4QkMsbUJBQW1CLEVBQ25CQyxnQkFBZ0IsRUFDaEJDLGVBQWUsRUFDaEI7SUFDQyxNQUFNQyxTQUFTZCxPQUFPZSxTQUFTO0lBQy9CLE1BQU1DLFVBQVUsSUFBSUM7SUFDcEIsTUFBTXpCLFNBQVMsRUFBRTtJQUNqQixJQUFJQyxjQUFjO0lBQ2xCLE1BQU8sS0FBTTtRQUNYLE1BQU0sRUFBRXBHLEtBQUssRUFBRSxHQUFHLE1BQU15SCxPQUFPSSxJQUFJO1FBQ25DLElBQUk3SCxPQUFPO1lBQ1RtRyxPQUFPOUMsSUFBSSxDQUFDckQ7WUFDWm9HLGVBQWVwRyxNQUFNd0QsTUFBTTtZQUMzQixJQUFJeEQsS0FBSyxDQUFDQSxNQUFNd0QsTUFBTSxHQUFHLEVBQUUsS0FBS3dDLFNBQVM7Z0JBQ3ZDO1lBQ0Y7UUFDRjtRQUNBLElBQUlHLE9BQU8zQyxNQUFNLEtBQUssR0FBRztZQUN2QjtRQUNGO1FBQ0EsTUFBTTZDLHFCQUFxQkgsYUFBYUMsUUFBUUM7UUFDaERBLGNBQWM7UUFDZCxNQUFNMEIsY0FBY0gsUUFBUUksTUFBTSxDQUFDMUIsb0JBQW9CO1lBQUVNLFFBQVE7UUFBSyxHQUFHcUIsS0FBSyxDQUFDLE1BQU1DLE1BQU0sQ0FBQyxDQUFDekcsT0FBU0EsU0FBUyxJQUFJSCxHQUFHLENBQUN5RTtRQUN2SCxLQUFLLE1BQU0sRUFBRTVGLElBQUksRUFBRUYsT0FBT2tJLE1BQU0sRUFBRSxJQUFJSixZQUFhO1lBQ2pELE9BQVE1SDtnQkFDTixLQUFLO29CQUNILE1BQU8wRyxDQUFBQSxjQUFjLE9BQU8sS0FBSyxJQUFJQSxXQUFXc0IsT0FBTTtvQkFDdEQ7Z0JBQ0YsS0FBSztvQkFDSCxNQUFPckIsQ0FBQUEsbUJBQW1CLE9BQU8sS0FBSyxJQUFJQSxnQkFBZ0JxQixPQUFNO29CQUNoRTtnQkFDRixLQUFLO29CQUNILE1BQU9wQixDQUFBQSxnQkFBZ0IsT0FBTyxLQUFLLElBQUlBLGFBQWFvQixPQUFNO29CQUMxRDtnQkFDRixLQUFLO29CQUNILE1BQU9uQixDQUFBQSxjQUFjLE9BQU8sS0FBSyxJQUFJQSxXQUFXbUIsT0FBTTtvQkFDdEQ7Z0JBQ0YsS0FBSztvQkFDSCxNQUFPbEIsQ0FBQUEsZUFBZSxPQUFPLEtBQUssSUFBSUEsWUFBWWtCLE9BQU07b0JBQ3hEO2dCQUNGLEtBQUs7b0JBQ0gsTUFBT2IsQ0FBQUEsNEJBQTRCLE9BQU8sS0FBSyxJQUFJQSx5QkFBeUJhLE9BQU07b0JBQ2xGO2dCQUNGLEtBQUs7b0JBQ0gsTUFBT2pCLENBQUFBLGdDQUFnQyxPQUFPLEtBQUssSUFBSUEsNkJBQTZCaUIsT0FBTTtvQkFDMUY7Z0JBQ0YsS0FBSztvQkFDSCxNQUFPaEIsQ0FBQUEsdUJBQXVCLE9BQU8sS0FBSyxJQUFJQSxvQkFBb0JnQixPQUFNO29CQUN4RTtnQkFDRixLQUFLO29CQUNILE1BQU9mLENBQUFBLGtCQUFrQixPQUFPLEtBQUssSUFBSUEsZUFBZWUsT0FBTTtvQkFDOUQ7Z0JBQ0YsS0FBSztvQkFDSCxNQUFPZCxDQUFBQSxvQkFBb0IsT0FBTyxLQUFLLElBQUlBLGlCQUFpQmMsT0FBTTtvQkFDbEU7Z0JBQ0YsS0FBSztvQkFDSCxNQUFPWixDQUFBQSx1QkFBdUIsT0FBTyxLQUFLLElBQUlBLG9CQUFvQlksT0FBTTtvQkFDeEU7Z0JBQ0YsS0FBSztvQkFDSCxNQUFPWCxDQUFBQSxvQkFBb0IsT0FBTyxLQUFLLElBQUlBLGlCQUFpQlcsT0FBTTtvQkFDbEU7Z0JBQ0YsS0FBSztvQkFDSCxNQUFPVixDQUFBQSxtQkFBbUIsT0FBTyxLQUFLLElBQUlBLGdCQUFnQlUsT0FBTTtvQkFDaEU7Z0JBQ0Y7b0JBQVM7d0JBQ1AsTUFBTUMsa0JBQWtCakk7d0JBQ3hCLE1BQU0sSUFBSUQsTUFBTSxDQUFDLDBCQUEwQixFQUFFa0ksZ0JBQWdCLENBQUM7b0JBQ2hFO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQSwrQkFBK0I7QUFDL0IsZUFBZUMsb0JBQW9CLEVBQ2pDekIsTUFBTSxFQUNOMEIsTUFBTSxFQUNOQyxVQUFVLEVBQ1ZDLFFBQVEsRUFDUjVJLFlBQVk2SSxjQUFjbkcsOERBQWtCLEVBQzVDb0csaUJBQWlCLElBQU0sYUFBYSxHQUFHLElBQUlDLE1BQU0sRUFDakRDLFdBQVcsRUFDWjtJQUNDLElBQUlDLElBQUlDO0lBQ1IsTUFBTUMscUJBQXFCLENBQUNILGVBQWUsT0FBTyxLQUFLLElBQUlBLFlBQVlySSxJQUFJLE1BQU07SUFDakYsSUFBSXlJLE9BQU9ELHFCQUFxQixJQUFJLDhDQUE4QztJQUNqRixFQUFDRCxLQUFLLENBQUNELEtBQUtELFlBQVlLLGVBQWUsS0FBSyxPQUFPLEtBQUssSUFBSUosR0FBR0ssTUFBTSxDQUFDLENBQUNDLEtBQUtDO1FBQzNFLElBQUlDO1FBQ0osT0FBT0MsS0FBS0gsR0FBRyxDQUFDQSxLQUFLLENBQUNFLE1BQU1ELGVBQWVKLElBQUksS0FBSyxPQUFPSyxNQUFNO0lBQ25FLEdBQUcsRUFBQyxLQUFNLE9BQU9QLEtBQUssS0FBSztJQUMzQixNQUFNUyxVQUFVUixxQkFBcUJTLGdCQUFnQlosZUFBZTtRQUNsRXRJLElBQUltSTtRQUNKZ0IsV0FBV2Y7UUFDWG5JLE1BQU07UUFDTkcsU0FBUztRQUNUZ0osT0FBTyxFQUFFO0lBQ1g7SUFDQSxJQUFJQyxrQkFBa0IsS0FBSztJQUMzQixJQUFJQyx1QkFBdUIsS0FBSztJQUNoQyxTQUFTQyx5QkFBeUJyRixVQUFVLEVBQUVzRixVQUFVO1FBQ3RELE1BQU12SSxPQUFPZ0ksUUFBUUcsS0FBSyxDQUFDdEgsSUFBSSxDQUM3QixDQUFDMkgsUUFBVUEsTUFBTTVKLElBQUksS0FBSyxxQkFBcUI0SixNQUFNWCxjQUFjLENBQUM1RSxVQUFVLEtBQUtBO1FBRXJGLElBQUlqRCxRQUFRLE1BQU07WUFDaEJBLEtBQUs2SCxjQUFjLEdBQUdVO1FBQ3hCLE9BQU87WUFDTFAsUUFBUUcsS0FBSyxDQUFDcEcsSUFBSSxDQUFDO2dCQUNqQm5ELE1BQU07Z0JBQ05pSixnQkFBZ0JVO1lBQ2xCO1FBQ0Y7SUFDRjtJQUNBLE1BQU1FLE9BQU8sRUFBRTtJQUNmLElBQUlDLHFCQUFxQmxCLHFCQUFxQkgsZUFBZSxPQUFPLEtBQUssSUFBSUEsWUFBWXNCLFdBQVcsR0FBRyxLQUFLO0lBQzVHLE1BQU1DLG1CQUFtQixDQUFDO0lBQzFCLElBQUlsRixRQUFRO1FBQ1Z4QyxrQkFBa0IwQztRQUNsQjNDLGNBQWMyQztRQUNkekMsYUFBYXlDO0lBQ2Y7SUFDQSxJQUFJSCxlQUFlO0lBQ25CLFNBQVNvRjtRQUNQLE1BQU1DLGFBQWE7ZUFBSUw7U0FBSztRQUM1QixJQUFJQyxzQkFBc0IsT0FBTyxLQUFLLElBQUlBLG1CQUFtQnhHLE1BQU0sRUFBRTtZQUNuRThGLFFBQVFXLFdBQVcsR0FBR0Q7UUFDeEI7UUFDQSxNQUFNSyxnQkFBZ0I7WUFDcEIsa0ZBQWtGO1lBQ2xGLHVGQUF1RjtZQUN2RixHQUFHZCxnQkFBZ0JELFFBQVE7WUFDM0IsK0VBQStFO1lBQy9FLCtFQUErRTtZQUMvRSwrRUFBK0U7WUFDL0UsNEVBQTRFO1lBQzVFLDJCQUEyQjtZQUMzQmdCLFlBQVk5QjtRQUNkO1FBQ0FILE9BQU87WUFDTGlCLFNBQVNlO1lBQ1ROLE1BQU1LO1lBQ050QjtRQUNGO0lBQ0Y7SUFDQSxNQUFNcEMsa0JBQWtCO1FBQ3RCQztRQUNBQyxZQUFXNUcsS0FBSztZQUNkLElBQUkwSixtQkFBbUIsTUFBTTtnQkFDM0JBLGtCQUFrQjtvQkFDaEJ4SixNQUFNO29CQUNOVSxNQUFNWjtnQkFDUjtnQkFDQXNKLFFBQVFHLEtBQUssQ0FBQ3BHLElBQUksQ0FBQ3FHO1lBQ3JCLE9BQU87Z0JBQ0xBLGdCQUFnQjlJLElBQUksSUFBSVo7WUFDMUI7WUFDQXNKLFFBQVE3SSxPQUFPLElBQUlUO1lBQ25CbUs7UUFDRjtRQUNBdEQsaUJBQWdCN0csS0FBSztZQUNuQixJQUFJb0o7WUFDSixJQUFJTyx3QkFBd0IsTUFBTTtnQkFDaENBLHVCQUF1QjtvQkFDckJ6SixNQUFNO29CQUNOcUssV0FBV3ZLO2dCQUNiO2dCQUNBc0osUUFBUUcsS0FBSyxDQUFDcEcsSUFBSSxDQUFDc0c7WUFDckIsT0FBTztnQkFDTEEscUJBQXFCWSxTQUFTLElBQUl2SztZQUNwQztZQUNBc0osUUFBUWlCLFNBQVMsR0FBRyxDQUFDLENBQUNuQixNQUFNRSxRQUFRaUIsU0FBUyxLQUFLLE9BQU9uQixNQUFNLEVBQUMsSUFBS3BKO1lBQ3JFbUs7UUFDRjtRQUNBckQsY0FBYTlHLEtBQUs7WUFDaEJzSixRQUFRRyxLQUFLLENBQUNwRyxJQUFJLENBQUM7Z0JBQ2pCbkQsTUFBTTtnQkFDTnNLLFFBQVF4SztZQUNWO1lBQ0FtSztRQUNGO1FBQ0FsRCw4QkFBNkJqSCxLQUFLO1lBQ2hDLElBQUlzSixRQUFRTixlQUFlLElBQUksTUFBTTtnQkFDbkNNLFFBQVFOLGVBQWUsR0FBRyxFQUFFO1lBQzlCO1lBQ0FrQixnQkFBZ0IsQ0FBQ2xLLE1BQU11RSxVQUFVLENBQUMsR0FBRztnQkFDbkMzRCxNQUFNO2dCQUNObUk7Z0JBQ0F2RSxVQUFVeEUsTUFBTXdFLFFBQVE7Z0JBQ3hCaUcsT0FBT25CLFFBQVFOLGVBQWUsQ0FBQ3hGLE1BQU07WUFDdkM7WUFDQSxNQUFNcUcsYUFBYTtnQkFDakIvRixPQUFPO2dCQUNQaUY7Z0JBQ0F4RSxZQUFZdkUsTUFBTXVFLFVBQVU7Z0JBQzVCQyxVQUFVeEUsTUFBTXdFLFFBQVE7Z0JBQ3hCQyxNQUFNLEtBQUs7WUFDYjtZQUNBNkUsUUFBUU4sZUFBZSxDQUFDM0YsSUFBSSxDQUFDd0c7WUFDN0JELHlCQUF5QjVKLE1BQU11RSxVQUFVLEVBQUVzRjtZQUMzQ007UUFDRjtRQUNBakQscUJBQW9CbEgsS0FBSztZQUN2QixNQUFNMEssa0JBQWtCUixnQkFBZ0IsQ0FBQ2xLLE1BQU11RSxVQUFVLENBQUM7WUFDMURtRyxnQkFBZ0I5SixJQUFJLElBQUlaLE1BQU02RSxhQUFhO1lBQzNDLE1BQU0sRUFBRTdFLE9BQU8ySyxXQUFXLEVBQUUsR0FBRzVHLGlCQUFpQjJHLGdCQUFnQjlKLElBQUk7WUFDcEUsTUFBTWlKLGFBQWE7Z0JBQ2pCL0YsT0FBTztnQkFDUGlGLE1BQU0yQixnQkFBZ0IzQixJQUFJO2dCQUMxQnhFLFlBQVl2RSxNQUFNdUUsVUFBVTtnQkFDNUJDLFVBQVVrRyxnQkFBZ0JsRyxRQUFRO2dCQUNsQ0MsTUFBTWtHO1lBQ1I7WUFDQXJCLFFBQVFOLGVBQWUsQ0FBQzBCLGdCQUFnQkQsS0FBSyxDQUFDLEdBQUdaO1lBQ2pERCx5QkFBeUI1SixNQUFNdUUsVUFBVSxFQUFFc0Y7WUFDM0NNO1FBQ0Y7UUFDQSxNQUFNaEQsZ0JBQWVuSCxLQUFLO1lBQ3hCLE1BQU02SixhQUFhO2dCQUNqQi9GLE9BQU87Z0JBQ1BpRjtnQkFDQSxHQUFHL0ksS0FBSztZQUNWO1lBQ0EsSUFBSWtLLGdCQUFnQixDQUFDbEssTUFBTXVFLFVBQVUsQ0FBQyxJQUFJLE1BQU07Z0JBQzlDK0UsUUFBUU4sZUFBZSxDQUFDa0IsZ0JBQWdCLENBQUNsSyxNQUFNdUUsVUFBVSxDQUFDLENBQUNrRyxLQUFLLENBQUMsR0FBR1o7WUFDdEUsT0FBTztnQkFDTCxJQUFJUCxRQUFRTixlQUFlLElBQUksTUFBTTtvQkFDbkNNLFFBQVFOLGVBQWUsR0FBRyxFQUFFO2dCQUM5QjtnQkFDQU0sUUFBUU4sZUFBZSxDQUFDM0YsSUFBSSxDQUFDd0c7WUFDL0I7WUFDQUQseUJBQXlCNUosTUFBTXVFLFVBQVUsRUFBRXNGO1lBQzNDTTtZQUNBLElBQUk3QixZQUFZO2dCQUNkLE1BQU16RSxTQUFTLE1BQU15RSxXQUFXO29CQUFFc0MsVUFBVTVLO2dCQUFNO2dCQUNsRCxJQUFJNkQsVUFBVSxNQUFNO29CQUNsQixNQUFNZ0gsY0FBYzt3QkFDbEIvRyxPQUFPO3dCQUNQaUY7d0JBQ0EsR0FBRy9JLEtBQUs7d0JBQ1I2RDtvQkFDRjtvQkFDQXlGLFFBQVFOLGVBQWUsQ0FBQ00sUUFBUU4sZUFBZSxDQUFDeEYsTUFBTSxHQUFHLEVBQUUsR0FBR3FIO29CQUM5RGpCLHlCQUF5QjVKLE1BQU11RSxVQUFVLEVBQUVzRztvQkFDM0NWO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBL0Msa0JBQWlCcEgsS0FBSztZQUNwQixNQUFNZ0osa0JBQWtCTSxRQUFRTixlQUFlO1lBQy9DLElBQUlBLG1CQUFtQixNQUFNO2dCQUMzQixNQUFNLElBQUkvSSxNQUFNO1lBQ2xCO1lBQ0EsTUFBTTZLLHNCQUFzQjlCLGdCQUFnQitCLFNBQVMsQ0FDbkQsQ0FBQ0YsY0FBZ0JBLFlBQVl0RyxVQUFVLEtBQUt2RSxNQUFNdUUsVUFBVTtZQUU5RCxJQUFJdUcsd0JBQXdCLENBQUMsR0FBRztnQkFDOUIsTUFBTSxJQUFJN0ssTUFDUjtZQUVKO1lBQ0EsTUFBTTRKLGFBQWE7Z0JBQ2pCLEdBQUdiLGVBQWUsQ0FBQzhCLG9CQUFvQjtnQkFDdkNoSCxPQUFPO2dCQUNQLEdBQUc5RCxLQUFLO1lBQ1Y7WUFDQWdKLGVBQWUsQ0FBQzhCLG9CQUFvQixHQUFHakI7WUFDdkNELHlCQUF5QjVKLE1BQU11RSxVQUFVLEVBQUVzRjtZQUMzQ007UUFDRjtRQUNBcEQsWUFBVy9HLEtBQUs7WUFDZCtKLEtBQUsxRyxJQUFJLElBQUlyRDtZQUNibUs7UUFDRjtRQUNBOUMsMEJBQXlCckgsS0FBSztZQUM1QixJQUFJZ0ssc0JBQXNCLE1BQU07Z0JBQzlCQSxxQkFBcUI7dUJBQUloSztpQkFBTTtZQUNqQyxPQUFPO2dCQUNMZ0ssbUJBQW1CM0csSUFBSSxJQUFJckQ7WUFDN0I7WUFDQW1LO1FBQ0Y7UUFDQTVDLGtCQUFpQnZILEtBQUs7WUFDcEIrSSxRQUFRO1lBQ1JXLGtCQUFrQjFKLE1BQU1vRixXQUFXLEdBQUdzRSxrQkFBa0IsS0FBSztZQUM3REMsdUJBQXVCLEtBQUs7UUFDOUI7UUFDQW5DLGlCQUFnQnhILEtBQUs7WUFDbkIsSUFBSSxDQUFDOEksb0JBQW9CO2dCQUN2QlEsUUFBUWpKLEVBQUUsR0FBR0wsTUFBTWUsU0FBUztZQUM5QjtRQUNGO1FBQ0F1RyxxQkFBb0J0SCxLQUFLO1lBQ3ZCK0UsZUFBZS9FLE1BQU0rRSxZQUFZO1lBQ2pDLElBQUkvRSxNQUFNZ0YsS0FBSyxJQUFJLE1BQU07Z0JBQ3ZCQSxRQUFRMUMsNEJBQTRCdEMsTUFBTWdGLEtBQUs7WUFDakQ7UUFDRjtRQUNBZ0MsYUFBWWdFLEtBQUs7WUFDZixNQUFNLElBQUkvSyxNQUFNK0s7UUFDbEI7SUFDRjtJQUNBekMsWUFBWSxPQUFPLEtBQUssSUFBSUEsU0FBUztRQUFFZTtRQUFTdkU7UUFBY0M7SUFBTTtBQUN0RTtBQUVBLG9DQUFvQztBQUN1QztBQUUzRSw2QkFBNkI7QUFDN0IsZUFBZWtHLGtCQUFrQixFQUMvQnZFLE1BQU0sRUFDTkMsVUFBVSxFQUNYO0lBQ0MsTUFBTWEsU0FBU2QsT0FBT3dFLFdBQVcsQ0FBQyxJQUFJQyxxQkFBcUIxRCxTQUFTO0lBQ3BFLE1BQU8sS0FBTTtRQUNYLE1BQU0sRUFBRTJELElBQUksRUFBRXJMLEtBQUssRUFBRSxHQUFHLE1BQU15SCxPQUFPSSxJQUFJO1FBQ3pDLElBQUl3RCxNQUFNO1lBQ1I7UUFDRjtRQUNBLE1BQU16RSxXQUFXNUc7SUFDbkI7QUFDRjtBQUVBLG9DQUFvQztBQUNwQyxlQUFlc0wsd0JBQXdCLEVBQ3JDM0UsTUFBTSxFQUNOMEIsTUFBTSxFQUNORSxRQUFRLEVBQ1JFLGlCQUFpQixJQUFNLGFBQWEsR0FBRyxJQUFJQyxNQUFNLEVBQ2pEL0ksWUFBWTZJLGNBQWN5Qyw4REFBbUIsRUFDOUM7SUFDQyxNQUFNTSxXQUFXO1FBQUVyTCxNQUFNO1FBQVFVLE1BQU07SUFBRztJQUMxQyxNQUFNNEssZ0JBQWdCO1FBQ3BCbkwsSUFBSW1JO1FBQ0pnQixXQUFXZjtRQUNYbkksTUFBTTtRQUNORyxTQUFTO1FBQ1RnSixPQUFPO1lBQUM4QjtTQUFTO0lBQ25CO0lBQ0EsTUFBTUwsa0JBQWtCO1FBQ3RCdkU7UUFDQUMsWUFBWSxDQUFDSjtZQUNYZ0YsY0FBYy9LLE9BQU8sSUFBSStGO1lBQ3pCK0UsU0FBUzNLLElBQUksSUFBSTRGO1lBQ2pCNkIsT0FBTztnQkFDTGlCLFNBQVM7b0JBQUUsR0FBR2tDLGFBQWE7Z0JBQUM7Z0JBQzVCekIsTUFBTSxFQUFFO2dCQUNSakIsb0JBQW9CO1lBQ3RCO1FBQ0Y7SUFDRjtJQUNBUCxZQUFZLE9BQU8sS0FBSyxJQUFJQSxTQUFTaUQsZUFBZTtRQUNsRHhHLE9BQU87WUFBRXhDLGtCQUFrQjBDO1lBQUszQyxjQUFjMkM7WUFBS3pDLGFBQWF5QztRQUFJO1FBQ3BFSCxjQUFjO0lBQ2hCO0FBQ0Y7QUFFQSx1QkFBdUI7QUFDdkIsSUFBSTBHLG1CQUFtQixJQUFNQztBQUM3QixlQUFlQyxZQUFZLEVBQ3pCQyxHQUFHLEVBQ0hDLElBQUksRUFDSkMsaUJBQWlCLE1BQU0sRUFDdkJDLFdBQVcsRUFDWEMsT0FBTyxFQUNQQyxlQUFlLEVBQ2ZDLHdCQUF3QixFQUN4QkMsVUFBVSxFQUNWQyxRQUFRLEVBQ1I3RCxRQUFRLEVBQ1JELFVBQVUsRUFDVjNJLFlBQVk2SSxXQUFXLEVBQ3ZCa0QsT0FBT1csU0FBU1osa0JBQWtCLEVBQ2xDOUMsV0FBVyxFQUNaO0lBQ0MsSUFBSUMsSUFBSUM7SUFDUixNQUFNeUQsV0FBVyxNQUFNRCxPQUFPVCxLQUFLO1FBQ2pDVyxRQUFRO1FBQ1JWLE1BQU03SixLQUFLSSxTQUFTLENBQUN5SjtRQUNyQkcsU0FBUztZQUNQLGdCQUFnQjtZQUNoQixHQUFHQSxPQUFPO1FBQ1o7UUFDQVEsUUFBUSxDQUFDNUQsS0FBS3FELG1CQUFtQixPQUFPLEtBQUssSUFBSUEsaUJBQWdCLEtBQU0sT0FBTyxLQUFLLElBQUlyRCxHQUFHNEQsTUFBTTtRQUNoR1Q7SUFDRixHQUFHVSxLQUFLLENBQUMsQ0FBQ0M7UUFDUlI7UUFDQSxNQUFNUTtJQUNSO0lBQ0EsSUFBSVAsWUFBWTtRQUNkLElBQUk7WUFDRixNQUFNQSxXQUFXRztRQUNuQixFQUFFLE9BQU9JLEtBQUs7WUFDWixNQUFNQTtRQUNSO0lBQ0Y7SUFDQSxJQUFJLENBQUNKLFNBQVNLLEVBQUUsRUFBRTtRQUNoQlQ7UUFDQSxNQUFNLElBQUlqTSxNQUNSLENBQUM0SSxLQUFLLE1BQU15RCxTQUFTMUwsSUFBSSxFQUFDLEtBQU0sT0FBT2lJLEtBQUs7SUFFaEQ7SUFDQSxJQUFJLENBQUN5RCxTQUFTVCxJQUFJLEVBQUU7UUFDbEIsTUFBTSxJQUFJNUwsTUFBTTtJQUNsQjtJQUNBLE9BQVE2TDtRQUNOLEtBQUs7WUFBUTtnQkFDWCxNQUFNUix3QkFBd0I7b0JBQzVCM0UsUUFBUTJGLFNBQVNULElBQUk7b0JBQ3JCeEQsUUFBUStEO29CQUNSN0Q7b0JBQ0E1SSxZQUFZNkk7Z0JBQ2Q7Z0JBQ0E7WUFDRjtRQUNBLEtBQUs7WUFBUTtnQkFDWCxNQUFNSixvQkFBb0I7b0JBQ3hCekIsUUFBUTJGLFNBQVNULElBQUk7b0JBQ3JCeEQsUUFBUStEO29CQUNSekQ7b0JBQ0FMO29CQUNBQyxVQUFTLEVBQUVlLE9BQU8sRUFBRXZFLFlBQVksRUFBRUMsS0FBSyxFQUFFO3dCQUN2QyxJQUFJdUQsWUFBWWUsV0FBVyxNQUFNOzRCQUMvQmYsU0FBU2UsU0FBUztnQ0FBRXRFO2dDQUFPRDs0QkFBYTt3QkFDMUM7b0JBQ0Y7b0JBQ0FwRixZQUFZNkk7Z0JBQ2Q7Z0JBQ0E7WUFDRjtRQUNBO1lBQVM7Z0JBQ1AsTUFBTUwsa0JBQWtCMkQ7Z0JBQ3hCLE1BQU0sSUFBSTdMLE1BQU0sQ0FBQyx5QkFBeUIsRUFBRWtJLGdCQUFnQixDQUFDO1lBQy9EO0lBQ0Y7QUFDRjtBQUVBLDZCQUE2QjtBQUM3QixJQUFJeUUsb0JBQW9CLElBQU1sQjtBQUM5QixlQUFlbUIsa0JBQWtCLEVBQy9CakIsR0FBRyxFQUNIa0IsTUFBTSxFQUNOZixXQUFXLEVBQ1hDLE9BQU8sRUFDUEgsSUFBSSxFQUNKQyxpQkFBaUIsTUFBTSxFQUN2QmlCLGFBQWEsRUFDYkMsVUFBVSxFQUNWQyxRQUFRLEVBQ1JDLGtCQUFrQixFQUNsQmYsVUFBVSxFQUNWNUQsUUFBUSxFQUNSNEUsT0FBTyxFQUNQQyxNQUFNLEVBQ04xQixPQUFPVyxTQUFTTyxtQkFBbUIsRUFDcEM7SUFDQyxJQUFJaEU7SUFDSixJQUFJO1FBQ0ZvRSxXQUFXO1FBQ1hDLFNBQVMsS0FBSztRQUNkLE1BQU1oQixrQkFBa0IsSUFBSW9CO1FBQzVCSCxtQkFBbUJqQjtRQUNuQmMsY0FBYztRQUNkLE1BQU1ULFdBQVcsTUFBTUQsT0FBT1QsS0FBSztZQUNqQ1csUUFBUTtZQUNSVixNQUFNN0osS0FBS0ksU0FBUyxDQUFDO2dCQUNuQjBLO2dCQUNBLEdBQUdqQixJQUFJO1lBQ1Q7WUFDQUU7WUFDQUMsU0FBUztnQkFDUCxnQkFBZ0I7Z0JBQ2hCLEdBQUdBLE9BQU87WUFDWjtZQUNBUSxRQUFRUCxnQkFBZ0JPLE1BQU07UUFDaEMsR0FBR0MsS0FBSyxDQUFDLENBQUNDO1lBQ1IsTUFBTUE7UUFDUjtRQUNBLElBQUlQLFlBQVk7WUFDZCxJQUFJO2dCQUNGLE1BQU1BLFdBQVdHO1lBQ25CLEVBQUUsT0FBT0ksS0FBSztnQkFDWixNQUFNQTtZQUNSO1FBQ0Y7UUFDQSxJQUFJLENBQUNKLFNBQVNLLEVBQUUsRUFBRTtZQUNoQixNQUFNLElBQUkxTSxNQUNSLENBQUMySSxLQUFLLE1BQU0wRCxTQUFTMUwsSUFBSSxFQUFDLEtBQU0sT0FBT2dJLEtBQUs7UUFFaEQ7UUFDQSxJQUFJLENBQUMwRCxTQUFTVCxJQUFJLEVBQUU7WUFDbEIsTUFBTSxJQUFJNUwsTUFBTTtRQUNsQjtRQUNBLElBQUk0RCxTQUFTO1FBQ2IsT0FBUWlJO1lBQ04sS0FBSztnQkFBUTtvQkFDWCxNQUFNWixrQkFBa0I7d0JBQ3RCdkUsUUFBUTJGLFNBQVNULElBQUk7d0JBQ3JCakYsWUFBWSxDQUFDSjs0QkFDWDNDLFVBQVUyQzs0QkFDVnVHLGNBQWNsSjt3QkFDaEI7b0JBQ0Y7b0JBQ0E7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUFRO29CQUNYLE1BQU02QyxrQkFBa0I7d0JBQ3RCQyxRQUFRMkYsU0FBU1QsSUFBSTt3QkFDckJqRixZQUFXNUcsS0FBSzs0QkFDZDZELFVBQVU3RDs0QkFDVitNLGNBQWNsSjt3QkFDaEI7d0JBQ0FrRCxZQUFXL0csS0FBSzs0QkFDZG9OLFVBQVUsT0FBTyxLQUFLLElBQUlBLE9BQU9wTjt3QkFDbkM7d0JBQ0FnSCxhQUFZaEgsS0FBSzs0QkFDZixNQUFNLElBQUlDLE1BQU1EO3dCQUNsQjtvQkFDRjtvQkFDQTtnQkFDRjtZQUNBO2dCQUFTO29CQUNQLE1BQU1tSSxrQkFBa0IyRDtvQkFDeEIsTUFBTSxJQUFJN0wsTUFBTSxDQUFDLHlCQUF5QixFQUFFa0ksZ0JBQWdCLENBQUM7Z0JBQy9EO1FBQ0Y7UUFDQSxJQUFJSSxVQUFVO1lBQ1pBLFNBQVN1RSxRQUFRako7UUFDbkI7UUFDQXFKLG1CQUFtQjtRQUNuQixPQUFPcko7SUFDVCxFQUFFLE9BQU82SSxLQUFLO1FBQ1osSUFBSUEsSUFBSTVNLElBQUksS0FBSyxjQUFjO1lBQzdCb04sbUJBQW1CO1lBQ25CLE9BQU87UUFDVDtRQUNBLElBQUlSLGVBQWV6TSxPQUFPO1lBQ3hCLElBQUlrTixTQUFTO2dCQUNYQSxRQUFRVDtZQUNWO1FBQ0Y7UUFDQU8sU0FBU1A7SUFDWCxTQUFVO1FBQ1JNLFdBQVc7SUFDYjtBQUNGO0FBRUEsa0JBQWtCO0FBQ2xCLFNBQVNNLG1CQUFtQkMsT0FBTztJQUNqQyxNQUFNLENBQUNDLFFBQVFDLGNBQWMsR0FBR0YsUUFBUXZGLEtBQUssQ0FBQztJQUM5QyxNQUFNMEYsV0FBV0YsT0FBT3hGLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDQSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDbkQsSUFBSTBGLFlBQVksUUFBUUQsaUJBQWlCLE1BQU07UUFDN0MsTUFBTSxJQUFJeE4sTUFBTTtJQUNsQjtJQUNBLElBQUk7UUFDRixPQUFPME4sT0FBT0MsSUFBSSxDQUFDSDtJQUNyQixFQUFFLE9BQU96QyxPQUFPO1FBQ2QsTUFBTSxJQUFJL0ssTUFBTSxDQUFDLHVCQUF1QixDQUFDO0lBQzNDO0FBQ0Y7QUFFQSwwQ0FBMEM7QUFDMUMsU0FBUzROLDZCQUE2QjdFLGVBQWU7SUFDbkQsT0FBT0EsbUJBQW1CLE9BQU8sS0FBSyxJQUFJQSxnQkFBZ0JDLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQztRQUNyRSxJQUFJUDtRQUNKLE9BQU9TLEtBQUtILEdBQUcsQ0FBQ0EsS0FBSyxDQUFDTixLQUFLTyxlQUFlSixJQUFJLEtBQUssT0FBT0gsS0FBSztJQUNqRSxHQUFHO0FBQ0w7QUFFQSwyQkFBMkI7QUFDM0IsU0FBU2tGLGdCQUFnQnhFLE9BQU87SUFDOUIsSUFBSVY7SUFDSixPQUFPLENBQUNBLEtBQUtVLFFBQVFHLEtBQUssS0FBSyxPQUFPYixLQUFLO1dBQ3RDVSxRQUFRTixlQUFlLEdBQUdNLFFBQVFOLGVBQWUsQ0FBQzNILEdBQUcsQ0FBQyxDQUFDOEgsaUJBQW9CO2dCQUM1RWpKLE1BQU07Z0JBQ05pSjtZQUNGLE1BQU0sRUFBRTtXQUNMRyxRQUFRaUIsU0FBUyxHQUFHO1lBQUM7Z0JBQUVySyxNQUFNO2dCQUFhcUssV0FBV2pCLFFBQVFpQixTQUFTO1lBQUM7U0FBRSxHQUFHLEVBQUU7V0FDOUVqQixRQUFRN0ksT0FBTyxHQUFHO1lBQUM7Z0JBQUVQLE1BQU07Z0JBQVFVLE1BQU0wSSxRQUFRN0ksT0FBTztZQUFDO1NBQUUsR0FBRyxFQUFFO0tBQ3BFO0FBQ0g7QUFFQSw0QkFBNEI7QUFDNUIsU0FBU3NOLGlCQUFpQkMsUUFBUTtJQUNoQyxPQUFPQSxTQUFTM00sR0FBRyxDQUFDLENBQUNpSSxVQUFhO1lBQ2hDLEdBQUdBLE9BQU87WUFDVkcsT0FBT3FFLGdCQUFnQnhFO1FBQ3pCO0FBQ0Y7QUFFQSw0QkFBNEI7QUFDNUIsU0FBUzJFLGdCQUFnQkMsSUFBSSxFQUFFQyxJQUFJO0lBQ2pDLElBQUlELFNBQVNDLE1BQ1gsT0FBTztJQUNULElBQUlELFFBQVEsUUFBUUMsUUFBUSxNQUMxQixPQUFPO0lBQ1QsSUFBSSxPQUFPRCxTQUFTLFlBQVksT0FBT0MsU0FBUyxVQUM5QyxPQUFPRCxTQUFTQztJQUNsQixJQUFJRCxLQUFLRSxXQUFXLEtBQUtELEtBQUtDLFdBQVcsRUFDdkMsT0FBTztJQUNULElBQUlGLGdCQUFnQnhGLFFBQVF5RixnQkFBZ0J6RixNQUFNO1FBQ2hELE9BQU93RixLQUFLRyxPQUFPLE9BQU9GLEtBQUtFLE9BQU87SUFDeEM7SUFDQSxJQUFJOU4sTUFBTUMsT0FBTyxDQUFDME4sT0FBTztRQUN2QixJQUFJQSxLQUFLMUssTUFBTSxLQUFLMkssS0FBSzNLLE1BQU0sRUFDN0IsT0FBTztRQUNULElBQUssSUFBSU4sSUFBSSxHQUFHQSxJQUFJZ0wsS0FBSzFLLE1BQU0sRUFBRU4sSUFBSztZQUNwQyxJQUFJLENBQUMrSyxnQkFBZ0JDLElBQUksQ0FBQ2hMLEVBQUUsRUFBRWlMLElBQUksQ0FBQ2pMLEVBQUUsR0FDbkMsT0FBTztRQUNYO1FBQ0EsT0FBTztJQUNUO0lBQ0EsTUFBTW9MLFFBQVE1SSxPQUFPNkksSUFBSSxDQUFDTDtJQUMxQixNQUFNTSxRQUFROUksT0FBTzZJLElBQUksQ0FBQ0o7SUFDMUIsSUFBSUcsTUFBTTlLLE1BQU0sS0FBS2dMLE1BQU1oTCxNQUFNLEVBQy9CLE9BQU87SUFDVCxLQUFLLE1BQU1pTCxPQUFPSCxNQUFPO1FBQ3ZCLElBQUksQ0FBQ0UsTUFBTTNNLFFBQVEsQ0FBQzRNLE1BQ2xCLE9BQU87UUFDVCxJQUFJLENBQUNSLGdCQUFnQkMsSUFBSSxDQUFDTyxJQUFJLEVBQUVOLElBQUksQ0FBQ00sSUFBSSxHQUN2QyxPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1Q7QUFFQSx5Q0FBeUM7QUFDekMsZUFBZUMsNkJBQTZCQyxzQkFBc0I7SUFDaEUsSUFBSSxDQUFDQSx3QkFBd0I7UUFDM0IsT0FBTyxFQUFFO0lBQ1g7SUFDQSxJQUFJQSxrQ0FBa0NDLFVBQVU7UUFDOUMsT0FBT0MsUUFBUUMsR0FBRyxDQUNoQnZPLE1BQU13TyxJQUFJLENBQUNKLHdCQUF3QnROLEdBQUcsQ0FBQyxPQUFPMk47WUFDNUMsTUFBTSxFQUFFbFAsSUFBSSxFQUFFSSxJQUFJLEVBQUUsR0FBRzhPO1lBQ3ZCLE1BQU16QixVQUFVLE1BQU0sSUFBSXNCLFFBQVEsQ0FBQ0ksU0FBU0M7Z0JBQzFDLE1BQU16SCxTQUFTLElBQUkwSDtnQkFDbkIxSCxPQUFPMkgsTUFBTSxHQUFHLENBQUNDO29CQUNmLElBQUl6RztvQkFDSnFHLFFBQVEsQ0FBQ3JHLEtBQUt5RyxZQUFZQyxNQUFNLEtBQUssT0FBTyxLQUFLLElBQUkxRyxHQUFHL0UsTUFBTTtnQkFDaEU7Z0JBQ0E0RCxPQUFPOEgsT0FBTyxHQUFHLENBQUN2RSxRQUFVa0UsT0FBT2xFO2dCQUNuQ3ZELE9BQU8rSCxhQUFhLENBQUNSO1lBQ3ZCO1lBQ0EsT0FBTztnQkFDTGxQO2dCQUNBMlAsYUFBYXZQO2dCQUNid1AsS0FBS25DO1lBQ1A7UUFDRjtJQUVKO0lBQ0EsSUFBSWhOLE1BQU1DLE9BQU8sQ0FBQ21PLHlCQUF5QjtRQUN6QyxPQUFPQTtJQUNUO0lBQ0EsTUFBTSxJQUFJMU8sTUFBTTtBQUNsQjtBQUVBLGtDQUFrQztBQUNsQyxJQUFJMFAsV0FBVyxLQUFLMUosVUFBVSxDQUFDO0FBQy9CLFNBQVMySixjQUFjekosTUFBTSxFQUFFQyxXQUFXO0lBQ3hDLE1BQU1DLHFCQUFxQixJQUFJQyxXQUFXRjtJQUMxQyxJQUFJRyxTQUFTO0lBQ2IsS0FBSyxNQUFNQyxTQUFTTCxPQUFRO1FBQzFCRSxtQkFBbUJJLEdBQUcsQ0FBQ0QsT0FBT0Q7UUFDOUJBLFVBQVVDLE1BQU1oRCxNQUFNO0lBQ3hCO0lBQ0EyQyxPQUFPM0MsTUFBTSxHQUFHO0lBQ2hCLE9BQU82QztBQUNUO0FBQ0EsZUFBZXdKLHVCQUF1QixFQUNwQ2xKLE1BQU0sRUFDTkMsVUFBVSxFQUNWSSxXQUFXLEVBQ1g4SSxzQkFBc0IsRUFDdEJDLDBCQUEwQixFQUMxQkMsaUJBQWlCLEVBQ2xCO0lBQ0MsTUFBTXZJLFNBQVNkLE9BQU9lLFNBQVM7SUFDL0IsTUFBTUMsVUFBVSxJQUFJQztJQUNwQixNQUFNekIsU0FBUyxFQUFFO0lBQ2pCLElBQUlDLGNBQWM7SUFDbEIsTUFBTyxLQUFNO1FBQ1gsTUFBTSxFQUFFcEcsS0FBSyxFQUFFLEdBQUcsTUFBTXlILE9BQU9JLElBQUk7UUFDbkMsSUFBSTdILE9BQU87WUFDVG1HLE9BQU85QyxJQUFJLENBQUNyRDtZQUNab0csZUFBZXBHLE1BQU13RCxNQUFNO1lBQzNCLElBQUl4RCxLQUFLLENBQUNBLE1BQU13RCxNQUFNLEdBQUcsRUFBRSxLQUFLbU0sVUFBVTtnQkFDeEM7WUFDRjtRQUNGO1FBQ0EsSUFBSXhKLE9BQU8zQyxNQUFNLEtBQUssR0FBRztZQUN2QjtRQUNGO1FBQ0EsTUFBTTZDLHFCQUFxQnVKLGNBQWN6SixRQUFRQztRQUNqREEsY0FBYztRQUNkLE1BQU0wQixjQUFjSCxRQUFRSSxNQUFNLENBQUMxQixvQkFBb0I7WUFBRU0sUUFBUTtRQUFLLEdBQUdxQixLQUFLLENBQUMsTUFBTUMsTUFBTSxDQUFDLENBQUN6RyxPQUFTQSxTQUFTLElBQUlILEdBQUcsQ0FBQ0U7UUFDdkgsS0FBSyxNQUFNLEVBQUVyQixJQUFJLEVBQUVGLE9BQU9rSSxNQUFNLEVBQUUsSUFBSUosWUFBYTtZQUNqRCxPQUFRNUg7Z0JBQ04sS0FBSztvQkFDSCxNQUFPMEcsQ0FBQUEsY0FBYyxPQUFPLEtBQUssSUFBSUEsV0FBV3NCLE9BQU07b0JBQ3REO2dCQUNGLEtBQUs7b0JBQ0gsTUFBT2xCLENBQUFBLGVBQWUsT0FBTyxLQUFLLElBQUlBLFlBQVlrQixPQUFNO29CQUN4RDtnQkFDRixLQUFLO29CQUNILE1BQU80SCxDQUFBQSwwQkFBMEIsT0FBTyxLQUFLLElBQUlBLHVCQUF1QjVILE9BQU07b0JBQzlFO2dCQUNGLEtBQUs7b0JBQ0gsTUFBTzZILENBQUFBLDhCQUE4QixPQUFPLEtBQUssSUFBSUEsMkJBQTJCN0gsT0FBTTtvQkFDdEY7Z0JBQ0YsS0FBSztvQkFDSCxNQUFPOEgsQ0FBQUEscUJBQXFCLE9BQU8sS0FBSyxJQUFJQSxrQkFBa0I5SCxPQUFNO29CQUNwRTtnQkFDRjtvQkFBUzt3QkFDUCxNQUFNQyxrQkFBa0JqSTt3QkFDeEIsTUFBTSxJQUFJRCxNQUFNLENBQUMsMEJBQTBCLEVBQUVrSSxnQkFBZ0IsQ0FBQztvQkFDaEU7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLGdCQUFnQjtBQUN5QztBQUV6RCxvQkFBb0I7QUFDNkI7QUFDakQsU0FBU2dJLFVBQVVDLFVBQVUsRUFBRUMsT0FBTztJQUNwQyxJQUFJekg7SUFDSixNQUFNMEgsZ0JBQWdCLENBQUMxSCxLQUFLeUgsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUUMsYUFBYSxLQUFLLE9BQU8xSCxLQUFLO0lBQzdGLE9BQU8ySCxXQUNMTCw4REFBZUEsQ0FBQ0UsWUFBWTtRQUMxQkksY0FBY0YsZ0JBQWdCLFNBQVM7UUFDdkNoQixRQUFRO0lBRVYsSUFDQTtRQUNFbUIsVUFBVSxDQUFDelE7WUFDVCxNQUFNNkQsU0FBU3VNLFdBQVdNLFNBQVMsQ0FBQzFRO1lBQ3BDLE9BQU82RCxPQUFPSSxPQUFPLEdBQUc7Z0JBQUVBLFNBQVM7Z0JBQU1qRSxPQUFPNkQsT0FBT2tHLElBQUk7WUFBQyxJQUFJO2dCQUFFOUYsU0FBUztnQkFBTytHLE9BQU9uSCxPQUFPbUgsS0FBSztZQUFDO1FBQ3hHO0lBQ0Y7QUFFSjtBQUVBLGdCQUFnQjtBQUNoQixJQUFJMkYsZUFBZUMsT0FBT0MsR0FBRyxDQUFDO0FBQzlCLFNBQVNOLFdBQVdPLFdBQVcsRUFBRSxFQUMvQkwsUUFBUSxFQUNULEdBQUcsQ0FBQyxDQUFDO0lBQ0osT0FBTztRQUNMLENBQUNFLGFBQWEsRUFBRTtRQUNoQkksT0FBTyxLQUFLO1FBQ1osZ0NBQWdDO1FBQ2hDLENBQUNkLG1FQUFlQSxDQUFDLEVBQUU7UUFDbkJNLFlBQVlPO1FBQ1pMO0lBQ0Y7QUFDRjtBQUNBLFNBQVNPLFNBQVNoUixLQUFLO0lBQ3JCLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEyUSxnQkFBZ0IzUSxTQUFTQSxLQUFLLENBQUMyUSxhQUFhLEtBQUssUUFBUSxnQkFBZ0IzUSxTQUFTLGNBQWNBO0FBQ3hKO0FBQ0EsU0FBU2lSLFNBQVNDLE1BQU07SUFDdEIsT0FBT0YsU0FBU0UsVUFBVUEsU0FBU2YsVUFBVWU7QUFDL0M7QUFFQSxrQ0FBa0M7QUFDbEMsU0FBU0MsdUJBQXVCLEVBQzlCQyw2QkFBNkIsRUFDN0JDLG9CQUFvQixFQUNwQkMsUUFBUSxFQUNSdEQsUUFBUSxFQUNUO0lBQ0MsSUFBSXBGO0lBQ0osTUFBTUQsY0FBY3FGLFFBQVEsQ0FBQ0EsU0FBU3hLLE1BQU0sR0FBRyxFQUFFO0lBQ2pELE9BQ0UsbUNBQW1DO0lBQ25DOE4sV0FBVyxLQUFLLGtDQUFrQztJQUNsRDNJLGVBQWUsUUFBUSxtRkFBbUY7SUFDekdxRixDQUFBQSxTQUFTeEssTUFBTSxHQUFHNk4sd0JBQXdCeEQsNkJBQTZCbEYsWUFBWUssZUFBZSxNQUFNb0ksNkJBQTRCLEtBQU0sb0NBQW9DO0lBQy9LRyx5Q0FBeUM1SSxnQkFBZ0IsNkNBQTZDO0lBQ3RHLENBQUM2SSxtQ0FBbUM3SSxnQkFDcEMsdUNBRDJGO0lBQzFGLEVBQUNDLEtBQUtpRiw2QkFBNkJsRixZQUFZSyxlQUFlLE1BQU0sT0FBT0osS0FBSyxLQUFLMEk7QUFFMUY7QUFDQSxTQUFTRSxtQ0FBbUNsSSxPQUFPO0lBQ2pELElBQUltSSxzQ0FBc0M7SUFDMUNuSSxRQUFRRyxLQUFLLENBQUNpSSxPQUFPLENBQUMsQ0FBQ3BRO1FBQ3JCLElBQUlBLEtBQUtwQixJQUFJLEtBQUssUUFBUTtZQUN4QnVSLHNDQUFzQztRQUN4QztRQUNBLElBQUluUSxLQUFLcEIsSUFBSSxLQUFLLG1CQUFtQjtZQUNuQ3VSLHNDQUFzQztRQUN4QztJQUNGO0lBQ0EsT0FBT0E7QUFDVDtBQUNBLFNBQVNGLHlDQUF5Q2pJLE9BQU87SUFDdkQsT0FBT0EsUUFBUWhKLElBQUksS0FBSyxlQUFlZ0osUUFBUUcsS0FBSyxDQUFDeEIsTUFBTSxDQUFDLENBQUMzRyxPQUFTQSxLQUFLcEIsSUFBSSxLQUFLLG1CQUFtQlEsS0FBSyxDQUFDLENBQUNZLE9BQVMsWUFBWUEsS0FBSzZILGNBQWM7QUFDeEo7QUFFQSxpQ0FBaUM7QUFDakMsU0FBU3dJLHFCQUFxQixFQUM1QjNELFFBQVEsRUFDUnpKLFVBQVUsRUFDVnFOLFlBQVkvTixNQUFNLEVBQ25CO0lBQ0MsSUFBSStFO0lBQ0osTUFBTUQsY0FBY3FGLFFBQVEsQ0FBQ0EsU0FBU3hLLE1BQU0sR0FBRyxFQUFFO0lBQ2pELE1BQU1xTyxpQkFBaUJsSixZQUFZYyxLQUFLLENBQUN0SCxJQUFJLENBQzNDLENBQUNiLE9BQVNBLEtBQUtwQixJQUFJLEtBQUsscUJBQXFCb0IsS0FBSzZILGNBQWMsQ0FBQzVFLFVBQVUsS0FBS0E7SUFFbEYsSUFBSXNOLGtCQUFrQixNQUFNO1FBQzFCO0lBQ0Y7SUFDQSxNQUFNRCxhQUFhO1FBQ2pCLEdBQUdDLGVBQWUxSSxjQUFjO1FBQ2hDckYsT0FBTztRQUNQRDtJQUNGO0lBQ0FnTyxlQUFlMUksY0FBYyxHQUFHeUk7SUFDaENqSixZQUFZSyxlQUFlLEdBQUcsQ0FBQ0osS0FBS0QsWUFBWUssZUFBZSxLQUFLLE9BQU8sS0FBSyxJQUFJSixHQUFHdkgsR0FBRyxDQUN4RixDQUFDOEgsaUJBQW1CQSxlQUFlNUUsVUFBVSxLQUFLQSxhQUFhcU4sYUFBYXpJO0FBRWhGO0FBeUJFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hlcmxvZy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AYWktc2RrL3VpLXV0aWxzL2Rpc3QvaW5kZXgubWpzPzc4M2IiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2Fzc2lzdGFudC1zdHJlYW0tcGFydHMudHNcbnZhciB0ZXh0U3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIwXCIsXG4gIG5hbWU6IFwidGV4dFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInRleHRcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIGVycm9yU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIzXCIsXG4gIG5hbWU6IFwiZXJyb3JcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJlcnJvclwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjRcIixcbiAgbmFtZTogXCJhc3Npc3RhbnRfbWVzc2FnZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJpZFwiIGluIHZhbHVlKSB8fCAhKFwicm9sZVwiIGluIHZhbHVlKSB8fCAhKFwiY29udGVudFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuaWQgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLnJvbGUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUucm9sZSAhPT0gXCJhc3Npc3RhbnRcIiB8fCAhQXJyYXkuaXNBcnJheSh2YWx1ZS5jb250ZW50KSB8fCAhdmFsdWUuY29udGVudC5ldmVyeShcbiAgICAgIChpdGVtKSA9PiBpdGVtICE9IG51bGwgJiYgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiYgXCJ0eXBlXCIgaW4gaXRlbSAmJiBpdGVtLnR5cGUgPT09IFwidGV4dFwiICYmIFwidGV4dFwiIGluIGl0ZW0gJiYgaXRlbS50ZXh0ICE9IG51bGwgJiYgdHlwZW9mIGl0ZW0udGV4dCA9PT0gXCJvYmplY3RcIiAmJiBcInZhbHVlXCIgaW4gaXRlbS50ZXh0ICYmIHR5cGVvZiBpdGVtLnRleHQudmFsdWUgPT09IFwic3RyaW5nXCJcbiAgICApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGFuIFwiaWRcIiwgXCJyb2xlXCIsIGFuZCBcImNvbnRlbnRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhc3Npc3RhbnRfbWVzc2FnZVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI1XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0aHJlYWRJZFwiIGluIHZhbHVlKSB8fCAhKFwibWVzc2FnZUlkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50aHJlYWRJZCAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUubWVzc2FnZUlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRocmVhZElkXCIgYW5kIFwibWVzc2FnZUlkXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdGhyZWFkSWQ6IHZhbHVlLnRocmVhZElkLFxuICAgICAgICBtZXNzYWdlSWQ6IHZhbHVlLm1lc3NhZ2VJZFxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG52YXIgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjZcIixcbiAgbmFtZTogXCJkYXRhX21lc3NhZ2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwicm9sZVwiIGluIHZhbHVlKSB8fCAhKFwiZGF0YVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUucm9sZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZS5yb2xlICE9PSBcImRhdGFcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJkYXRhX21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInJvbGVcIiBhbmQgXCJkYXRhXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZGF0YV9tZXNzYWdlXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50U3RyZWFtUGFydHMgPSBbXG4gIHRleHRTdHJlYW1QYXJ0LFxuICBlcnJvclN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIGRhdGFNZXNzYWdlU3RyZWFtUGFydFxuXTtcbnZhciBhc3Npc3RhbnRTdHJlYW1QYXJ0c0J5Q29kZSA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0LmNvZGVdOiB0ZXh0U3RyZWFtUGFydCxcbiAgW2Vycm9yU3RyZWFtUGFydC5jb2RlXTogZXJyb3JTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydFxufTtcbnZhciBTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0Lm5hbWVdOiB0ZXh0U3RyZWFtUGFydC5jb2RlLFxuICBbZXJyb3JTdHJlYW1QYXJ0Lm5hbWVdOiBlcnJvclN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGVcbn07XG52YXIgdmFsaWRDb2RlcyA9IGFzc2lzdGFudFN0cmVhbVBhcnRzLm1hcCgocGFydCkgPT4gcGFydC5jb2RlKTtcbnZhciBwYXJzZUFzc2lzdGFudFN0cmVhbVBhcnQgPSAobGluZSkgPT4ge1xuICBjb25zdCBmaXJzdFNlcGFyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGZpcnN0U2VwYXJhdG9ySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIE5vIHNlcGFyYXRvciBmb3VuZC5cIik7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gbGluZS5zbGljZSgwLCBmaXJzdFNlcGFyYXRvckluZGV4KTtcbiAgaWYgKCF2YWxpZENvZGVzLmluY2x1ZGVzKHByZWZpeCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBJbnZhbGlkIGNvZGUgJHtwcmVmaXh9LmApO1xuICB9XG4gIGNvbnN0IGNvZGUgPSBwcmVmaXg7XG4gIGNvbnN0IHRleHRWYWx1ZSA9IGxpbmUuc2xpY2UoZmlyc3RTZXBhcmF0b3JJbmRleCArIDEpO1xuICBjb25zdCBqc29uVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG4gIHJldHVybiBhc3Npc3RhbnRTdHJlYW1QYXJ0c0J5Q29kZVtjb2RlXS5wYXJzZShqc29uVmFsdWUpO1xufTtcbmZ1bmN0aW9uIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQodHlwZSwgdmFsdWUpIHtcbiAgY29uc3Qgc3RyZWFtUGFydCA9IGFzc2lzdGFudFN0cmVhbVBhcnRzLmZpbmQoKHBhcnQpID0+IHBhcnQubmFtZSA9PT0gdHlwZSk7XG4gIGlmICghc3RyZWFtUGFydCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdHJlYW0gcGFydCB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbiAgcmV0dXJuIGAke3N0cmVhbVBhcnQuY29kZX06JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XG5gO1xufVxuXG4vLyBzcmMvcHJvY2Vzcy1jaGF0LXJlc3BvbnNlLnRzXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRGdW5jdGlvbiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9kdXBsaWNhdGVkL3VzYWdlLnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2Uoe1xuICBwcm9tcHRUb2tlbnMsXG4gIGNvbXBsZXRpb25Ub2tlbnNcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHRUb2tlbnMsXG4gICAgY29tcGxldGlvblRva2VucyxcbiAgICB0b3RhbFRva2VuczogcHJvbXB0VG9rZW5zICsgY29tcGxldGlvblRva2Vuc1xuICB9O1xufVxuXG4vLyBzcmMvcGFyc2UtcGFydGlhbC1qc29uLnRzXG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2ZpeC1qc29uLnRzXG5mdW5jdGlvbiBmaXhKc29uKGlucHV0KSB7XG4gIGNvbnN0IHN0YWNrID0gW1wiUk9PVFwiXTtcbiAgbGV0IGxhc3RWYWxpZEluZGV4ID0gLTE7XG4gIGxldCBsaXRlcmFsU3RhcnQgPSBudWxsO1xuICBmdW5jdGlvbiBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBzd2FwU3RhdGUpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR1wiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICBjYXNlIFwiblwiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIGxpdGVyYWxTdGFydCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTElURVJBTFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiLVwiOiB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgIGNhc2UgXCI4XCI6XG4gICAgICAgIGNhc2UgXCI5XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ7XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX1NUQVJUXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJbXCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfU1RBUlRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSkge1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKSB7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgc3dpdGNoIChjdXJyZW50U3RhdGUpIHtcbiAgICAgIGNhc2UgXCJST09UXCI6XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiRklOSVNIXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX1NUQVJUXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0tFWVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiOlwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXFxcXFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR19FU0NBUEVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfU1RBUlRcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HX0VTQ0FQRVwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9OVU1CRVJcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgICBjYXNlIFwiOVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVcIjpcbiAgICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgY2FzZSBcIi5cIjoge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9MSVRFUkFMXCI6IHtcbiAgICAgICAgY29uc3QgcGFydGlhbExpdGVyYWwgPSBpbnB1dC5zdWJzdHJpbmcobGl0ZXJhbFN0YXJ0LCBpICsgMSk7XG4gICAgICAgIGlmICghXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpICYmICFcInRydWVcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSAmJiAhXCJudWxsXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCByZXN1bHQgPSBpbnB1dC5zbGljZSgwLCBsYXN0VmFsaWRJbmRleCArIDEpO1xuICBmb3IgKGxldCBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0YWNrW2ldO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9ICdcIic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfS0VZXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9TVEFSVFwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHJlc3VsdCArPSBcIn1cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX1NUQVJUXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTElURVJBTFwiOiB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxMaXRlcmFsID0gaW5wdXQuc3Vic3RyaW5nKGxpdGVyYWxTdGFydCwgaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgaWYgKFwidHJ1ZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwidHJ1ZVwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwiZmFsc2VcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKFwibnVsbFwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwibnVsbFwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3BhcnNlLXBhcnRpYWwtanNvbi50c1xuZnVuY3Rpb24gcGFyc2VQYXJ0aWFsSnNvbihqc29uVGV4dCkge1xuICBpZiAoanNvblRleHQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB2b2lkIDAsIHN0YXRlOiBcInVuZGVmaW5lZC1pbnB1dFwiIH07XG4gIH1cbiAgbGV0IHJlc3VsdCA9IHNhZmVQYXJzZUpTT04oeyB0ZXh0OiBqc29uVGV4dCB9KTtcbiAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdC52YWx1ZSwgc3RhdGU6IFwic3VjY2Vzc2Z1bC1wYXJzZVwiIH07XG4gIH1cbiAgcmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7IHRleHQ6IGZpeEpzb24oanNvblRleHQpIH0pO1xuICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LnZhbHVlLCBzdGF0ZTogXCJyZXBhaXJlZC1wYXJzZVwiIH07XG4gIH1cbiAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCwgc3RhdGU6IFwiZmFpbGVkLXBhcnNlXCIgfTtcbn1cblxuLy8gc3JjL2RhdGEtc3RyZWFtLXBhcnRzLnRzXG52YXIgdGV4dFN0cmVhbVBhcnQyID0ge1xuICBjb2RlOiBcIjBcIixcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGV4dFwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMlwiLFxuICBuYW1lOiBcImRhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJkYXRhXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBlcnJvclN0cmVhbVBhcnQyID0ge1xuICBjb2RlOiBcIjNcIixcbiAgbmFtZTogXCJlcnJvclwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImVycm9yXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI4XCIsXG4gIG5hbWU6IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiBwYXJ0cyBleHBlY3QgYW4gYXJyYXkgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIHRvb2xDYWxsU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI5XCIsXG4gIG5hbWU6IFwidG9vbF9jYWxsXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRvb2xDYWxsSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xDYWxsSWQgIT09IFwic3RyaW5nXCIgfHwgIShcInRvb2xOYW1lXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sTmFtZSAhPT0gXCJzdHJpbmdcIiB8fCAhKFwiYXJnc1wiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuYXJncyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX2NhbGxcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRvb2xDYWxsSWRcIiwgXCJ0b29sTmFtZVwiLCBhbmQgXCJhcmdzXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgdG9vbFJlc3VsdFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiYVwiLFxuICBuYW1lOiBcInRvb2xfcmVzdWx0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRvb2xDYWxsSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xDYWxsSWQgIT09IFwic3RyaW5nXCIgfHwgIShcInJlc3VsdFwiIGluIHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX3Jlc3VsdFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidG9vbENhbGxJZFwiIGFuZCBhIFwicmVzdWx0XCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9yZXN1bHRcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciB0b29sQ2FsbFN0cmVhbWluZ1N0YXJ0U3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJiXCIsXG4gIG5hbWU6IFwidG9vbF9jYWxsX3N0cmVhbWluZ19zdGFydFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sQ2FsbElkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sQ2FsbElkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJ0b29sTmFtZVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsX3N0cmVhbWluZ19zdGFydFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidG9vbENhbGxJZFwiIGFuZCBcInRvb2xOYW1lXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsX3N0cmVhbWluZ19zdGFydFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHRvb2xDYWxsRGVsdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImNcIixcbiAgbmFtZTogXCJ0b29sX2NhbGxfZGVsdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbENhbGxJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbENhbGxJZCAhPT0gXCJzdHJpbmdcIiB8fCAhKFwiYXJnc1RleHREZWx0YVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuYXJnc1RleHREZWx0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX2NhbGxfZGVsdGFcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRvb2xDYWxsSWRcIiBhbmQgXCJhcmdzVGV4dERlbHRhXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsX2RlbHRhXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgZmluaXNoTWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiZFwiLFxuICBuYW1lOiBcImZpbmlzaF9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImZpbmlzaFJlYXNvblwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuZmluaXNoUmVhc29uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZpbmlzaF9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmaW5pc2hSZWFzb25cIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBmaW5pc2hSZWFzb246IHZhbHVlLmZpbmlzaFJlYXNvblxuICAgIH07XG4gICAgaWYgKFwidXNhZ2VcIiBpbiB2YWx1ZSAmJiB2YWx1ZS51c2FnZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS51c2FnZSA9PT0gXCJvYmplY3RcIiAmJiBcInByb21wdFRva2Vuc1wiIGluIHZhbHVlLnVzYWdlICYmIFwiY29tcGxldGlvblRva2Vuc1wiIGluIHZhbHVlLnVzYWdlKSB7XG4gICAgICByZXN1bHQudXNhZ2UgPSB7XG4gICAgICAgIHByb21wdFRva2VuczogdHlwZW9mIHZhbHVlLnVzYWdlLnByb21wdFRva2VucyA9PT0gXCJudW1iZXJcIiA/IHZhbHVlLnVzYWdlLnByb21wdFRva2VucyA6IE51bWJlci5OYU4sXG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IHR5cGVvZiB2YWx1ZS51c2FnZS5jb21wbGV0aW9uVG9rZW5zID09PSBcIm51bWJlclwiID8gdmFsdWUudXNhZ2UuY29tcGxldGlvblRva2VucyA6IE51bWJlci5OYU5cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImZpbmlzaF9tZXNzYWdlXCIsXG4gICAgICB2YWx1ZTogcmVzdWx0XG4gICAgfTtcbiAgfVxufTtcbnZhciBmaW5pc2hTdGVwU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJlXCIsXG4gIG5hbWU6IFwiZmluaXNoX3N0ZXBcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiZmluaXNoUmVhc29uXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5maW5pc2hSZWFzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZmluaXNoX3N0ZXBcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImZpbmlzaFJlYXNvblwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGZpbmlzaFJlYXNvbjogdmFsdWUuZmluaXNoUmVhc29uLFxuICAgICAgaXNDb250aW51ZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAoXCJ1c2FnZVwiIGluIHZhbHVlICYmIHZhbHVlLnVzYWdlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnVzYWdlID09PSBcIm9iamVjdFwiICYmIFwicHJvbXB0VG9rZW5zXCIgaW4gdmFsdWUudXNhZ2UgJiYgXCJjb21wbGV0aW9uVG9rZW5zXCIgaW4gdmFsdWUudXNhZ2UpIHtcbiAgICAgIHJlc3VsdC51c2FnZSA9IHtcbiAgICAgICAgcHJvbXB0VG9rZW5zOiB0eXBlb2YgdmFsdWUudXNhZ2UucHJvbXB0VG9rZW5zID09PSBcIm51bWJlclwiID8gdmFsdWUudXNhZ2UucHJvbXB0VG9rZW5zIDogTnVtYmVyLk5hTixcbiAgICAgICAgY29tcGxldGlvblRva2VuczogdHlwZW9mIHZhbHVlLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgPT09IFwibnVtYmVyXCIgPyB2YWx1ZS51c2FnZS5jb21wbGV0aW9uVG9rZW5zIDogTnVtYmVyLk5hTlxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKFwiaXNDb250aW51ZWRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuaXNDb250aW51ZWQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXN1bHQuaXNDb250aW51ZWQgPSB2YWx1ZS5pc0NvbnRpbnVlZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZmluaXNoX3N0ZXBcIixcbiAgICAgIHZhbHVlOiByZXN1bHRcbiAgICB9O1xuICB9XG59O1xudmFyIHN0YXJ0U3RlcFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiZlwiLFxuICBuYW1lOiBcInN0YXJ0X3N0ZXBcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwibWVzc2FnZUlkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5tZXNzYWdlSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wic3RhcnRfc3RlcFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3RhcnRfc3RlcFwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgbWVzc2FnZUlkOiB2YWx1ZS5tZXNzYWdlSWRcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xudmFyIHJlYXNvbmluZ1N0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiZ1wiLFxuICBuYW1lOiBcInJlYXNvbmluZ1wiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInJlYXNvbmluZ1wiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJyZWFzb25pbmdcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBzb3VyY2VQYXJ0ID0ge1xuICBjb2RlOiBcImhcIixcbiAgbmFtZTogXCJzb3VyY2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNvdXJjZVwiIHBhcnRzIGV4cGVjdCBhIFNvdXJjZSBvYmplY3QuJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNvdXJjZVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFTdHJlYW1QYXJ0cyA9IFtcbiAgdGV4dFN0cmVhbVBhcnQyLFxuICBkYXRhU3RyZWFtUGFydCxcbiAgZXJyb3JTdHJlYW1QYXJ0MixcbiAgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1QYXJ0LFxuICB0b29sUmVzdWx0U3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1pbmdTdGFydFN0cmVhbVBhcnQsXG4gIHRvb2xDYWxsRGVsdGFTdHJlYW1QYXJ0LFxuICBmaW5pc2hNZXNzYWdlU3RyZWFtUGFydCxcbiAgZmluaXNoU3RlcFN0cmVhbVBhcnQsXG4gIHN0YXJ0U3RlcFN0cmVhbVBhcnQsXG4gIHJlYXNvbmluZ1N0cmVhbVBhcnQsXG4gIHNvdXJjZVBhcnRcbl07XG52YXIgZGF0YVN0cmVhbVBhcnRzQnlDb2RlID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICBkYXRhU3RyZWFtUGFydHMubWFwKChwYXJ0KSA9PiBbcGFydC5jb2RlLCBwYXJ0XSlcbik7XG52YXIgRGF0YVN0cmVhbVN0cmluZ1ByZWZpeGVzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICBkYXRhU3RyZWFtUGFydHMubWFwKChwYXJ0KSA9PiBbcGFydC5uYW1lLCBwYXJ0LmNvZGVdKVxuKTtcbnZhciB2YWxpZENvZGVzMiA9IGRhdGFTdHJlYW1QYXJ0cy5tYXAoKHBhcnQpID0+IHBhcnQuY29kZSk7XG52YXIgcGFyc2VEYXRhU3RyZWFtUGFydCA9IChsaW5lKSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gTm8gc2VwYXJhdG9yIGZvdW5kLlwiKTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuICBpZiAoIXZhbGlkQ29kZXMyLmluY2x1ZGVzKHByZWZpeCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBJbnZhbGlkIGNvZGUgJHtwcmVmaXh9LmApO1xuICB9XG4gIGNvbnN0IGNvZGUgPSBwcmVmaXg7XG4gIGNvbnN0IHRleHRWYWx1ZSA9IGxpbmUuc2xpY2UoZmlyc3RTZXBhcmF0b3JJbmRleCArIDEpO1xuICBjb25zdCBqc29uVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG4gIHJldHVybiBkYXRhU3RyZWFtUGFydHNCeUNvZGVbY29kZV0ucGFyc2UoanNvblZhbHVlKTtcbn07XG5mdW5jdGlvbiBmb3JtYXREYXRhU3RyZWFtUGFydCh0eXBlLCB2YWx1ZSkge1xuICBjb25zdCBzdHJlYW1QYXJ0ID0gZGF0YVN0cmVhbVBhcnRzLmZpbmQoKHBhcnQpID0+IHBhcnQubmFtZSA9PT0gdHlwZSk7XG4gIGlmICghc3RyZWFtUGFydCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdHJlYW0gcGFydCB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbiAgcmV0dXJuIGAke3N0cmVhbVBhcnQuY29kZX06JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XG5gO1xufVxuXG4vLyBzcmMvcHJvY2Vzcy1kYXRhLXN0cmVhbS50c1xudmFyIE5FV0xJTkUgPSBcIlxcblwiLmNoYXJDb2RlQXQoMCk7XG5mdW5jdGlvbiBjb25jYXRDaHVua3MoY2h1bmtzLCB0b3RhbExlbmd0aCkge1xuICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgIGNvbmNhdGVuYXRlZENodW5rcy5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuICBjaHVua3MubGVuZ3RoID0gMDtcbiAgcmV0dXJuIGNvbmNhdGVuYXRlZENodW5rcztcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NEYXRhU3RyZWFtKHtcbiAgc3RyZWFtLFxuICBvblRleHRQYXJ0LFxuICBvblJlYXNvbmluZ1BhcnQsXG4gIG9uU291cmNlUGFydCxcbiAgb25EYXRhUGFydCxcbiAgb25FcnJvclBhcnQsXG4gIG9uVG9vbENhbGxTdHJlYW1pbmdTdGFydFBhcnQsXG4gIG9uVG9vbENhbGxEZWx0YVBhcnQsXG4gIG9uVG9vbENhbGxQYXJ0LFxuICBvblRvb2xSZXN1bHRQYXJ0LFxuICBvbk1lc3NhZ2VBbm5vdGF0aW9uc1BhcnQsXG4gIG9uRmluaXNoTWVzc2FnZVBhcnQsXG4gIG9uRmluaXNoU3RlcFBhcnQsXG4gIG9uU3RhcnRTdGVwUGFydFxufSkge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBjb25jYXRDaHVua3MoY2h1bmtzLCB0b3RhbExlbmd0aCk7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGNvbnN0IHN0cmVhbVBhcnRzID0gZGVjb2Rlci5kZWNvZGUoY29uY2F0ZW5hdGVkQ2h1bmtzLCB7IHN0cmVhbTogdHJ1ZSB9KS5zcGxpdChcIlxcblwiKS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT09IFwiXCIpLm1hcChwYXJzZURhdGFTdHJlYW1QYXJ0KTtcbiAgICBmb3IgKGNvbnN0IHsgdHlwZSwgdmFsdWU6IHZhbHVlMiB9IG9mIHN0cmVhbVBhcnRzKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICBhd2FpdCAob25UZXh0UGFydCA9PSBudWxsID8gdm9pZCAwIDogb25UZXh0UGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOlxuICAgICAgICAgIGF3YWl0IChvblJlYXNvbmluZ1BhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUmVhc29uaW5nUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNvdXJjZVwiOlxuICAgICAgICAgIGF3YWl0IChvblNvdXJjZVBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uU291cmNlUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICBhd2FpdCAob25EYXRhUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25EYXRhUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgYXdhaXQgKG9uRXJyb3JQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIjpcbiAgICAgICAgICBhd2FpdCAob25NZXNzYWdlQW5ub3RhdGlvbnNQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbk1lc3NhZ2VBbm5vdGF0aW9uc1BhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b29sX2NhbGxfc3RyZWFtaW5nX3N0YXJ0XCI6XG4gICAgICAgICAgYXdhaXQgKG9uVG9vbENhbGxTdHJlYW1pbmdTdGFydFBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uVG9vbENhbGxTdHJlYW1pbmdTdGFydFBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b29sX2NhbGxfZGVsdGFcIjpcbiAgICAgICAgICBhd2FpdCAob25Ub29sQ2FsbERlbHRhUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25Ub29sQ2FsbERlbHRhUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRvb2xfY2FsbFwiOlxuICAgICAgICAgIGF3YWl0IChvblRvb2xDYWxsUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25Ub29sQ2FsbFBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b29sX3Jlc3VsdFwiOlxuICAgICAgICAgIGF3YWl0IChvblRvb2xSZXN1bHRQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblRvb2xSZXN1bHRQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZmluaXNoX21lc3NhZ2VcIjpcbiAgICAgICAgICBhd2FpdCAob25GaW5pc2hNZXNzYWdlUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2hNZXNzYWdlUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImZpbmlzaF9zdGVwXCI6XG4gICAgICAgICAgYXdhaXQgKG9uRmluaXNoU3RlcFBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoU3RlcFBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdGFydF9zdGVwXCI6XG4gICAgICAgICAgYXdhaXQgKG9uU3RhcnRTdGVwUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25TdGFydFN0ZXBQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gdHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RyZWFtIHBhcnQgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL3Byb2Nlc3MtY2hhdC1yZXNwb25zZS50c1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NoYXRSZXNwb25zZSh7XG4gIHN0cmVhbSxcbiAgdXBkYXRlLFxuICBvblRvb2xDYWxsLFxuICBvbkZpbmlzaCxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBnZW5lcmF0ZUlkRnVuY3Rpb24sXG4gIGdldEN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gIGxhc3RNZXNzYWdlXG59KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHJlcGxhY2VMYXN0TWVzc2FnZSA9IChsYXN0TWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbGFzdE1lc3NhZ2Uucm9sZSkgPT09IFwiYXNzaXN0YW50XCI7XG4gIGxldCBzdGVwID0gcmVwbGFjZUxhc3RNZXNzYWdlID8gMSArIC8vIGZpbmQgbWF4IHN0ZXAgaW4gZXhpc3RpbmcgdG9vbCBpbnZvY2F0aW9uczpcbiAgKChfYiA9IChfYSA9IGxhc3RNZXNzYWdlLnRvb2xJbnZvY2F0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlZHVjZSgobWF4LCB0b29sSW52b2NhdGlvbikgPT4ge1xuICAgIHZhciBfYTI7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1heCwgKF9hMiA9IHRvb2xJbnZvY2F0aW9uLnN0ZXApICE9IG51bGwgPyBfYTIgOiAwKTtcbiAgfSwgMCkpICE9IG51bGwgPyBfYiA6IDApIDogMDtcbiAgY29uc3QgbWVzc2FnZSA9IHJlcGxhY2VMYXN0TWVzc2FnZSA/IHN0cnVjdHVyZWRDbG9uZShsYXN0TWVzc2FnZSkgOiB7XG4gICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgY3JlYXRlZEF0OiBnZXRDdXJyZW50RGF0ZSgpLFxuICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgY29udGVudDogXCJcIixcbiAgICBwYXJ0czogW11cbiAgfTtcbiAgbGV0IGN1cnJlbnRUZXh0UGFydCA9IHZvaWQgMDtcbiAgbGV0IGN1cnJlbnRSZWFzb25pbmdQYXJ0ID0gdm9pZCAwO1xuICBmdW5jdGlvbiB1cGRhdGVUb29sSW52b2NhdGlvblBhcnQodG9vbENhbGxJZCwgaW52b2NhdGlvbikge1xuICAgIGNvbnN0IHBhcnQgPSBtZXNzYWdlLnBhcnRzLmZpbmQoXG4gICAgICAocGFydDIpID0+IHBhcnQyLnR5cGUgPT09IFwidG9vbC1pbnZvY2F0aW9uXCIgJiYgcGFydDIudG9vbEludm9jYXRpb24udG9vbENhbGxJZCA9PT0gdG9vbENhbGxJZFxuICAgICk7XG4gICAgaWYgKHBhcnQgIT0gbnVsbCkge1xuICAgICAgcGFydC50b29sSW52b2NhdGlvbiA9IGludm9jYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidG9vbC1pbnZvY2F0aW9uXCIsXG4gICAgICAgIHRvb2xJbnZvY2F0aW9uOiBpbnZvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGF0YSA9IFtdO1xuICBsZXQgbWVzc2FnZUFubm90YXRpb25zID0gcmVwbGFjZUxhc3RNZXNzYWdlID8gbGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLmFubm90YXRpb25zIDogdm9pZCAwO1xuICBjb25zdCBwYXJ0aWFsVG9vbENhbGxzID0ge307XG4gIGxldCB1c2FnZSA9IHtcbiAgICBjb21wbGV0aW9uVG9rZW5zOiBOYU4sXG4gICAgcHJvbXB0VG9rZW5zOiBOYU4sXG4gICAgdG90YWxUb2tlbnM6IE5hTlxuICB9O1xuICBsZXQgZmluaXNoUmVhc29uID0gXCJ1bmtub3duXCI7XG4gIGZ1bmN0aW9uIGV4ZWNVcGRhdGUoKSB7XG4gICAgY29uc3QgY29waWVkRGF0YSA9IFsuLi5kYXRhXTtcbiAgICBpZiAobWVzc2FnZUFubm90YXRpb25zID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlQW5ub3RhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBtZXNzYWdlLmFubm90YXRpb25zID0gbWVzc2FnZUFubm90YXRpb25zO1xuICAgIH1cbiAgICBjb25zdCBjb3BpZWRNZXNzYWdlID0ge1xuICAgICAgLy8gZGVlcCBjb3B5IHRoZSBtZXNzYWdlIHRvIGVuc3VyZSB0aGF0IGRlZXAgY2hhbmdlcyAobXNnIGF0dGFjaG1lbnRzKSBhcmUgdXBkYXRlZFxuICAgICAgLy8gd2l0aCBTb2xpZEpTLiBTb2xpZEpTIHVzZXMgcmVmZXJlbnRpYWwgaW50ZWdyYXRpb24gb2Ygc3ViLW9iamVjdHMgdG8gZGV0ZWN0IGNoYW5nZXMuXG4gICAgICAuLi5zdHJ1Y3R1cmVkQ2xvbmUobWVzc2FnZSksXG4gICAgICAvLyBhZGQgYSByZXZpc2lvbiBpZCB0byBlbnN1cmUgdGhhdCB0aGUgbWVzc2FnZSBpcyB1cGRhdGVkIHdpdGggU1dSLiBTV1IgdXNlcyBhXG4gICAgICAvLyBoYXNoaW5nIGFwcHJvYWNoIGJ5IGRlZmF1bHQgdG8gZGV0ZWN0IGNoYW5nZXMsIGJ1dCBpdCBvbmx5IHdvcmtzIGZvciBzaGFsbG93XG4gICAgICAvLyBjaGFuZ2VzLiBUaGlzIGlzIHdoeSB3ZSBuZWVkIHRvIGFkZCBhIHJldmlzaW9uIGlkIHRvIGVuc3VyZSB0aGF0IHRoZSBtZXNzYWdlXG4gICAgICAvLyBpcyB1cGRhdGVkIHdpdGggU1dSICh3aXRob3V0IGl0LCB0aGUgY2hhbmdlcyBnZXQgc3R1Y2sgaW4gU1dSIGFuZCBhcmUgbm90XG4gICAgICAvLyBmb3J3YXJkZWQgdG8gcmVuZGVyaW5nKTpcbiAgICAgIHJldmlzaW9uSWQ6IGdlbmVyYXRlSWQyKClcbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICBtZXNzYWdlOiBjb3BpZWRNZXNzYWdlLFxuICAgICAgZGF0YTogY29waWVkRGF0YSxcbiAgICAgIHJlcGxhY2VMYXN0TWVzc2FnZVxuICAgIH0pO1xuICB9XG4gIGF3YWl0IHByb2Nlc3NEYXRhU3RyZWFtKHtcbiAgICBzdHJlYW0sXG4gICAgb25UZXh0UGFydCh2YWx1ZSkge1xuICAgICAgaWYgKGN1cnJlbnRUZXh0UGFydCA9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRUZXh0UGFydCA9IHtcbiAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICB0ZXh0OiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBtZXNzYWdlLnBhcnRzLnB1c2goY3VycmVudFRleHRQYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRUZXh0UGFydC50ZXh0ICs9IHZhbHVlO1xuICAgICAgfVxuICAgICAgbWVzc2FnZS5jb250ZW50ICs9IHZhbHVlO1xuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgIH0sXG4gICAgb25SZWFzb25pbmdQYXJ0KHZhbHVlKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKGN1cnJlbnRSZWFzb25pbmdQYXJ0ID09IG51bGwpIHtcbiAgICAgICAgY3VycmVudFJlYXNvbmluZ1BhcnQgPSB7XG4gICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICByZWFzb25pbmc6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIG1lc3NhZ2UucGFydHMucHVzaChjdXJyZW50UmVhc29uaW5nUGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50UmVhc29uaW5nUGFydC5yZWFzb25pbmcgKz0gdmFsdWU7XG4gICAgICB9XG4gICAgICBtZXNzYWdlLnJlYXNvbmluZyA9ICgoX2EyID0gbWVzc2FnZS5yZWFzb25pbmcpICE9IG51bGwgPyBfYTIgOiBcIlwiKSArIHZhbHVlO1xuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgIH0sXG4gICAgb25Tb3VyY2VQYXJ0KHZhbHVlKSB7XG4gICAgICBtZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInNvdXJjZVwiLFxuICAgICAgICBzb3VyY2U6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGV4ZWNVcGRhdGUoKTtcbiAgICB9LFxuICAgIG9uVG9vbENhbGxTdHJlYW1pbmdTdGFydFBhcnQodmFsdWUpIHtcbiAgICAgIGlmIChtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG1lc3NhZ2UudG9vbEludm9jYXRpb25zID0gW107XG4gICAgICB9XG4gICAgICBwYXJ0aWFsVG9vbENhbGxzW3ZhbHVlLnRvb2xDYWxsSWRdID0ge1xuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBzdGVwLFxuICAgICAgICB0b29sTmFtZTogdmFsdWUudG9vbE5hbWUsXG4gICAgICAgIGluZGV4OiBtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucy5sZW5ndGhcbiAgICAgIH07XG4gICAgICBjb25zdCBpbnZvY2F0aW9uID0ge1xuICAgICAgICBzdGF0ZTogXCJwYXJ0aWFsLWNhbGxcIixcbiAgICAgICAgc3RlcCxcbiAgICAgICAgdG9vbENhbGxJZDogdmFsdWUudG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWU6IHZhbHVlLnRvb2xOYW1lLFxuICAgICAgICBhcmdzOiB2b2lkIDBcbiAgICAgIH07XG4gICAgICBtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucy5wdXNoKGludm9jYXRpb24pO1xuICAgICAgdXBkYXRlVG9vbEludm9jYXRpb25QYXJ0KHZhbHVlLnRvb2xDYWxsSWQsIGludm9jYXRpb24pO1xuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgIH0sXG4gICAgb25Ub29sQ2FsbERlbHRhUGFydCh2YWx1ZSkge1xuICAgICAgY29uc3QgcGFydGlhbFRvb2xDYWxsID0gcGFydGlhbFRvb2xDYWxsc1t2YWx1ZS50b29sQ2FsbElkXTtcbiAgICAgIHBhcnRpYWxUb29sQ2FsbC50ZXh0ICs9IHZhbHVlLmFyZ3NUZXh0RGVsdGE7XG4gICAgICBjb25zdCB7IHZhbHVlOiBwYXJ0aWFsQXJncyB9ID0gcGFyc2VQYXJ0aWFsSnNvbihwYXJ0aWFsVG9vbENhbGwudGV4dCk7XG4gICAgICBjb25zdCBpbnZvY2F0aW9uID0ge1xuICAgICAgICBzdGF0ZTogXCJwYXJ0aWFsLWNhbGxcIixcbiAgICAgICAgc3RlcDogcGFydGlhbFRvb2xDYWxsLnN0ZXAsXG4gICAgICAgIHRvb2xDYWxsSWQ6IHZhbHVlLnRvb2xDYWxsSWQsXG4gICAgICAgIHRvb2xOYW1lOiBwYXJ0aWFsVG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgIGFyZ3M6IHBhcnRpYWxBcmdzXG4gICAgICB9O1xuICAgICAgbWVzc2FnZS50b29sSW52b2NhdGlvbnNbcGFydGlhbFRvb2xDYWxsLmluZGV4XSA9IGludm9jYXRpb247XG4gICAgICB1cGRhdGVUb29sSW52b2NhdGlvblBhcnQodmFsdWUudG9vbENhbGxJZCwgaW52b2NhdGlvbik7XG4gICAgICBleGVjVXBkYXRlKCk7XG4gICAgfSxcbiAgICBhc3luYyBvblRvb2xDYWxsUGFydCh2YWx1ZSkge1xuICAgICAgY29uc3QgaW52b2NhdGlvbiA9IHtcbiAgICAgICAgc3RhdGU6IFwiY2FsbFwiLFxuICAgICAgICBzdGVwLFxuICAgICAgICAuLi52YWx1ZVxuICAgICAgfTtcbiAgICAgIGlmIChwYXJ0aWFsVG9vbENhbGxzW3ZhbHVlLnRvb2xDYWxsSWRdICE9IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZS50b29sSW52b2NhdGlvbnNbcGFydGlhbFRvb2xDYWxsc1t2YWx1ZS50b29sQ2FsbElkXS5pbmRleF0gPSBpbnZvY2F0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudG9vbEludm9jYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICBtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UudG9vbEludm9jYXRpb25zLnB1c2goaW52b2NhdGlvbik7XG4gICAgICB9XG4gICAgICB1cGRhdGVUb29sSW52b2NhdGlvblBhcnQodmFsdWUudG9vbENhbGxJZCwgaW52b2NhdGlvbik7XG4gICAgICBleGVjVXBkYXRlKCk7XG4gICAgICBpZiAob25Ub29sQ2FsbCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvblRvb2xDYWxsKHsgdG9vbENhbGw6IHZhbHVlIH0pO1xuICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBpbnZvY2F0aW9uMiA9IHtcbiAgICAgICAgICAgIHN0YXRlOiBcInJlc3VsdFwiLFxuICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBtZXNzYWdlLnRvb2xJbnZvY2F0aW9uc1ttZXNzYWdlLnRvb2xJbnZvY2F0aW9ucy5sZW5ndGggLSAxXSA9IGludm9jYXRpb24yO1xuICAgICAgICAgIHVwZGF0ZVRvb2xJbnZvY2F0aW9uUGFydCh2YWx1ZS50b29sQ2FsbElkLCBpbnZvY2F0aW9uMik7XG4gICAgICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvblRvb2xSZXN1bHRQYXJ0KHZhbHVlKSB7XG4gICAgICBjb25zdCB0b29sSW52b2NhdGlvbnMgPSBtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucztcbiAgICAgIGlmICh0b29sSW52b2NhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b29sX3Jlc3VsdCBtdXN0IGJlIHByZWNlZGVkIGJ5IGEgdG9vbF9jYWxsXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9vbEludm9jYXRpb25JbmRleCA9IHRvb2xJbnZvY2F0aW9ucy5maW5kSW5kZXgoXG4gICAgICAgIChpbnZvY2F0aW9uMikgPT4gaW52b2NhdGlvbjIudG9vbENhbGxJZCA9PT0gdmFsdWUudG9vbENhbGxJZFxuICAgICAgKTtcbiAgICAgIGlmICh0b29sSW52b2NhdGlvbkluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJ0b29sX3Jlc3VsdCBtdXN0IGJlIHByZWNlZGVkIGJ5IGEgdG9vbF9jYWxsIHdpdGggdGhlIHNhbWUgdG9vbENhbGxJZFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbnZvY2F0aW9uID0ge1xuICAgICAgICAuLi50b29sSW52b2NhdGlvbnNbdG9vbEludm9jYXRpb25JbmRleF0sXG4gICAgICAgIHN0YXRlOiBcInJlc3VsdFwiLFxuICAgICAgICAuLi52YWx1ZVxuICAgICAgfTtcbiAgICAgIHRvb2xJbnZvY2F0aW9uc1t0b29sSW52b2NhdGlvbkluZGV4XSA9IGludm9jYXRpb247XG4gICAgICB1cGRhdGVUb29sSW52b2NhdGlvblBhcnQodmFsdWUudG9vbENhbGxJZCwgaW52b2NhdGlvbik7XG4gICAgICBleGVjVXBkYXRlKCk7XG4gICAgfSxcbiAgICBvbkRhdGFQYXJ0KHZhbHVlKSB7XG4gICAgICBkYXRhLnB1c2goLi4udmFsdWUpO1xuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgIH0sXG4gICAgb25NZXNzYWdlQW5ub3RhdGlvbnNQYXJ0KHZhbHVlKSB7XG4gICAgICBpZiAobWVzc2FnZUFubm90YXRpb25zID09IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZUFubm90YXRpb25zID0gWy4uLnZhbHVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2VBbm5vdGF0aW9ucy5wdXNoKC4uLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGV4ZWNVcGRhdGUoKTtcbiAgICB9LFxuICAgIG9uRmluaXNoU3RlcFBhcnQodmFsdWUpIHtcbiAgICAgIHN0ZXAgKz0gMTtcbiAgICAgIGN1cnJlbnRUZXh0UGFydCA9IHZhbHVlLmlzQ29udGludWVkID8gY3VycmVudFRleHRQYXJ0IDogdm9pZCAwO1xuICAgICAgY3VycmVudFJlYXNvbmluZ1BhcnQgPSB2b2lkIDA7XG4gICAgfSxcbiAgICBvblN0YXJ0U3RlcFBhcnQodmFsdWUpIHtcbiAgICAgIGlmICghcmVwbGFjZUxhc3RNZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSB2YWx1ZS5tZXNzYWdlSWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkZpbmlzaE1lc3NhZ2VQYXJ0KHZhbHVlKSB7XG4gICAgICBmaW5pc2hSZWFzb24gPSB2YWx1ZS5maW5pc2hSZWFzb247XG4gICAgICBpZiAodmFsdWUudXNhZ2UgIT0gbnVsbCkge1xuICAgICAgICB1c2FnZSA9IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSh2YWx1ZS51c2FnZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkVycm9yUGFydChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0pO1xuICBvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goeyBtZXNzYWdlLCBmaW5pc2hSZWFzb24sIHVzYWdlIH0pO1xufVxuXG4vLyBzcmMvcHJvY2Vzcy1jaGF0LXRleHQtcmVzcG9uc2UudHNcbmltcG9ydCB7IGdlbmVyYXRlSWQgYXMgZ2VuZXJhdGVJZEZ1bmN0aW9uMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9wcm9jZXNzLXRleHQtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzVGV4dFN0cmVhbSh7XG4gIHN0cmVhbSxcbiAgb25UZXh0UGFydFxufSkge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLmdldFJlYWRlcigpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBhd2FpdCBvblRleHRQYXJ0KHZhbHVlKTtcbiAgfVxufVxuXG4vLyBzcmMvcHJvY2Vzcy1jaGF0LXRleHQtcmVzcG9uc2UudHNcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDaGF0VGV4dFJlc3BvbnNlKHtcbiAgc3RyZWFtLFxuICB1cGRhdGUsXG4gIG9uRmluaXNoLFxuICBnZXRDdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IGdlbmVyYXRlSWRGdW5jdGlvbjJcbn0pIHtcbiAgY29uc3QgdGV4dFBhcnQgPSB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBcIlwiIH07XG4gIGNvbnN0IHJlc3VsdE1lc3NhZ2UgPSB7XG4gICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgY3JlYXRlZEF0OiBnZXRDdXJyZW50RGF0ZSgpLFxuICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgY29udGVudDogXCJcIixcbiAgICBwYXJ0czogW3RleHRQYXJ0XVxuICB9O1xuICBhd2FpdCBwcm9jZXNzVGV4dFN0cmVhbSh7XG4gICAgc3RyZWFtLFxuICAgIG9uVGV4dFBhcnQ6IChjaHVuaykgPT4ge1xuICAgICAgcmVzdWx0TWVzc2FnZS5jb250ZW50ICs9IGNodW5rO1xuICAgICAgdGV4dFBhcnQudGV4dCArPSBjaHVuaztcbiAgICAgIHVwZGF0ZSh7XG4gICAgICAgIG1lc3NhZ2U6IHsgLi4ucmVzdWx0TWVzc2FnZSB9LFxuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgcmVwbGFjZUxhc3RNZXNzYWdlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgb25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHJlc3VsdE1lc3NhZ2UsIHtcbiAgICB1c2FnZTogeyBjb21wbGV0aW9uVG9rZW5zOiBOYU4sIHByb21wdFRva2VuczogTmFOLCB0b3RhbFRva2VuczogTmFOIH0sXG4gICAgZmluaXNoUmVhc29uOiBcInVua25vd25cIlxuICB9KTtcbn1cblxuLy8gc3JjL2NhbGwtY2hhdC1hcGkudHNcbnZhciBnZXRPcmlnaW5hbEZldGNoID0gKCkgPT4gZmV0Y2g7XG5hc3luYyBmdW5jdGlvbiBjYWxsQ2hhdEFwaSh7XG4gIGFwaSxcbiAgYm9keSxcbiAgc3RyZWFtUHJvdG9jb2wgPSBcImRhdGFcIixcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGFib3J0Q29udHJvbGxlcixcbiAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlLFxuICBvblJlc3BvbnNlLFxuICBvblVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIG9uVG9vbENhbGwsXG4gIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyLFxuICBmZXRjaDogZmV0Y2gyID0gZ2V0T3JpZ2luYWxGZXRjaCgpLFxuICBsYXN0TWVzc2FnZVxufSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMihhcGksIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgLi4uaGVhZGVyc1xuICAgIH0sXG4gICAgc2lnbmFsOiAoX2EgPSBhYm9ydENvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlcigpKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2lnbmFsLFxuICAgIGNyZWRlbnRpYWxzXG4gIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xuICBpZiAob25SZXNwb25zZSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIChfYiA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9iIDogXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICApO1xuICB9XG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgfVxuICBzd2l0Y2ggKHN0cmVhbVByb3RvY29sKSB7XG4gICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgYXdhaXQgcHJvY2Vzc0NoYXRUZXh0UmVzcG9uc2Uoe1xuICAgICAgICBzdHJlYW06IHJlc3BvbnNlLmJvZHksXG4gICAgICAgIHVwZGF0ZTogb25VcGRhdGUsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMlxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhc2UgXCJkYXRhXCI6IHtcbiAgICAgIGF3YWl0IHByb2Nlc3NDaGF0UmVzcG9uc2Uoe1xuICAgICAgICBzdHJlYW06IHJlc3BvbnNlLmJvZHksXG4gICAgICAgIHVwZGF0ZTogb25VcGRhdGUsXG4gICAgICAgIGxhc3RNZXNzYWdlLFxuICAgICAgICBvblRvb2xDYWxsLFxuICAgICAgICBvbkZpbmlzaCh7IG1lc3NhZ2UsIGZpbmlzaFJlYXNvbiwgdXNhZ2UgfSkge1xuICAgICAgICAgIGlmIChvbkZpbmlzaCAmJiBtZXNzYWdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9uRmluaXNoKG1lc3NhZ2UsIHsgdXNhZ2UsIGZpbmlzaFJlYXNvbiB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gc3RyZWFtUHJvdG9jb2w7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RyZWFtIHByb3RvY29sOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL2NhbGwtY29tcGxldGlvbi1hcGkudHNcbnZhciBnZXRPcmlnaW5hbEZldGNoMiA9ICgpID0+IGZldGNoO1xuYXN5bmMgZnVuY3Rpb24gY2FsbENvbXBsZXRpb25BcGkoe1xuICBhcGksXG4gIHByb21wdCxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIHN0cmVhbVByb3RvY29sID0gXCJkYXRhXCIsXG4gIHNldENvbXBsZXRpb24sXG4gIHNldExvYWRpbmcsXG4gIHNldEVycm9yLFxuICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBvbkRhdGEsXG4gIGZldGNoOiBmZXRjaDIgPSBnZXRPcmlnaW5hbEZldGNoMigpXG59KSB7XG4gIHZhciBfYTtcbiAgdHJ5IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKHZvaWQgMCk7XG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHNldEFib3J0Q29udHJvbGxlcihhYm9ydENvbnRyb2xsZXIpO1xuICAgIHNldENvbXBsZXRpb24oXCJcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaDIoYXBpLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIC4uLmJvZHlcbiAgICAgIH0pLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5oZWFkZXJzXG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICAgIGlmIChvblJlc3BvbnNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgKF9hID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpKSAhPSBudWxsID8gX2EgOiBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIHN3aXRjaCAoc3RyZWFtUHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgYXdhaXQgcHJvY2Vzc1RleHRTdHJlYW0oe1xuICAgICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgICBvblRleHRQYXJ0OiAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaHVuaztcbiAgICAgICAgICAgIHNldENvbXBsZXRpb24ocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkYXRhXCI6IHtcbiAgICAgICAgYXdhaXQgcHJvY2Vzc0RhdGFTdHJlYW0oe1xuICAgICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgICBvblRleHRQYXJ0KHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICAgICAgICBzZXRDb21wbGV0aW9uKHJlc3VsdCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkRhdGFQYXJ0KHZhbHVlKSB7XG4gICAgICAgICAgICBvbkRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRGF0YSh2YWx1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkVycm9yUGFydCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gc3RyZWFtUHJvdG9jb2w7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gcHJvdG9jb2w6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHByb21wdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0RXJyb3IoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgfVxufVxuXG4vLyBzcmMvZGF0YS11cmwudHNcbmZ1bmN0aW9uIGdldFRleHRGcm9tRGF0YVVybChkYXRhVXJsKSB7XG4gIGNvbnN0IFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gZGF0YVVybC5zcGxpdChcIixcIik7XG4gIGNvbnN0IG1pbWVUeXBlID0gaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV07XG4gIGlmIChtaW1lVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSBVUkwgZm9ybWF0XCIpO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5hdG9iKGJhc2U2NENvbnRlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjb2RpbmcgZGF0YSBVUkxgKTtcbiAgfVxufVxuXG4vLyBzcmMvZXh0cmFjdC1tYXgtdG9vbC1pbnZvY2F0aW9uLXN0ZXAudHNcbmZ1bmN0aW9uIGV4dHJhY3RNYXhUb29sSW52b2NhdGlvblN0ZXAodG9vbEludm9jYXRpb25zKSB7XG4gIHJldHVybiB0b29sSW52b2NhdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xJbnZvY2F0aW9ucy5yZWR1Y2UoKG1heCwgdG9vbEludm9jYXRpb24pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1heCwgKF9hID0gdG9vbEludm9jYXRpb24uc3RlcCkgIT0gbnVsbCA/IF9hIDogMCk7XG4gIH0sIDApO1xufVxuXG4vLyBzcmMvZ2V0LW1lc3NhZ2UtcGFydHMudHNcbmZ1bmN0aW9uIGdldE1lc3NhZ2VQYXJ0cyhtZXNzYWdlKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IG1lc3NhZ2UucGFydHMpICE9IG51bGwgPyBfYSA6IFtcbiAgICAuLi5tZXNzYWdlLnRvb2xJbnZvY2F0aW9ucyA/IG1lc3NhZ2UudG9vbEludm9jYXRpb25zLm1hcCgodG9vbEludm9jYXRpb24pID0+ICh7XG4gICAgICB0eXBlOiBcInRvb2wtaW52b2NhdGlvblwiLFxuICAgICAgdG9vbEludm9jYXRpb25cbiAgICB9KSkgOiBbXSxcbiAgICAuLi5tZXNzYWdlLnJlYXNvbmluZyA/IFt7IHR5cGU6IFwicmVhc29uaW5nXCIsIHJlYXNvbmluZzogbWVzc2FnZS5yZWFzb25pbmcgfV0gOiBbXSxcbiAgICAuLi5tZXNzYWdlLmNvbnRlbnQgPyBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dIDogW11cbiAgXTtcbn1cblxuLy8gc3JjL2ZpbGwtbWVzc2FnZS1wYXJ0cy50c1xuZnVuY3Rpb24gZmlsbE1lc3NhZ2VQYXJ0cyhtZXNzYWdlcykge1xuICByZXR1cm4gbWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiAoe1xuICAgIC4uLm1lc3NhZ2UsXG4gICAgcGFydHM6IGdldE1lc3NhZ2VQYXJ0cyhtZXNzYWdlKVxuICB9KSk7XG59XG5cbi8vIHNyYy9pcy1kZWVwLWVxdWFsLWRhdGEudHNcbmZ1bmN0aW9uIGlzRGVlcEVxdWFsRGF0YShvYmoxLCBvYmoyKSB7XG4gIGlmIChvYmoxID09PSBvYmoyKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAob2JqMSA9PSBudWxsIHx8IG9iajIgPT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2Ygb2JqMSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqMiAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gb2JqMSA9PT0gb2JqMjtcbiAgaWYgKG9iajEuY29uc3RydWN0b3IgIT09IG9iajIuY29uc3RydWN0b3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAob2JqMSBpbnN0YW5jZW9mIERhdGUgJiYgb2JqMiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gb2JqMS5nZXRUaW1lKCkgPT09IG9iajIuZ2V0VGltZSgpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9iajEpKSB7XG4gICAgaWYgKG9iajEubGVuZ3RoICE9PSBvYmoyLmxlbmd0aClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iajEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghaXNEZWVwRXF1YWxEYXRhKG9iajFbaV0sIG9iajJbaV0pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG4gIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG4gIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMxKSB7XG4gICAgaWYgKCFrZXlzMi5pbmNsdWRlcyhrZXkpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghaXNEZWVwRXF1YWxEYXRhKG9iajFba2V5XSwgb2JqMltrZXldKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gc3JjL3ByZXBhcmUtYXR0YWNobWVudHMtZm9yLXJlcXVlc3QudHNcbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVBdHRhY2htZW50c0ZvclJlcXVlc3QoYXR0YWNobWVudHNGcm9tT3B0aW9ucykge1xuICBpZiAoIWF0dGFjaG1lbnRzRnJvbU9wdGlvbnMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKGF0dGFjaG1lbnRzRnJvbU9wdGlvbnMgaW5zdGFuY2VvZiBGaWxlTGlzdCkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIEFycmF5LmZyb20oYXR0YWNobWVudHNGcm9tT3B0aW9ucykubWFwKGFzeW5jIChhdHRhY2htZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgdHlwZSB9ID0gYXR0YWNobWVudDtcbiAgICAgICAgY29uc3QgZGF0YVVybCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAocmVhZGVyRXZlbnQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJlc29sdmUoKF9hID0gcmVhZGVyRXZlbnQudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVzdWx0KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gKGVycm9yKSA9PiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGF0dGFjaG1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGNvbnRlbnRUeXBlOiB0eXBlLFxuICAgICAgICAgIHVybDogZGF0YVVybFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGF0dGFjaG1lbnRzRnJvbU9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGF0dGFjaG1lbnRzRnJvbU9wdGlvbnM7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhdHRhY2htZW50cyB0eXBlXCIpO1xufVxuXG4vLyBzcmMvcHJvY2Vzcy1hc3Npc3RhbnQtc3RyZWFtLnRzXG52YXIgTkVXTElORTIgPSBcIlxcblwiLmNoYXJDb2RlQXQoMCk7XG5mdW5jdGlvbiBjb25jYXRDaHVua3MyKGNodW5rcywgdG90YWxMZW5ndGgpIHtcbiAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgY2h1bmtzLmxlbmd0aCA9IDA7XG4gIHJldHVybiBjb25jYXRlbmF0ZWRDaHVua3M7XG59XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzQXNzaXN0YW50U3RyZWFtKHtcbiAgc3RyZWFtLFxuICBvblRleHRQYXJ0LFxuICBvbkVycm9yUGFydCxcbiAgb25Bc3Npc3RhbnRNZXNzYWdlUGFydCxcbiAgb25Bc3Npc3RhbnRDb250cm9sRGF0YVBhcnQsXG4gIG9uRGF0YU1lc3NhZ2VQYXJ0XG59KSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgICAgdG90YWxMZW5ndGggKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICE9PSBORVdMSU5FMikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBjb25jYXRDaHVua3MyKGNodW5rcywgdG90YWxMZW5ndGgpO1xuICAgIHRvdGFsTGVuZ3RoID0gMDtcbiAgICBjb25zdCBzdHJlYW1QYXJ0cyA9IGRlY29kZXIuZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKS5tYXAocGFyc2VBc3Npc3RhbnRTdHJlYW1QYXJ0KTtcbiAgICBmb3IgKGNvbnN0IHsgdHlwZSwgdmFsdWU6IHZhbHVlMiB9IG9mIHN0cmVhbVBhcnRzKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICBhd2FpdCAob25UZXh0UGFydCA9PSBudWxsID8gdm9pZCAwIDogb25UZXh0UGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgYXdhaXQgKG9uRXJyb3JQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFzc2lzdGFudF9tZXNzYWdlXCI6XG4gICAgICAgICAgYXdhaXQgKG9uQXNzaXN0YW50TWVzc2FnZVBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQXNzaXN0YW50TWVzc2FnZVBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCI6XG4gICAgICAgICAgYXdhaXQgKG9uQXNzaXN0YW50Q29udHJvbERhdGFQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbkFzc2lzdGFudENvbnRyb2xEYXRhUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRhdGFfbWVzc2FnZVwiOlxuICAgICAgICAgIGF3YWl0IChvbkRhdGFNZXNzYWdlUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25EYXRhTWVzc2FnZVBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSB0eXBlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gcGFydCB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvc2NoZW1hLnRzXG5pbXBvcnQgeyB2YWxpZGF0b3JTeW1ib2wgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvem9kLXNjaGVtYS50c1xuaW1wb3J0IHpvZFRvSnNvblNjaGVtYSBmcm9tIFwiem9kLXRvLWpzb24tc2NoZW1hXCI7XG5mdW5jdGlvbiB6b2RTY2hlbWEoem9kU2NoZW1hMiwgb3B0aW9ucykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHVzZVJlZmVyZW5jZXMgPSAoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnVzZVJlZmVyZW5jZXMpICE9IG51bGwgPyBfYSA6IGZhbHNlO1xuICByZXR1cm4ganNvblNjaGVtYShcbiAgICB6b2RUb0pzb25TY2hlbWEoem9kU2NoZW1hMiwge1xuICAgICAgJHJlZlN0cmF0ZWd5OiB1c2VSZWZlcmVuY2VzID8gXCJyb290XCIgOiBcIm5vbmVcIixcbiAgICAgIHRhcmdldDogXCJqc29uU2NoZW1hN1wiXG4gICAgICAvLyBub3RlOiBvcGVuYWkgbW9kZSBicmVha3MgdmFyaW91cyBnZW1pbmkgY29udmVyc2lvbnNcbiAgICB9KSxcbiAgICB7XG4gICAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHpvZFNjaGVtYTIuc2FmZVBhcnNlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0LmRhdGEgfSA6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByZXN1bHQuZXJyb3IgfTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cbi8vIHNyYy9zY2hlbWEudHNcbnZhciBzY2hlbWFTeW1ib2wgPSBTeW1ib2wuZm9yKFwidmVyY2VsLmFpLnNjaGVtYVwiKTtcbmZ1bmN0aW9uIGpzb25TY2hlbWEoanNvblNjaGVtYTIsIHtcbiAgdmFsaWRhdGVcbn0gPSB7fSkge1xuICByZXR1cm4ge1xuICAgIFtzY2hlbWFTeW1ib2xdOiB0cnVlLFxuICAgIF90eXBlOiB2b2lkIDAsXG4gICAgLy8gc2hvdWxkIG5ldmVyIGJlIHVzZWQgZGlyZWN0bHlcbiAgICBbdmFsaWRhdG9yU3ltYm9sXTogdHJ1ZSxcbiAgICBqc29uU2NoZW1hOiBqc29uU2NoZW1hMixcbiAgICB2YWxpZGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gaXNTY2hlbWEodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBzY2hlbWFTeW1ib2wgaW4gdmFsdWUgJiYgdmFsdWVbc2NoZW1hU3ltYm9sXSA9PT0gdHJ1ZSAmJiBcImpzb25TY2hlbWFcIiBpbiB2YWx1ZSAmJiBcInZhbGlkYXRlXCIgaW4gdmFsdWU7XG59XG5mdW5jdGlvbiBhc1NjaGVtYShzY2hlbWEpIHtcbiAgcmV0dXJuIGlzU2NoZW1hKHNjaGVtYSkgPyBzY2hlbWEgOiB6b2RTY2hlbWEoc2NoZW1hKTtcbn1cblxuLy8gc3JjL3Nob3VsZC1yZXN1Ym1pdC1tZXNzYWdlcy50c1xuZnVuY3Rpb24gc2hvdWxkUmVzdWJtaXRNZXNzYWdlcyh7XG4gIG9yaWdpbmFsTWF4VG9vbEludm9jYXRpb25TdGVwLFxuICBvcmlnaW5hbE1lc3NhZ2VDb3VudCxcbiAgbWF4U3RlcHMsXG4gIG1lc3NhZ2VzXG59KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIChcbiAgICAvLyBjaGVjayBpZiB0aGUgZmVhdHVyZSBpcyBlbmFibGVkOlxuICAgIG1heFN0ZXBzID4gMSAmJiAvLyBlbnN1cmUgdGhlcmUgaXMgYSBsYXN0IG1lc3NhZ2U6XG4gICAgbGFzdE1lc3NhZ2UgIT0gbnVsbCAmJiAvLyBlbnN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBuZXcgc3RlcHMgKHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMgaW4gY2FzZSBvZiBlcnJvcnMpOlxuICAgIChtZXNzYWdlcy5sZW5ndGggPiBvcmlnaW5hbE1lc3NhZ2VDb3VudCB8fCBleHRyYWN0TWF4VG9vbEludm9jYXRpb25TdGVwKGxhc3RNZXNzYWdlLnRvb2xJbnZvY2F0aW9ucykgIT09IG9yaWdpbmFsTWF4VG9vbEludm9jYXRpb25TdGVwKSAmJiAvLyBjaGVjayB0aGF0IG5leHQgc3RlcCBpcyBwb3NzaWJsZTpcbiAgICBpc0Fzc2lzdGFudE1lc3NhZ2VXaXRoQ29tcGxldGVkVG9vbENhbGxzKGxhc3RNZXNzYWdlKSAmJiAvLyBjaGVjayB0aGF0IGFzc2lzdGFudCBoYXMgbm90IGFuc3dlcmVkIHlldDpcbiAgICAhaXNMYXN0VG9vbEludm9jYXRpb25Gb2xsb3dlZEJ5VGV4dChsYXN0TWVzc2FnZSkgJiYgLy8gbGltaXQgdGhlIG51bWJlciBvZiBhdXRvbWF0aWMgc3RlcHM6XG4gICAgKChfYSA9IGV4dHJhY3RNYXhUb29sSW52b2NhdGlvblN0ZXAobGFzdE1lc3NhZ2UudG9vbEludm9jYXRpb25zKSkgIT0gbnVsbCA/IF9hIDogMCkgPCBtYXhTdGVwc1xuICApO1xufVxuZnVuY3Rpb24gaXNMYXN0VG9vbEludm9jYXRpb25Gb2xsb3dlZEJ5VGV4dChtZXNzYWdlKSB7XG4gIGxldCBpc0xhc3RUb29sSW52b2NhdGlvbkZvbGxvd2VkQnlUZXh0MiA9IGZhbHNlO1xuICBtZXNzYWdlLnBhcnRzLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICBpZiAocGFydC50eXBlID09PSBcInRleHRcIikge1xuICAgICAgaXNMYXN0VG9vbEludm9jYXRpb25Gb2xsb3dlZEJ5VGV4dDIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtaW52b2NhdGlvblwiKSB7XG4gICAgICBpc0xhc3RUb29sSW52b2NhdGlvbkZvbGxvd2VkQnlUZXh0MiA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpc0xhc3RUb29sSW52b2NhdGlvbkZvbGxvd2VkQnlUZXh0Mjtcbn1cbmZ1bmN0aW9uIGlzQXNzaXN0YW50TWVzc2FnZVdpdGhDb21wbGV0ZWRUb29sQ2FsbHMobWVzc2FnZSkge1xuICByZXR1cm4gbWVzc2FnZS5yb2xlID09PSBcImFzc2lzdGFudFwiICYmIG1lc3NhZ2UucGFydHMuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1pbnZvY2F0aW9uXCIpLmV2ZXJ5KChwYXJ0KSA9PiBcInJlc3VsdFwiIGluIHBhcnQudG9vbEludm9jYXRpb24pO1xufVxuXG4vLyBzcmMvdXBkYXRlLXRvb2wtY2FsbC1yZXN1bHQudHNcbmZ1bmN0aW9uIHVwZGF0ZVRvb2xDYWxsUmVzdWx0KHtcbiAgbWVzc2FnZXMsXG4gIHRvb2xDYWxsSWQsXG4gIHRvb2xSZXN1bHQ6IHJlc3VsdFxufSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGludm9jYXRpb25QYXJ0ID0gbGFzdE1lc3NhZ2UucGFydHMuZmluZChcbiAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtaW52b2NhdGlvblwiICYmIHBhcnQudG9vbEludm9jYXRpb24udG9vbENhbGxJZCA9PT0gdG9vbENhbGxJZFxuICApO1xuICBpZiAoaW52b2NhdGlvblBhcnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0b29sUmVzdWx0ID0ge1xuICAgIC4uLmludm9jYXRpb25QYXJ0LnRvb2xJbnZvY2F0aW9uLFxuICAgIHN0YXRlOiBcInJlc3VsdFwiLFxuICAgIHJlc3VsdFxuICB9O1xuICBpbnZvY2F0aW9uUGFydC50b29sSW52b2NhdGlvbiA9IHRvb2xSZXN1bHQ7XG4gIGxhc3RNZXNzYWdlLnRvb2xJbnZvY2F0aW9ucyA9IChfYSA9IGxhc3RNZXNzYWdlLnRvb2xJbnZvY2F0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1hcChcbiAgICAodG9vbEludm9jYXRpb24pID0+IHRvb2xJbnZvY2F0aW9uLnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsSWQgPyB0b29sUmVzdWx0IDogdG9vbEludm9jYXRpb25cbiAgKTtcbn1cbmV4cG9ydCB7XG4gIGFzU2NoZW1hLFxuICBjYWxsQ2hhdEFwaSxcbiAgY2FsbENvbXBsZXRpb25BcGksXG4gIGV4dHJhY3RNYXhUb29sSW52b2NhdGlvblN0ZXAsXG4gIGZpbGxNZXNzYWdlUGFydHMsXG4gIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQsXG4gIGZvcm1hdERhdGFTdHJlYW1QYXJ0LFxuICBnZW5lcmF0ZUlkLFxuICBnZXRNZXNzYWdlUGFydHMsXG4gIGdldFRleHRGcm9tRGF0YVVybCxcbiAgaXNBc3Npc3RhbnRNZXNzYWdlV2l0aENvbXBsZXRlZFRvb2xDYWxscyxcbiAgaXNEZWVwRXF1YWxEYXRhLFxuICBqc29uU2NoZW1hLFxuICBwYXJzZUFzc2lzdGFudFN0cmVhbVBhcnQsXG4gIHBhcnNlRGF0YVN0cmVhbVBhcnQsXG4gIHBhcnNlUGFydGlhbEpzb24sXG4gIHByZXBhcmVBdHRhY2htZW50c0ZvclJlcXVlc3QsXG4gIHByb2Nlc3NBc3Npc3RhbnRTdHJlYW0sXG4gIHByb2Nlc3NEYXRhU3RyZWFtLFxuICBwcm9jZXNzVGV4dFN0cmVhbSxcbiAgc2hvdWxkUmVzdWJtaXRNZXNzYWdlcyxcbiAgdXBkYXRlVG9vbENhbGxSZXN1bHQsXG4gIHpvZFNjaGVtYVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiZ2VuZXJhdGVJZCIsInRleHRTdHJlYW1QYXJ0IiwiY29kZSIsIm5hbWUiLCJwYXJzZSIsInZhbHVlIiwiRXJyb3IiLCJ0eXBlIiwiZXJyb3JTdHJlYW1QYXJ0IiwiYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQiLCJpZCIsInJvbGUiLCJBcnJheSIsImlzQXJyYXkiLCJjb250ZW50IiwiZXZlcnkiLCJpdGVtIiwidGV4dCIsImFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCIsInRocmVhZElkIiwibWVzc2FnZUlkIiwiZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0IiwiYXNzaXN0YW50U3RyZWFtUGFydHMiLCJhc3Npc3RhbnRTdHJlYW1QYXJ0c0J5Q29kZSIsIlN0cmVhbVN0cmluZ1ByZWZpeGVzIiwidmFsaWRDb2RlcyIsIm1hcCIsInBhcnQiLCJwYXJzZUFzc2lzdGFudFN0cmVhbVBhcnQiLCJsaW5lIiwiZmlyc3RTZXBhcmF0b3JJbmRleCIsImluZGV4T2YiLCJwcmVmaXgiLCJzbGljZSIsImluY2x1ZGVzIiwidGV4dFZhbHVlIiwianNvblZhbHVlIiwiSlNPTiIsImZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQiLCJzdHJlYW1QYXJ0IiwiZmluZCIsInN0cmluZ2lmeSIsImdlbmVyYXRlSWRGdW5jdGlvbiIsImNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSIsInByb21wdFRva2VucyIsImNvbXBsZXRpb25Ub2tlbnMiLCJ0b3RhbFRva2VucyIsInNhZmVQYXJzZUpTT04iLCJmaXhKc29uIiwiaW5wdXQiLCJzdGFjayIsImxhc3RWYWxpZEluZGV4IiwibGl0ZXJhbFN0YXJ0IiwicHJvY2Vzc1ZhbHVlU3RhcnQiLCJjaGFyIiwiaSIsInN3YXBTdGF0ZSIsInBvcCIsInB1c2giLCJwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZSIsInByb2Nlc3NBZnRlckFycmF5VmFsdWUiLCJsZW5ndGgiLCJjdXJyZW50U3RhdGUiLCJwYXJ0aWFsTGl0ZXJhbCIsInN1YnN0cmluZyIsInN0YXJ0c1dpdGgiLCJyZXN1bHQiLCJzdGF0ZSIsInBhcnNlUGFydGlhbEpzb24iLCJqc29uVGV4dCIsInN1Y2Nlc3MiLCJ0ZXh0U3RyZWFtUGFydDIiLCJkYXRhU3RyZWFtUGFydCIsImVycm9yU3RyZWFtUGFydDIiLCJtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0IiwidG9vbENhbGxTdHJlYW1QYXJ0IiwidG9vbENhbGxJZCIsInRvb2xOYW1lIiwiYXJncyIsInRvb2xSZXN1bHRTdHJlYW1QYXJ0IiwidG9vbENhbGxTdHJlYW1pbmdTdGFydFN0cmVhbVBhcnQiLCJ0b29sQ2FsbERlbHRhU3RyZWFtUGFydCIsImFyZ3NUZXh0RGVsdGEiLCJmaW5pc2hNZXNzYWdlU3RyZWFtUGFydCIsImZpbmlzaFJlYXNvbiIsInVzYWdlIiwiTnVtYmVyIiwiTmFOIiwiZmluaXNoU3RlcFN0cmVhbVBhcnQiLCJpc0NvbnRpbnVlZCIsInN0YXJ0U3RlcFN0cmVhbVBhcnQiLCJyZWFzb25pbmdTdHJlYW1QYXJ0Iiwic291cmNlUGFydCIsImRhdGFTdHJlYW1QYXJ0cyIsImRhdGFTdHJlYW1QYXJ0c0J5Q29kZSIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiRGF0YVN0cmVhbVN0cmluZ1ByZWZpeGVzIiwidmFsaWRDb2RlczIiLCJwYXJzZURhdGFTdHJlYW1QYXJ0IiwiZm9ybWF0RGF0YVN0cmVhbVBhcnQiLCJORVdMSU5FIiwiY2hhckNvZGVBdCIsImNvbmNhdENodW5rcyIsImNodW5rcyIsInRvdGFsTGVuZ3RoIiwiY29uY2F0ZW5hdGVkQ2h1bmtzIiwiVWludDhBcnJheSIsIm9mZnNldCIsImNodW5rIiwic2V0IiwicHJvY2Vzc0RhdGFTdHJlYW0iLCJzdHJlYW0iLCJvblRleHRQYXJ0Iiwib25SZWFzb25pbmdQYXJ0Iiwib25Tb3VyY2VQYXJ0Iiwib25EYXRhUGFydCIsIm9uRXJyb3JQYXJ0Iiwib25Ub29sQ2FsbFN0cmVhbWluZ1N0YXJ0UGFydCIsIm9uVG9vbENhbGxEZWx0YVBhcnQiLCJvblRvb2xDYWxsUGFydCIsIm9uVG9vbFJlc3VsdFBhcnQiLCJvbk1lc3NhZ2VBbm5vdGF0aW9uc1BhcnQiLCJvbkZpbmlzaE1lc3NhZ2VQYXJ0Iiwib25GaW5pc2hTdGVwUGFydCIsIm9uU3RhcnRTdGVwUGFydCIsInJlYWRlciIsImdldFJlYWRlciIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsInJlYWQiLCJzdHJlYW1QYXJ0cyIsImRlY29kZSIsInNwbGl0IiwiZmlsdGVyIiwidmFsdWUyIiwiZXhoYXVzdGl2ZUNoZWNrIiwicHJvY2Vzc0NoYXRSZXNwb25zZSIsInVwZGF0ZSIsIm9uVG9vbENhbGwiLCJvbkZpbmlzaCIsImdlbmVyYXRlSWQyIiwiZ2V0Q3VycmVudERhdGUiLCJEYXRlIiwibGFzdE1lc3NhZ2UiLCJfYSIsIl9iIiwicmVwbGFjZUxhc3RNZXNzYWdlIiwic3RlcCIsInRvb2xJbnZvY2F0aW9ucyIsInJlZHVjZSIsIm1heCIsInRvb2xJbnZvY2F0aW9uIiwiX2EyIiwiTWF0aCIsIm1lc3NhZ2UiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJjcmVhdGVkQXQiLCJwYXJ0cyIsImN1cnJlbnRUZXh0UGFydCIsImN1cnJlbnRSZWFzb25pbmdQYXJ0IiwidXBkYXRlVG9vbEludm9jYXRpb25QYXJ0IiwiaW52b2NhdGlvbiIsInBhcnQyIiwiZGF0YSIsIm1lc3NhZ2VBbm5vdGF0aW9ucyIsImFubm90YXRpb25zIiwicGFydGlhbFRvb2xDYWxscyIsImV4ZWNVcGRhdGUiLCJjb3BpZWREYXRhIiwiY29waWVkTWVzc2FnZSIsInJldmlzaW9uSWQiLCJyZWFzb25pbmciLCJzb3VyY2UiLCJpbmRleCIsInBhcnRpYWxUb29sQ2FsbCIsInBhcnRpYWxBcmdzIiwidG9vbENhbGwiLCJpbnZvY2F0aW9uMiIsInRvb2xJbnZvY2F0aW9uSW5kZXgiLCJmaW5kSW5kZXgiLCJlcnJvciIsImdlbmVyYXRlSWRGdW5jdGlvbjIiLCJwcm9jZXNzVGV4dFN0cmVhbSIsInBpcGVUaHJvdWdoIiwiVGV4dERlY29kZXJTdHJlYW0iLCJkb25lIiwicHJvY2Vzc0NoYXRUZXh0UmVzcG9uc2UiLCJ0ZXh0UGFydCIsInJlc3VsdE1lc3NhZ2UiLCJnZXRPcmlnaW5hbEZldGNoIiwiZmV0Y2giLCJjYWxsQ2hhdEFwaSIsImFwaSIsImJvZHkiLCJzdHJlYW1Qcm90b2NvbCIsImNyZWRlbnRpYWxzIiwiaGVhZGVycyIsImFib3J0Q29udHJvbGxlciIsInJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSIsIm9uUmVzcG9uc2UiLCJvblVwZGF0ZSIsImZldGNoMiIsInJlc3BvbnNlIiwibWV0aG9kIiwic2lnbmFsIiwiY2F0Y2giLCJlcnIiLCJvayIsImdldE9yaWdpbmFsRmV0Y2gyIiwiY2FsbENvbXBsZXRpb25BcGkiLCJwcm9tcHQiLCJzZXRDb21wbGV0aW9uIiwic2V0TG9hZGluZyIsInNldEVycm9yIiwic2V0QWJvcnRDb250cm9sbGVyIiwib25FcnJvciIsIm9uRGF0YSIsIkFib3J0Q29udHJvbGxlciIsImdldFRleHRGcm9tRGF0YVVybCIsImRhdGFVcmwiLCJoZWFkZXIiLCJiYXNlNjRDb250ZW50IiwibWltZVR5cGUiLCJ3aW5kb3ciLCJhdG9iIiwiZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcCIsImdldE1lc3NhZ2VQYXJ0cyIsImZpbGxNZXNzYWdlUGFydHMiLCJtZXNzYWdlcyIsImlzRGVlcEVxdWFsRGF0YSIsIm9iajEiLCJvYmoyIiwiY29uc3RydWN0b3IiLCJnZXRUaW1lIiwia2V5czEiLCJrZXlzIiwia2V5czIiLCJrZXkiLCJwcmVwYXJlQXR0YWNobWVudHNGb3JSZXF1ZXN0IiwiYXR0YWNobWVudHNGcm9tT3B0aW9ucyIsIkZpbGVMaXN0IiwiUHJvbWlzZSIsImFsbCIsImZyb20iLCJhdHRhY2htZW50IiwicmVzb2x2ZSIsInJlamVjdCIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJyZWFkZXJFdmVudCIsInRhcmdldCIsIm9uZXJyb3IiLCJyZWFkQXNEYXRhVVJMIiwiY29udGVudFR5cGUiLCJ1cmwiLCJORVdMSU5FMiIsImNvbmNhdENodW5rczIiLCJwcm9jZXNzQXNzaXN0YW50U3RyZWFtIiwib25Bc3Npc3RhbnRNZXNzYWdlUGFydCIsIm9uQXNzaXN0YW50Q29udHJvbERhdGFQYXJ0Iiwib25EYXRhTWVzc2FnZVBhcnQiLCJ2YWxpZGF0b3JTeW1ib2wiLCJ6b2RUb0pzb25TY2hlbWEiLCJ6b2RTY2hlbWEiLCJ6b2RTY2hlbWEyIiwib3B0aW9ucyIsInVzZVJlZmVyZW5jZXMiLCJqc29uU2NoZW1hIiwiJHJlZlN0cmF0ZWd5IiwidmFsaWRhdGUiLCJzYWZlUGFyc2UiLCJzY2hlbWFTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJqc29uU2NoZW1hMiIsIl90eXBlIiwiaXNTY2hlbWEiLCJhc1NjaGVtYSIsInNjaGVtYSIsInNob3VsZFJlc3VibWl0TWVzc2FnZXMiLCJvcmlnaW5hbE1heFRvb2xJbnZvY2F0aW9uU3RlcCIsIm9yaWdpbmFsTWVzc2FnZUNvdW50IiwibWF4U3RlcHMiLCJpc0Fzc2lzdGFudE1lc3NhZ2VXaXRoQ29tcGxldGVkVG9vbENhbGxzIiwiaXNMYXN0VG9vbEludm9jYXRpb25Gb2xsb3dlZEJ5VGV4dCIsImlzTGFzdFRvb2xJbnZvY2F0aW9uRm9sbG93ZWRCeVRleHQyIiwiZm9yRWFjaCIsInVwZGF0ZVRvb2xDYWxsUmVzdWx0IiwidG9vbFJlc3VsdCIsImludm9jYXRpb25QYXJ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\n");

/***/ })

};
;